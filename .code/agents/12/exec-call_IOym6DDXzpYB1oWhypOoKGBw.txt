frontend/app/search/page.tsx:39:        downloadingFiles,
frontend/app/search/page.tsx:40:        handleDownload,
frontend/app/search/page.tsx:186:                            downloadingFiles={downloadingFiles}
frontend/app/search/page.tsx:187:                            onDownload={handleDownload}
services/audio-analyzer/Dockerfile:32:# Download Discogs EfficientNet models from essentia.upf.edu/models/
services/audio-analyzer/Dockerfile:63:# Verify models downloaded
services/audio-analyzer/Dockerfile:64:RUN echo "Models downloaded:" && ls -lh /app/models/
services/audio-analyzer/analyzer.py:81:# Useful for low-resource systems that don't need mood-based playlists
services/audio-analyzer/analyzer.py:1312:        logger.info("Mood-based playlists will not be available.")
frontend/app/releases/page.tsx:4:import { Calendar, Clock, Download, Music2, Disc, ArrowRight, CheckCircle2, Loader2 } from "lucide-react";
frontend/app/releases/page.tsx:20:    canDownload: boolean;
frontend/app/releases/page.tsx:33:    const [downloadingId, setDownloadingId] = useState<string | number | null>(null);
frontend/app/releases/page.tsx:54:    const handleDownload = async (albumMbid: string, releaseId: string | number) => {
frontend/app/releases/page.tsx:56:            setDownloadingId(releaseId);
frontend/app/releases/page.tsx:57:            const res = await fetch(`/api/releases/download/${albumMbid}`, {
frontend/app/releases/page.tsx:65:            console.error("Download failed:", err);
frontend/app/releases/page.tsx:67:            setDownloadingId(null);
frontend/app/releases/page.tsx:147:                                    onDownload={handleDownload}
frontend/app/releases/page.tsx:148:                                    isDownloading={downloadingId === release.id}
frontend/app/releases/page.tsx:170:                                    onDownload={handleDownload}
frontend/app/releases/page.tsx:171:                                    isDownloading={downloadingId === release.id}
frontend/app/releases/page.tsx:203:    onDownload,
frontend/app/releases/page.tsx:204:    isDownloading,
frontend/app/releases/page.tsx:208:    onDownload: (albumMbid: string, releaseId: string | number) => void;
frontend/app/releases/page.tsx:209:    isDownloading: boolean;
frontend/app/releases/page.tsx:240:                {/* Download Button Overlay */}
frontend/app/releases/page.tsx:241:                {release.canDownload && !hasIt && (
frontend/app/releases/page.tsx:243:                        onClick={() => onDownload(release.albumMbid, release.id)}
frontend/app/releases/page.tsx:244:                        disabled={isDownloading}
frontend/app/releases/page.tsx:248:                            isDownloading && "opacity-100"
frontend/app/releases/page.tsx:251:                        {isDownloading ? (
frontend/app/releases/page.tsx:254:                            <Download className="w-8 h-8 text-white" />
frontend/features/settings/types.ts:33:    // Spotify (for playlist import)
frontend/features/settings/types.ts:34:    spotifyClientId: string;
frontend/features/settings/types.ts:35:    spotifyClientSecret: string;
frontend/features/settings/types.ts:38:    downloadPath: string;
frontend/features/settings/types.ts:44:    // Download Preferences
frontend/features/settings/types.ts:45:    downloadSource: "soulseek" | "lidarr";
frontend/components/PWAInstallPrompt.tsx:4:import { X, Download, Smartphone } from "lucide-react";
frontend/components/PWAInstallPrompt.tsx:113:                        <Download className="w-4 h-4" />
frontend/app/album/[id]/page.tsx:9:import { PlaylistSelector } from "@/components/ui/PlaylistSelector";
frontend/app/album/[id]/page.tsx:10:import { useDownloadContext } from "@/lib/download-context";
frontend/app/album/[id]/page.tsx:35:    const [showPlaylistSelector, setShowPlaylistSelector] = useState(false);
frontend/app/album/[id]/page.tsx:38:    const [isAddingToPlaylist, setIsAddingToPlaylist] = useState(false);
frontend/app/album/[id]/page.tsx:42:    const { playAlbum, shufflePlay, addToQueue, downloadAlbum } =
frontend/app/album/[id]/page.tsx:44:    const { isPendingByMbid } = useDownloadContext();
frontend/app/album/[id]/page.tsx:88:    const openPlaylistSelector = (trackIds: string[], bulk = false) => {
frontend/app/album/[id]/page.tsx:92:        setShowPlaylistSelector(true);
frontend/app/album/[id]/page.tsx:95:    const handleAddAlbumToPlaylist = () => {
frontend/app/album/[id]/page.tsx:100:        openPlaylistSelector(trackIds, true);
frontend/app/album/[id]/page.tsx:103:    const handleAddToPlaylist = (trackId: string) => {
frontend/app/album/[id]/page.tsx:104:        openPlaylistSelector([trackId]);
frontend/app/album/[id]/page.tsx:107:    const handlePlaylistSelected = async (playlistId: string) => {
frontend/app/album/[id]/page.tsx:111:            setIsAddingToPlaylist(true);
frontend/app/album/[id]/page.tsx:113:                await api.addTrackToPlaylist(playlistId, trackId);
frontend/app/album/[id]/page.tsx:117:            setShowPlaylistSelector(false);
frontend/app/album/[id]/page.tsx:119:            console.error("Failed to add track(s) to playlist:", error);
frontend/app/album/[id]/page.tsx:121:            setIsAddingToPlaylist(false);
frontend/app/album/[id]/page.tsx:140:                    onDownloadAlbum={() => downloadAlbum(album)}
frontend/app/album/[id]/page.tsx:141:                    onAddToPlaylist={handleAddAlbumToPlaylist}
frontend/app/album/[id]/page.tsx:142:                    isPendingDownload={isPendingByMbid(
frontend/app/album/[id]/page.tsx:185:                            onAddToPlaylist={handleAddToPlaylist}
frontend/app/album/[id]/page.tsx:208:            <PlaylistSelector
frontend/app/album/[id]/page.tsx:209:                isOpen={showPlaylistSelector}
frontend/app/album/[id]/page.tsx:211:                    setShowPlaylistSelector(false);
frontend/app/album/[id]/page.tsx:215:                onSelectPlaylist={handlePlaylistSelected}
frontend/app/recommendations/page.tsx:235:            toast("No Deezer preview available", { duration: 1500 });
frontend/app/recommendations/page.tsx:247:                toast("No Deezer preview available", { duration: 1500 });
frontend/app/recommendations/page.tsx:279:                toast("No Deezer preview available", { duration: 1500 });
frontend/app/recommendations/page.tsx:302:                toast("No Deezer preview available", { duration: 1500 });
frontend/app/recommendations/page.tsx:470:                                                title="Play Deezer preview"
frontend/features/settings/hooks/useSystemSettings.ts:20:    spotifyClientId: "",
frontend/features/settings/hooks/useSystemSettings.ts:21:    spotifyClientSecret: "",
frontend/features/settings/hooks/useSystemSettings.ts:23:    downloadPath: "/downloads",
frontend/features/settings/hooks/useSystemSettings.ts:28:    // Download preferences
frontend/features/settings/hooks/useSystemSettings.ts:29:    downloadSource: "soulseek",
frontend/features/settings/hooks/useSystemSettings.ts:180:                case "spotify":
frontend/features/settings/hooks/useSystemSettings.ts:181:                    result = await api.testSpotify(
frontend/features/settings/hooks/useSystemSettings.ts:182:                        systemSettings.spotifyClientId,
frontend/features/settings/hooks/useSystemSettings.ts:183:                        systemSettings.spotifyClientSecret
frontend/app/artist/[id]/page.tsx:6:import { useDownloadContext } from "@/lib/download-context";
frontend/app/artist/[id]/page.tsx:16:import { useDownloadActions } from "@/features/artist/hooks/useDownloadActions";
frontend/app/artist/[id]/page.tsx:31:  const { isPendingByMbid } = useDownloadContext();
frontend/app/artist/[id]/page.tsx:38:  const { downloadArtist, downloadAlbum } = useDownloadActions();
frontend/app/artist/[id]/page.tsx:99:  // Download album handler
frontend/app/artist/[id]/page.tsx:100:  function handleDownloadAlbum(album: any, e: React.MouseEvent) {
frontend/app/artist/[id]/page.tsx:101:    downloadAlbum(album, artist?.name || "", e);
frontend/app/artist/[id]/page.tsx:177:          onDownloadAll={() => downloadArtist(artist)}
frontend/app/artist/[id]/page.tsx:179:          isPendingDownload={isPendingByMbid(artist.mbid || "")}
frontend/app/artist/[id]/page.tsx:228:          {/* Available Albums to Download */}
frontend/app/artist/[id]/page.tsx:234:            onDownloadAlbum={handleDownloadAlbum}
frontend/app/artist/[id]/page.tsx:236:            isPendingDownload={isPendingByMbid}
frontend/app/discover/page.tsx:367:            toast("No Deezer preview available", { duration: 1500 });
frontend/app/discover/page.tsx:379:                toast("No Deezer preview available", { duration: 1500 });
frontend/app/discover/page.tsx:413:                toast("No Deezer preview available", { duration: 1500 });
frontend/app/discover/page.tsx:436:                toast("No Deezer preview available", { duration: 1500 });
frontend/app/discover/page.tsx:618:                                                title="Play Deezer preview"
frontend/app/discover/page.tsx:661:                            Top albums from artists similar to your favorites — preview before you download
frontend/app/discover/page.tsx:870:                        Preview tracks via Deezer, then add to your library if you like them.
frontend/app/discover/page.tsx:873:                        No automatic downloads — you decide what to keep.
frontend/components/activity/HistoryTab.tsx:8:interface DownloadHistory {
frontend/components/activity/HistoryTab.tsx:19:    const [history, setHistory] = useState<DownloadHistory[]>([]);
frontend/components/activity/HistoryTab.tsx:25:            const data = await api.getDownloadHistory();
frontend/components/activity/HistoryTab.tsx:28:            console.error("Failed to fetch download history:", error);
frontend/components/activity/HistoryTab.tsx:45:            await api.clearDownloadFromHistory(id);
frontend/components/activity/HistoryTab.tsx:47:            // Notify other components that download status has changed
frontend/components/activity/HistoryTab.tsx:48:            window.dispatchEvent(new CustomEvent("download-status-changed"));
frontend/components/activity/HistoryTab.tsx:50:            console.error("Failed to clear download:", error);
frontend/components/activity/HistoryTab.tsx:56:            await api.clearAllDownloadHistory();
frontend/components/activity/HistoryTab.tsx:58:            // Notify other components that download status has changed
frontend/components/activity/HistoryTab.tsx:59:            window.dispatchEvent(new CustomEvent("download-status-changed"));
frontend/components/activity/HistoryTab.tsx:68:            const result = await api.retryFailedDownload(id);
frontend/components/activity/HistoryTab.tsx:74:            console.error("Failed to retry download:", error);
frontend/components/activity/HistoryTab.tsx:110:                <p className="text-sm text-white/40">No download history</p>
frontend/components/activity/HistoryTab.tsx:111:                <p className="text-xs text-white/30 mt-1">Completed downloads will appear here</p>
frontend/components/activity/HistoryTab.tsx:188:    item: DownloadHistory;
frontend/components/activity/HistoryTab.tsx:250:                            title="Retry download"
frontend/app/layout.tsx:6:import { DownloadProvider } from "@/lib/download-context";
frontend/app/layout.tsx:81:                        <DownloadProvider>
frontend/app/layout.tsx:89:                        </DownloadProvider>
frontend/components/activity/NotificationsTab.tsx:47:    // Dispatch events when new playlist-related notifications arrive
frontend/components/activity/NotificationsTab.tsx:53:        // Check for new playlist-related notifications
frontend/components/activity/NotificationsTab.tsx:58:                    notification.type === "playlist_ready" ||
frontend/components/activity/NotificationsTab.tsx:62:                        "[NotificationsTab] New playlist notification, dispatching event"
frontend/components/activity/NotificationsTab.tsx:64:                    window.dispatchEvent(new CustomEvent("playlist-created"));
frontend/components/activity/NotificationsTab.tsx:170:            case "download_complete":
frontend/components/activity/NotificationsTab.tsx:172:            case "download_failed":
frontend/components/activity/NotificationsTab.tsx:174:            case "playlist_ready":
frontend/components/activity/NotificationsTab.tsx:184:        if (notification.metadata?.playlistId) {
frontend/components/activity/NotificationsTab.tsx:185:            return `/playlist/${notification.metadata.playlistId}`;
frontend/components/activity/ActiveDownloadsTab.tsx:4:import { Download, Loader2, Music, Disc, X, Trash2 } from "lucide-react";
frontend/components/activity/ActiveDownloadsTab.tsx:9:interface ActiveDownload {
frontend/components/activity/ActiveDownloadsTab.tsx:17:export function ActiveDownloadsTab() {
frontend/components/activity/ActiveDownloadsTab.tsx:18:    const [downloads, setDownloads] = useState<ActiveDownload[]>([]);
frontend/components/activity/ActiveDownloadsTab.tsx:22:    const fetchDownloads = async () => {
frontend/components/activity/ActiveDownloadsTab.tsx:24:            const data = await api.getActiveDownloads();
frontend/components/activity/ActiveDownloadsTab.tsx:25:            setDownloads(data);
frontend/components/activity/ActiveDownloadsTab.tsx:27:            console.error("Failed to fetch active downloads:", error);
frontend/components/activity/ActiveDownloadsTab.tsx:36:            await api.deleteDownload(id);
frontend/components/activity/ActiveDownloadsTab.tsx:38:            setDownloads(prev => prev.filter(d => d.id !== id));
frontend/components/activity/ActiveDownloadsTab.tsx:40:            console.error("Failed to cancel download:", error);
frontend/components/activity/ActiveDownloadsTab.tsx:51:        const ids = downloads.map(d => d.id);
frontend/components/activity/ActiveDownloadsTab.tsx:54:            // Cancel all downloads in parallel
frontend/components/activity/ActiveDownloadsTab.tsx:55:            await Promise.all(ids.map(id => api.deleteDownload(id)));
frontend/components/activity/ActiveDownloadsTab.tsx:56:            setDownloads([]);
frontend/components/activity/ActiveDownloadsTab.tsx:58:            console.error("Failed to cancel all downloads:", error);
frontend/components/activity/ActiveDownloadsTab.tsx:60:            fetchDownloads();
frontend/components/activity/ActiveDownloadsTab.tsx:67:        fetchDownloads();
frontend/components/activity/ActiveDownloadsTab.tsx:70:        const interval = setInterval(fetchDownloads, 5000);
frontend/components/activity/ActiveDownloadsTab.tsx:93:    if (downloads.length === 0) {
frontend/components/activity/ActiveDownloadsTab.tsx:96:                <Download className="w-8 h-8 text-white/20 mb-3" />
frontend/components/activity/ActiveDownloadsTab.tsx:97:                <p className="text-sm text-white/40">No active downloads</p>
frontend/components/activity/ActiveDownloadsTab.tsx:98:                <p className="text-xs text-white/30 mt-1">Downloads will appear here</p>
frontend/components/activity/ActiveDownloadsTab.tsx:108:                    {downloads.length} downloading
frontend/components/activity/ActiveDownloadsTab.tsx:114:                        title="Cancel all downloads"
frontend/components/activity/ActiveDownloadsTab.tsx:125:            {/* Download list */}
frontend/components/activity/ActiveDownloadsTab.tsx:127:                {downloads.map((download) => (
frontend/components/activity/ActiveDownloadsTab.tsx:129:                        key={download.id}
frontend/components/activity/ActiveDownloadsTab.tsx:134:                                {cancelling.has(download.id) ? (
frontend/components/activity/ActiveDownloadsTab.tsx:142:                                    {download.subject}
frontend/components/activity/ActiveDownloadsTab.tsx:147:                                        download.status === "processing" ? "text-blue-400" : "text-yellow-400"
frontend/components/activity/ActiveDownloadsTab.tsx:149:                                        {download.status}
frontend/components/activity/ActiveDownloadsTab.tsx:153:                                        {download.type === "album" ? (
frontend/components/activity/ActiveDownloadsTab.tsx:158:                                        {download.type}
frontend/components/activity/ActiveDownloadsTab.tsx:162:                                        {formatTime(download.createdAt)}
frontend/components/activity/ActiveDownloadsTab.tsx:167:                                onClick={() => handleCancel(download.id)}
frontend/components/activity/ActiveDownloadsTab.tsx:168:                                disabled={cancelling.has(download.id)}
frontend/components/activity/ActiveDownloadsTab.tsx:170:                                title="Cancel download"
frontend/app/import/spotify/page.tsx:10:    Download,
frontend/app/import/spotify/page.tsx:19:// Types for Spotify Import
frontend/app/import/spotify/page.tsx:20:interface SpotifyTrack {
frontend/app/import/spotify/page.tsx:21:    spotifyId: string;
frontend/app/import/spotify/page.tsx:35:    spotifyTrack: SpotifyTrack;
frontend/app/import/spotify/page.tsx:47:interface AlbumToDownload {
frontend/app/import/spotify/page.tsx:48:    spotifyAlbumId: string;
frontend/app/import/spotify/page.tsx:55:    tracksNeeded: SpotifyTrack[];
frontend/app/import/spotify/page.tsx:59:    playlist: {
frontend/app/import/spotify/page.tsx:68:    albumsToDownload: AlbumToDownload[];
frontend/app/import/spotify/page.tsx:72:        downloadable: number;
frontend/app/import/spotify/page.tsx:81:        | "downloading"
frontend/app/import/spotify/page.tsx:83:        | "creating_playlist"
frontend/app/import/spotify/page.tsx:93:    tracksDownloadable: number;
frontend/app/import/spotify/page.tsx:94:    createdPlaylistId: string | null;
frontend/app/import/spotify/page.tsx:100:function SpotifyImportPageContent() {
frontend/app/import/spotify/page.tsx:114:    const [playlistName, setPlaylistName] = useState("");
frontend/app/import/spotify/page.tsx:120:        "matched" | "download" | "notfound" | null
frontend/app/import/spotify/page.tsx:134:                        "/spotify/preview",
frontend/app/import/spotify/page.tsx:136:                        { timeout: 180000 } // 3 min timeout for large playlists
frontend/app/import/spotify/page.tsx:139:                    setPlaylistName(result.playlist.name);
frontend/app/import/spotify/page.tsx:142:                    const downloadableAlbumIds = result.albumsToDownload.map(
frontend/app/import/spotify/page.tsx:143:                        (a) => a.albumMbid || a.spotifyAlbumId
frontend/app/import/spotify/page.tsx:145:                    setSelectedAlbums(new Set(downloadableAlbumIds));
frontend/app/import/spotify/page.tsx:152:                            : "Failed to fetch playlist";
frontend/app/import/spotify/page.tsx:175:                    `/spotify/import/${importJob.id}/status`
frontend/app/import/spotify/page.tsx:184:                    window.dispatchEvent(new CustomEvent("playlist-created"));
frontend/app/import/spotify/page.tsx:190:                    window.dispatchEvent(new CustomEvent("playlist-created"));
frontend/app/import/spotify/page.tsx:213:            toast.error("Please enter a playlist URL");
frontend/app/import/spotify/page.tsx:220:                "/spotify/preview",
frontend/app/import/spotify/page.tsx:222:                { timeout: 180000 } // 3 min timeout for large playlists
frontend/app/import/spotify/page.tsx:225:            setPlaylistName(result.playlist.name);
frontend/app/import/spotify/page.tsx:228:            const downloadableAlbumIds = result.albumsToDownload.map(
frontend/app/import/spotify/page.tsx:229:                (a) => a.albumMbid || a.spotifyAlbumId
frontend/app/import/spotify/page.tsx:231:            setSelectedAlbums(new Set(downloadableAlbumIds));
frontend/app/import/spotify/page.tsx:236:                err instanceof Error ? err.message : "Failed to fetch playlist";
frontend/app/import/spotify/page.tsx:251:                "/spotify/import",
frontend/app/import/spotify/page.tsx:253:                    spotifyPlaylistId: preview.playlist.id,
frontend/app/import/spotify/page.tsx:255:                    playlistName: playlistName || preview.playlist.name,
frontend/app/import/spotify/page.tsx:256:                    albumMbidsToDownload: Array.from(selectedAlbums),
frontend/app/import/spotify/page.tsx:268:                tracksDownloadable: preview.summary.downloadable,
frontend/app/import/spotify/page.tsx:269:                createdPlaylistId: null,
frontend/app/import/spotify/page.tsx:299:        // All albums are downloadable via Soulseek (even without MBID)
frontend/app/import/spotify/page.tsx:300:        const allAlbumIds = preview.albumsToDownload.map(
frontend/app/import/spotify/page.tsx:301:            (a) => a.albumMbid || a.spotifyAlbumId
frontend/app/import/spotify/page.tsx:320:                playlistId: string | null;
frontend/app/import/spotify/page.tsx:322:            }>(`/spotify/import/${importJob.id}/cancel`, {});
frontend/app/import/spotify/page.tsx:329:                          createdPlaylistId: null,
frontend/app/import/spotify/page.tsx:336:            // Only dispatch notifications-changed, not playlist-created since no playlist was made
frontend/app/import/spotify/page.tsx:379:                            Import Playlist
frontend/app/import/spotify/page.tsx:382:                            Import from Spotify or Deezer and download missing
frontend/app/import/spotify/page.tsx:391:                        Looking for playlists to import?{" "}
frontend/app/import/spotify/page.tsx:393:                            href="/browse/playlists"
frontend/app/import/spotify/page.tsx:396:                            Browse Deezer playlists & radio stations →
frontend/app/import/spotify/page.tsx:406:                                Playlist URL
frontend/app/import/spotify/page.tsx:412:                                placeholder="https://www.deezer.com/playlist/... or https://open.spotify.com/playlist/..."
frontend/app/import/spotify/page.tsx:420:                                <span className="text-[#AD47FF]">Deezer</span>{" "}
frontend/app/import/spotify/page.tsx:422:                                <span className="text-[#1DB954]">Spotify</span>{" "}
frontend/app/import/spotify/page.tsx:423:                                playlist URL
frontend/app/import/spotify/page.tsx:446:                        {/* Playlist Info */}
frontend/app/import/spotify/page.tsx:448:                            {preview.playlist.imageUrl ? (
frontend/app/import/spotify/page.tsx:450:                                    src={preview.playlist.imageUrl}
frontend/app/import/spotify/page.tsx:451:                                    alt={preview.playlist.name}
frontend/app/import/spotify/page.tsx:458:                                        alt="Spotify"
frontend/app/import/spotify/page.tsx:466:                                    {preview.playlist.name}
frontend/app/import/spotify/page.tsx:469:                                    {preview.playlist.owner} ·{" "}
frontend/app/import/spotify/page.tsx:470:                                    {preview.playlist.trackCount} songs
frontend/app/import/spotify/page.tsx:472:                                {preview.playlist.description && (
frontend/app/import/spotify/page.tsx:474:                                        {preview.playlist.description}
frontend/app/import/spotify/page.tsx:481:                                    `https://open.spotify.com/playlist/${preview.playlist.id}`
frontend/app/import/spotify/page.tsx:512:                                        preview.albumsToDownload.filter(
frontend/app/import/spotify/page.tsx:518:                                    To Download
frontend/app/import/spotify/page.tsx:575:                                                        match.spotifyTrack
frontend/app/import/spotify/page.tsx:576:                                                            .spotifyId
frontend/app/import/spotify/page.tsx:588:                                                                    .spotifyTrack
frontend/app/import/spotify/page.tsx:595:                                                                    .spotifyTrack
frontend/app/import/spotify/page.tsx:601:                                                            match.spotifyTrack
frontend/app/import/spotify/page.tsx:612:                        {/* Songs to download via Soulseek */}
frontend/app/import/spotify/page.tsx:613:                        {preview.albumsToDownload.filter((a) => a.albumMbid)
frontend/app/import/spotify/page.tsx:619:                                            expandedSection === "download"
frontend/app/import/spotify/page.tsx:621:                                                : "download"
frontend/app/import/spotify/page.tsx:627:                                        <Download className="w-4 h-4 text-[#1DB954]" />
frontend/app/import/spotify/page.tsx:630:                                                preview.albumsToDownload.filter(
frontend/app/import/spotify/page.tsx:637:                                            songs to download
frontend/app/import/spotify/page.tsx:640:                                    {expandedSection === "download" ? (
frontend/app/import/spotify/page.tsx:646:                                {expandedSection === "download" && (
frontend/app/import/spotify/page.tsx:654:                                                preview.albumsToDownload.length
frontend/app/import/spotify/page.tsx:663:                                            {preview.albumsToDownload.map(
frontend/app/import/spotify/page.tsx:667:                                                        album.spotifyAlbumId;
frontend/app/import/spotify/page.tsx:754:                                        {preview.albumsToDownload
frontend/app/import/spotify/page.tsx:766:                                                    key={track.spotifyId}
frontend/app/import/spotify/page.tsx:785:                        {/* Playlist name input */}
frontend/app/import/spotify/page.tsx:788:                                Playlist Name
frontend/app/import/spotify/page.tsx:792:                                value={playlistName}
frontend/app/import/spotify/page.tsx:794:                                    setPlaylistName(e.target.value)
frontend/app/import/spotify/page.tsx:796:                                placeholder="Enter playlist name"
frontend/app/import/spotify/page.tsx:828:                                    `Import ${preview.summary.inLibrary} songs + Download ${selectedAlbums.size} songs`
frontend/app/import/spotify/page.tsx:832:                                    `Download ${selectedAlbums.size} songs`
frontend/app/import/spotify/page.tsx:834:                                    "Select songs to download"
frontend/app/import/spotify/page.tsx:846:                            {importJob.status === "downloading"
frontend/app/import/spotify/page.tsx:847:                                ? "Queueing Song Downloads"
frontend/app/import/spotify/page.tsx:850:                                : importJob.status === "creating_playlist" ||
frontend/app/import/spotify/page.tsx:852:                                ? "Creating Playlist"
frontend/app/import/spotify/page.tsx:854:                                ? "Waiting for Downloads"
frontend/app/import/spotify/page.tsx:858:                            {importJob.status === "downloading" && (
frontend/app/import/spotify/page.tsx:869:                                    downloads to complete
frontend/app/import/spotify/page.tsx:873:                                <>Importing downloaded files into library</>
frontend/app/import/spotify/page.tsx:875:                            {(importJob.status === "creating_playlist" ||
frontend/app/import/spotify/page.tsx:887:                            {importJob.progress}% complete • downloads continue
frontend/app/import/spotify/page.tsx:906:                            Playlist will be created with tracks downloaded so
frontend/app/import/spotify/page.tsx:947:                                Import was cancelled. No playlist was created.
frontend/app/import/spotify/page.tsx:953:                                        ? `Added ${importJob.tracksMatched} songs to your playlist`
frontend/app/import/spotify/page.tsx:954:                                        : "Playlist created (songs still downloading)"}
frontend/app/import/spotify/page.tsx:956:                                {importJob.tracksDownloadable > 0 &&
frontend/app/import/spotify/page.tsx:959:                                            {importJob.tracksDownloadable} songs still
frontend/app/import/spotify/page.tsx:960:                                            downloading
frontend/app/import/spotify/page.tsx:978:                            {importJob.tracksDownloadable > 0 &&
frontend/app/import/spotify/page.tsx:990:                                                    `/spotify/import/${importJob.id}/refresh`,
frontend/app/import/spotify/page.tsx:1008:                                                        "Albums still downloading. Try again later."
frontend/app/import/spotify/page.tsx:1032:                            {importJob.createdPlaylistId && (
frontend/app/import/spotify/page.tsx:1036:                                            `/playlist/${importJob.createdPlaylistId}`
frontend/app/import/spotify/page.tsx:1041:                                    View Playlist
frontend/app/import/spotify/page.tsx:1052:export default function SpotifyImportPage() {
frontend/app/import/spotify/page.tsx:1061:            <SpotifyImportPageContent />
frontend/app/page.tsx:17:import { FeaturedPlaylistsGrid } from "@/features/home/components/FeaturedPlaylistsGrid";
frontend/app/page.tsx:85:// Loading skeleton for playlist cards
frontend/app/page.tsx:86:function PlaylistSkeleton() {
frontend/app/page.tsx:126:        featuredPlaylists,
frontend/app/page.tsx:249:                    {/* Featured Playlists - After Popular Artists */}
frontend/app/page.tsx:250:                    {(isBrowseLoading || featuredPlaylists.length > 0) && (
frontend/app/page.tsx:252:                            <SectionHeader title="Featured Playlists" showAllHref="/browse/playlists" badge="Deezer" />
frontend/app/page.tsx:253:                            {isBrowseLoading && featuredPlaylists.length === 0 ? (
frontend/app/page.tsx:254:                                <PlaylistSkeleton />
frontend/app/page.tsx:256:                                <FeaturedPlaylistsGrid playlists={featuredPlaylists} />
backend/src/jobs/queueCleaner.ts:4:    cleanStuckDownloads,
backend/src/jobs/queueCleaner.ts:5:    getRecentCompletedDownloads,
backend/src/jobs/queueCleaner.ts:8:import { simpleDownloadManager } from "../services/simpleDownloadManager";
backend/src/jobs/queueCleaner.ts:62:            // PART 0: Check for stale downloads (timed out)
backend/src/jobs/queueCleaner.ts:64:                await simpleDownloadManager.markStaleJobsAsFailed();
backend/src/jobs/queueCleaner.ts:66:                console.log(`⏰ Cleaned up ${staleCount} stale download(s)`);
backend/src/jobs/queueCleaner.ts:72:                await simpleDownloadManager.reconcileWithLidarr();
backend/src/jobs/queueCleaner.ts:93:            // PART 1: Check for stuck downloads needing blocklist + retry
backend/src/jobs/queueCleaner.ts:94:            const cleanResult = await cleanStuckDownloads(
backend/src/jobs/queueCleaner.ts:101:                    `[CLEANUP] Removed ${cleanResult.removed} stuck download(s) - searching for alternatives`
backend/src/jobs/queueCleaner.ts:120:                        const matchingJobs = await prisma.downloadJob.findMany({
backend/src/jobs/queueCleaner.ts:134:                            await prisma.downloadJob.update({
backend/src/jobs/queueCleaner.ts:156:            // PART 2: Check for completed downloads (missing webhooks)
backend/src/jobs/queueCleaner.ts:157:            const completedDownloads = await getRecentCompletedDownloads(
backend/src/jobs/queueCleaner.ts:166:            for (const download of completedDownloads) {
backend/src/jobs/queueCleaner.ts:168:                if (!download.album?.foreignAlbumId) {
backend/src/jobs/queueCleaner.ts:173:                const mbid = download.album.foreignAlbumId;
backend/src/jobs/queueCleaner.ts:175:                // Find matching job(s) in database by MBID or downloadId
backend/src/jobs/queueCleaner.ts:176:                const orphanedJobs = await prisma.downloadJob.findMany({
backend/src/jobs/queueCleaner.ts:181:                            { lidarrRef: download.downloadId },
backend/src/jobs/queueCleaner.ts:188:                        download.artist?.name || "Unknown Artist";
backend/src/jobs/queueCleaner.ts:189:                    const albumTitle = download.album?.title || "Unknown Album";
backend/src/jobs/queueCleaner.ts:193:                    console.log(`   Download ID: ${download.downloadId}`);
backend/src/jobs/queueCleaner.ts:198:                    await prisma.downloadJob.updateMany({
backend/src/jobs/queueCleaner.ts:259:                    `   (Skipped ${skippedCount} incomplete download records)`
backend/src/jobs/queueCleaner.ts:264:            const activeJobs = await prisma.downloadJob.count({
frontend/components/layout/Sidebar.tsx:28:    { name: "Browse", href: "/browse/playlists", badge: "Beta" },
frontend/components/layout/Sidebar.tsx:31:interface Playlist {
frontend/components/layout/Sidebar.tsx:50:    const [playlists, setPlaylists] = useState<Playlist[]>([]);
frontend/components/layout/Sidebar.tsx:51:    const [isLoadingPlaylists, setIsLoadingPlaylists] = useState(false);
frontend/components/layout/Sidebar.tsx:53:    const hasLoadedPlaylists = useRef(false);
frontend/components/layout/Sidebar.tsx:125:    // Load playlists only once
frontend/components/layout/Sidebar.tsx:129:        const loadPlaylists = async () => {
frontend/components/layout/Sidebar.tsx:130:            if (!isAuthenticated || hasLoadedPlaylists.current) return;
frontend/components/layout/Sidebar.tsx:133:            loadingTimeout = setTimeout(() => setIsLoadingPlaylists(true), 200);
frontend/components/layout/Sidebar.tsx:134:            hasLoadedPlaylists.current = true;
frontend/components/layout/Sidebar.tsx:136:                const data = await api.getPlaylists();
frontend/components/layout/Sidebar.tsx:137:                setPlaylists(data);
frontend/components/layout/Sidebar.tsx:139:                console.error("Failed to load playlists:", error);
frontend/components/layout/Sidebar.tsx:140:                hasLoadedPlaylists.current = false; // Allow retry on error
frontend/components/layout/Sidebar.tsx:143:                setIsLoadingPlaylists(false);
frontend/components/layout/Sidebar.tsx:147:        loadPlaylists();
frontend/components/layout/Sidebar.tsx:149:        // Listen for playlist events to refresh playlists
frontend/components/layout/Sidebar.tsx:150:        const handlePlaylistEvent = async () => {
frontend/components/layout/Sidebar.tsx:152:                "[Sidebar] Playlist event received, refreshing playlists..."
frontend/components/layout/Sidebar.tsx:156:                const data = await api.getPlaylists();
frontend/components/layout/Sidebar.tsx:158:                    "[Sidebar] Playlists refreshed:",
frontend/components/layout/Sidebar.tsx:160:                    "playlists"
frontend/components/layout/Sidebar.tsx:162:                setPlaylists(data);
frontend/components/layout/Sidebar.tsx:164:                console.error("Failed to reload playlists:", error);
frontend/components/layout/Sidebar.tsx:168:        window.addEventListener("playlist-created", handlePlaylistEvent);
frontend/components/layout/Sidebar.tsx:169:        window.addEventListener("playlist-updated", handlePlaylistEvent);
frontend/components/layout/Sidebar.tsx:170:        window.addEventListener("playlist-deleted", handlePlaylistEvent);
frontend/components/layout/Sidebar.tsx:176:            window.removeEventListener("playlist-created", handlePlaylistEvent);
frontend/components/layout/Sidebar.tsx:177:            window.removeEventListener("playlist-updated", handlePlaylistEvent);
frontend/components/layout/Sidebar.tsx:178:            window.removeEventListener("playlist-deleted", handlePlaylistEvent);
frontend/components/layout/Sidebar.tsx:355:            {/* Playlists Section */}
frontend/components/layout/Sidebar.tsx:364:                        href="/playlists"
frontend/components/layout/Sidebar.tsx:369:                            Your playlists
frontend/components/layout/Sidebar.tsx:374:                        href="/playlists"
frontend/components/layout/Sidebar.tsx:377:                        title="Create Playlist"
frontend/components/layout/Sidebar.tsx:388:                    {isLoadingPlaylists ? (
frontend/components/layout/Sidebar.tsx:407:                    ) : playlists.filter((p) => !p.isHidden).length > 0 ? (
frontend/components/layout/Sidebar.tsx:408:                        playlists
frontend/components/layout/Sidebar.tsx:409:                            .filter((p) => !p.isHidden) // Filter out hidden playlists
frontend/components/layout/Sidebar.tsx:410:                            .map((playlist) => {
frontend/components/layout/Sidebar.tsx:412:                                    pathname === `/playlist/${playlist.id}`;
frontend/components/layout/Sidebar.tsx:413:                                const isShared = playlist.isOwner === false;
frontend/components/layout/Sidebar.tsx:416:                                        key={playlist.id}
frontend/components/layout/Sidebar.tsx:417:                                        href={`/playlist/${playlist.id}`}
frontend/components/layout/Sidebar.tsx:440:                                                {playlist.name}
frontend/components/layout/Sidebar.tsx:446:                                                        playlist.user
frontend/components/layout/Sidebar.tsx:463:                                                      playlist.user?.username ||
frontend/components/layout/Sidebar.tsx:466:                                                : "Playlist"}{" "}
frontend/components/layout/Sidebar.tsx:467:                                            • {playlist.trackCount} track
frontend/components/layout/Sidebar.tsx:468:                                            {playlist.trackCount !== 1
frontend/components/layout/Sidebar.tsx:478:                                No playlists yet
frontend/components/layout/Sidebar.tsx:481:                                Create your first playlist to get started
frontend/components/player/VibeOverlayEnhanced.tsx:273:                    // Spotify-inspired dark theme
frontend/components/layout/TVLayout.tsx:21:    { name: "Playlists", href: "/playlists" },
frontend/app/settings/page.tsx:23:import { DownloadPreferencesSection } from "@/features/settings/components/sections/DownloadPreferencesSection";
frontend/app/settings/page.tsx:38:    { id: "download-preferences", label: "Download Preferences", adminOnly: true },
frontend/app/settings/page.tsx:39:    { id: "lidarr", label: "Download Services", adminOnly: true },
frontend/app/settings/page.tsx:164:                        {/* Download Preferences */}
frontend/app/settings/page.tsx:165:                        <DownloadPreferencesSection
frontend/app/settings/page.tsx:170:                        {/* Download Services - Lidarr */}
frontend/components/layout/MobileSidebar.tsx:185:                            href="/browse/playlists"
frontend/components/layout/MobileSidebar.tsx:205:                    {/* Playlists Section */}
frontend/components/layout/MobileSidebar.tsx:209:                                Playlists
frontend/components/layout/MobileSidebar.tsx:212:                                href="/playlists"
frontend/components/layout/MobileSidebar.tsx:214:                                title="Create Playlist"
frontend/components/layout/MobileSidebar.tsx:221:                            href="/playlists"
frontend/components/layout/MobileSidebar.tsx:224:                                pathname === "/playlists"
frontend/components/layout/MobileSidebar.tsx:230:                                View All Playlists
frontend/components/player/HowlerAudioElement.tsx:71:        setDownloadProgress,
frontend/components/player/HowlerAudioElement.tsx:549:            setDownloadProgress(null);
frontend/components/player/HowlerAudioElement.tsx:573:                    setDownloadProgress(null);
frontend/components/player/HowlerAudioElement.tsx:580:                    setDownloadProgress(
frontend/components/player/HowlerAudioElement.tsx:581:                        status.downloadProgress ??
frontend/components/player/HowlerAudioElement.tsx:582:                            (status.downloading ? 0 : null)
frontend/components/player/HowlerAudioElement.tsx:613:    }, [currentPodcast, playbackType, setCanSeek, setDownloadProgress]);
frontend/components/player/HowlerAudioElement.tsx:699:                        downloading: status.downloading,
frontend/components/player/HowlerAudioElement.tsx:700:                        downloadProgress: status.downloadProgress,
backend/src/middleware/rateLimiter.ts:50:// Download limiter (100 req/minute)
backend/src/middleware/rateLimiter.ts:51:// Users might download entire discographies, so this needs to be reasonable
backend/src/middleware/rateLimiter.ts:52:export const downloadLimiter = rateLimit({
backend/src/middleware/rateLimiter.ts:55:    message: "Too many download requests, please try again later.",
frontend/app/browse/playlists/[id]/page.tsx:9:    Download,
frontend/app/browse/playlists/[id]/page.tsx:21:// Deezer icon component
frontend/app/browse/playlists/[id]/page.tsx:22:const DeezerIcon = ({ className }: { className?: string }) => (
frontend/app/browse/playlists/[id]/page.tsx:28:// Types for Deezer playlist
frontend/app/browse/playlists/[id]/page.tsx:29:interface DeezerTrack {
frontend/app/browse/playlists/[id]/page.tsx:30:    deezerId: string;
frontend/app/browse/playlists/[id]/page.tsx:41:interface DeezerPlaylistFull {
frontend/app/browse/playlists/[id]/page.tsx:48:    tracks: DeezerTrack[];
frontend/app/browse/playlists/[id]/page.tsx:54:export default function DeezerPlaylistDetailPage() {
frontend/app/browse/playlists/[id]/page.tsx:58:    const playlistId = params.id as string;
frontend/app/browse/playlists/[id]/page.tsx:61:    const [playlist, setPlaylist] = useState<DeezerPlaylistFull | null>(null);
frontend/app/browse/playlists/[id]/page.tsx:73:    // Fetch playlist data
frontend/app/browse/playlists/[id]/page.tsx:75:        async function fetchPlaylist() {
frontend/app/browse/playlists/[id]/page.tsx:79:                const data = await api.get<DeezerPlaylistFull>(
frontend/app/browse/playlists/[id]/page.tsx:80:                    `/browse/playlists/${playlistId}`
frontend/app/browse/playlists/[id]/page.tsx:82:                setPlaylist(data);
frontend/app/browse/playlists/[id]/page.tsx:87:                        : "Failed to load playlist";
frontend/app/browse/playlists/[id]/page.tsx:94:        fetchPlaylist();
frontend/app/browse/playlists/[id]/page.tsx:95:    }, [playlistId]);
frontend/app/browse/playlists/[id]/page.tsx:108:    const handlePlayPreview = (track: DeezerTrack) => {
frontend/app/browse/playlists/[id]/page.tsx:115:        if (playingTrackId === track.deezerId) {
frontend/app/browse/playlists/[id]/page.tsx:148:        setPlayingTrackId(track.deezerId);
frontend/app/browse/playlists/[id]/page.tsx:170:    // Handle import/download
frontend/app/browse/playlists/[id]/page.tsx:172:        if (!playlist) return;
frontend/app/browse/playlists/[id]/page.tsx:173:        // Navigate to import page with the Deezer URL
frontend/app/browse/playlists/[id]/page.tsx:175:            `/import/spotify?url=${encodeURIComponent(playlist.url)}`
frontend/app/browse/playlists/[id]/page.tsx:187:    const totalDuration = playlist?.tracks.reduce(
frontend/app/browse/playlists/[id]/page.tsx:209:    if (error || !playlist) {
frontend/app/browse/playlists/[id]/page.tsx:231:                            Playlist not found
frontend/app/browse/playlists/[id]/page.tsx:234:                            {error || "This playlist may be private or no longer available."}
frontend/app/browse/playlists/[id]/page.tsx:237:                            onClick={() => router.push("/browse/playlists")}
frontend/app/browse/playlists/[id]/page.tsx:240:                            Browse playlists
frontend/app/browse/playlists/[id]/page.tsx:255:                        {playlist.imageUrl ? (
frontend/app/browse/playlists/[id]/page.tsx:257:                                src={playlist.imageUrl}
frontend/app/browse/playlists/[id]/page.tsx:258:                                alt={playlist.title}
frontend/app/browse/playlists/[id]/page.tsx:268:                    {/* Playlist Info */}
frontend/app/browse/playlists/[id]/page.tsx:271:                            <DeezerIcon className="w-4 h-4 text-[#AD47FF]" />
frontend/app/browse/playlists/[id]/page.tsx:273:                                Deezer Playlist
frontend/app/browse/playlists/[id]/page.tsx:277:                            {playlist.title}
frontend/app/browse/playlists/[id]/page.tsx:279:                        {playlist.description && (
frontend/app/browse/playlists/[id]/page.tsx:281:                                {playlist.description}
frontend/app/browse/playlists/[id]/page.tsx:286:                                {playlist.creator}
frontend/app/browse/playlists/[id]/page.tsx:289:                            <span>{playlist.trackCount} songs</span>
frontend/app/browse/playlists/[id]/page.tsx:303:                    {/* Download/Import Button */}
frontend/app/browse/playlists/[id]/page.tsx:312:                            <Download className="w-5 h-5 text-black" />
frontend/app/browse/playlists/[id]/page.tsx:315:                            {isImporting ? "Importing..." : "Download & Create Playlist"}
frontend/app/browse/playlists/[id]/page.tsx:344:                    {/* Open in Deezer */}
frontend/app/browse/playlists/[id]/page.tsx:346:                        href={playlist.url}
frontend/app/browse/playlists/[id]/page.tsx:352:                        <span className="hidden sm:inline">Open in Deezer</span>
frontend/app/browse/playlists/[id]/page.tsx:359:                {playlist.tracks.length > 0 ? (
frontend/app/browse/playlists/[id]/page.tsx:371:                            {playlist.tracks.map((track, index) => {
frontend/app/browse/playlists/[id]/page.tsx:373:                                    playingTrackId === track.deezerId;
frontend/app/browse/playlists/[id]/page.tsx:378:                                        key={track.deezerId}
frontend/app/browse/playlists/[id]/page.tsx:475:                            This playlist appears to be empty
frontend/components/layout/BottomNavigation.tsx:29:        name: "Playlists", 
frontend/components/layout/BottomNavigation.tsx:30:        href: "/playlists", 
frontend/components/layout/BottomNavigation.tsx:32:        matchPattern: "/playlist" // Matches both /playlists and /playlist/[id]
frontend/components/player/MiniPlayer.tsx:49:        downloadProgress,
frontend/components/player/MiniPlayer.tsx:279:    // MOBILE/TABLET: Spotify-style compact player
frontend/components/player/MiniPlayer.tsx:607:                            ? downloadProgress !== null
frontend/components/player/MiniPlayer.tsx:608:                                ? `Downloading ${downloadProgress}%... Seek will be available when cached`
frontend/components/player/MiniPlayer.tsx:609:                                : "Downloading... Seeking will be available when cached"
frontend/components/player/OverlayPlayer.tsx:40:        downloadProgress,
frontend/components/player/OverlayPlayer.tsx:423:                                ? downloadProgress !== null
frontend/components/player/OverlayPlayer.tsx:424:                                    ? `Downloading ${downloadProgress}%...`
frontend/components/player/OverlayPlayer.tsx:425:                                    : "Downloading..."
frontend/components/layout/ActivityPanel.tsx:5:import { useActiveDownloads } from "@/hooks/useNotifications";
frontend/components/layout/ActivityPanel.tsx:7:import { ActiveDownloadsTab } from "@/components/activity/ActiveDownloadsTab";
frontend/components/layout/ActivityPanel.tsx:11:    Download,
frontend/components/layout/ActivityPanel.tsx:24:    { id: "active", label: "Active", icon: Download },
frontend/components/layout/ActivityPanel.tsx:46:    const { downloads: activeDownloads } = useActiveDownloads();
frontend/components/layout/ActivityPanel.tsx:54:        activeDownloads.length > 0 ? activeDownloads.length : null;
frontend/components/layout/ActivityPanel.tsx:55:    const hasActivity = unreadCount > 0 || activeDownloads.length > 0;
frontend/components/layout/ActivityPanel.tsx:135:                            <ActiveDownloadsTab />
frontend/components/layout/ActivityPanel.tsx:212:                    {resolvedActiveTab === "active" && <ActiveDownloadsTab />}
frontend/components/layout/ActivityPanel.tsx:223:    const { downloads: activeDownloads } = useActiveDownloads();
frontend/components/layout/ActivityPanel.tsx:231:    const hasActivity = unreadCount > 0 || activeDownloads.length > 0;
frontend/app/browse/playlists/page.tsx:10:interface PlaylistPreview {
frontend/app/browse/playlists/page.tsx:12:    source: "deezer" | "spotify";
frontend/app/browse/playlists/page.tsx:13:    type: "playlist" | "radio";
frontend/app/browse/playlists/page.tsx:28:// Deezer icon component
frontend/app/browse/playlists/page.tsx:29:const DeezerIcon = ({ className }: { className?: string }) => (
frontend/app/browse/playlists/page.tsx:36:type BrowseTab = "playlists" | "genres";
frontend/app/browse/playlists/page.tsx:47:export default function BrowsePlaylistsPage() {
frontend/app/browse/playlists/page.tsx:52:    const [activeTab, setActiveTab] = useState<BrowseTab>("playlists");
frontend/app/browse/playlists/page.tsx:63:    const [playlists, setPlaylists] = useState<PlaylistPreview[]>([]);
frontend/app/browse/playlists/page.tsx:66:    const [genrePlaylists, setGenrePlaylists] = useState<PlaylistPreview[]>([]);
frontend/app/browse/playlists/page.tsx:74:                playlists: PlaylistPreview[];
frontend/app/browse/playlists/page.tsx:78:            setPlaylists(response.playlists);
frontend/app/browse/playlists/page.tsx:83:                "Couldn't load playlists. Check your connection and try again."
frontend/app/browse/playlists/page.tsx:94:    // Search playlists
frontend/app/browse/playlists/page.tsx:106:        setActiveTab("playlists"); // Switch to playlists for search results
frontend/app/browse/playlists/page.tsx:110:                playlists: PlaylistPreview[];
frontend/app/browse/playlists/page.tsx:112:                `/browse/playlists/search?q=${encodeURIComponent(
frontend/app/browse/playlists/page.tsx:116:            setPlaylists(response.playlists);
frontend/app/browse/playlists/page.tsx:119:            toast.error("Failed to search playlists");
frontend/app/browse/playlists/page.tsx:143:            }>("/browse/playlists/parse", { url: urlInput.trim() });
frontend/app/browse/playlists/page.tsx:147:                `/import/spotify?url=${encodeURIComponent(response.url)}`
frontend/app/browse/playlists/page.tsx:151:                error instanceof Error ? error.message : "Invalid playlist URL";
frontend/app/browse/playlists/page.tsx:158:    // Handle playlist click - navigate to detail page
frontend/app/browse/playlists/page.tsx:159:    const handleItemClick = (item: PlaylistPreview) => {
frontend/app/browse/playlists/page.tsx:160:        router.push(`/browse/playlists/${item.id}`);
frontend/app/browse/playlists/page.tsx:170:                playlists: PlaylistPreview[];
frontend/app/browse/playlists/page.tsx:171:            }>(`/browse/genres/${genre.id}/playlists?limit=50`);
frontend/app/browse/playlists/page.tsx:172:            setGenrePlaylists(response.playlists);
frontend/app/browse/playlists/page.tsx:174:            console.error("Failed to fetch genre playlists:", error);
frontend/app/browse/playlists/page.tsx:175:            toast.error("Failed to load genre playlists");
frontend/app/browse/playlists/page.tsx:184:        setGenrePlaylists([]);
frontend/app/browse/playlists/page.tsx:187:    // Render playlist card
frontend/app/browse/playlists/page.tsx:189:        item: PlaylistPreview,
frontend/app/browse/playlists/page.tsx:275:                        <DeezerIcon className="w-8 h-8 text-[#AD47FF]" />
frontend/app/browse/playlists/page.tsx:284:                        Discover and import playlists from Deezer
frontend/app/browse/playlists/page.tsx:293:                        Importing from Spotify and Deezer relies on matching tracks through Soulseek and your configured indexers.
frontend/app/browse/playlists/page.tsx:309:                            placeholder="Search playlists..."
frontend/app/browse/playlists/page.tsx:336:                            onClick={() => setActiveTab("playlists")}
frontend/app/browse/playlists/page.tsx:338:                                activeTab === "playlists"
frontend/app/browse/playlists/page.tsx:343:                            Playlists
frontend/app/browse/playlists/page.tsx:413:                        {playlists.length === 0 ? (
frontend/app/browse/playlists/page.tsx:416:                                    No playlists found
frontend/app/browse/playlists/page.tsx:431:                                {playlists.map((item, idx) =>
frontend/app/browse/playlists/page.tsx:439:                {/* Genre Playlists View */}
frontend/app/browse/playlists/page.tsx:443:                            {selectedGenre.name} Playlists
frontend/app/browse/playlists/page.tsx:445:                        {genrePlaylists.length === 0 ? (
frontend/app/browse/playlists/page.tsx:447:                                No playlists found for this genre
frontend/app/browse/playlists/page.tsx:451:                                {genrePlaylists.map((item, idx) =>
frontend/app/browse/playlists/page.tsx:465:                            {/* Playlists Tab */}
frontend/app/browse/playlists/page.tsx:466:                            {activeTab === "playlists" && (
frontend/app/browse/playlists/page.tsx:469:                                        Featured Playlists
frontend/app/browse/playlists/page.tsx:472:                                        {playlists.map((item, idx) =>
frontend/app/browse/playlists/page.tsx:476:                                    {playlists.length >= 20 && (
frontend/app/browse/playlists/page.tsx:478:                                            Showing {playlists.length} playlists
frontend/app/browse/playlists/page.tsx:492:                                        Explore playlists organized by musical
frontend/app/browse/playlists/page.tsx:504:            {/* URL Import Modal - Modern Spotify-style */}
frontend/app/browse/playlists/page.tsx:528:                                    Import Playlist
frontend/app/browse/playlists/page.tsx:548:                                        Spotify
frontend/app/browse/playlists/page.tsx:552:                                    <DeezerIcon className="w-4 h-4 text-[#AD47FF]" />
frontend/app/browse/playlists/page.tsx:554:                                        Deezer
frontend/app/browse/playlists/page.tsx:572:                                    placeholder="Paste playlist URL here..."
frontend/app/browse/playlists/page.tsx:591:                                https://open.spotify.com/playlist/37i9dQZF1DXcBWIGoYBM5M
frontend/components/player/UniversalPlayer.tsx:64:            {/* Always show player UI (like Spotify), even when no media is playing */}
backend/src/services/podcastCache.ts:9: * This service adds cover image caching to avoid repeated downloads
backend/src/services/podcastCache.ts:63:                        const localPath = await this.downloadCover(
backend/src/services/podcastCache.ts:143:                        const localPath = await this.downloadCover(
backend/src/services/podcastCache.ts:183:     * Download a cover image and save it locally
backend/src/services/podcastCache.ts:185:    private async downloadCover(
backend/src/services/podcastCache.ts:208:                `Failed to download cover for ${type} ${id}:`,
frontend/app/sync/page.tsx:59:                            // Artists get images from Deezer/Fanart when first viewed
frontend/components/layout/TopBar.tsx:11:import { useDownloadContext } from "@/lib/download-context";
frontend/components/layout/TopBar.tsx:89:    // Track download status from context (single source of truth)
frontend/components/layout/TopBar.tsx:90:    const { pendingDownloads, downloadStatus } = useDownloadContext();
frontend/components/layout/TopBar.tsx:91:    const hasActiveDownloads =
frontend/components/layout/TopBar.tsx:92:        downloadStatus.hasActiveDownloads || pendingDownloads.length > 0;
frontend/components/layout/TopBar.tsx:93:    const hasFailedDownloads = downloadStatus.failedDownloads.length > 0;
frontend/components/layout/TopBar.tsx:318:                                    hasActiveDownloads
frontend/components/layout/TopBar.tsx:320:                                        : hasFailedDownloads
frontend/components/layout/TopBar.tsx:327:                                        : hasActiveDownloads
frontend/components/layout/TopBar.tsx:329:                                              downloadStatus.activeDownloads
frontend/components/layout/TopBar.tsx:330:                                                  .length + pendingDownloads.length
frontend/components/layout/TopBar.tsx:331:                                          } download(s) in progress`
frontend/components/layout/TopBar.tsx:332:                                        : hasFailedDownloads
frontend/components/layout/TopBar.tsx:333:                                        ? `${downloadStatus.failedDownloads.length} download(s) failed`
frontend/components/layout/TopBar.tsx:340:                                        (isPolling || hasActiveDownloads) &&
frontend/components/player/FullPlayer.tsx:66:        downloadProgress,
frontend/components/player/FullPlayer.tsx:598:                                    ? downloadProgress !== null
frontend/components/player/FullPlayer.tsx:599:                                        ? `Downloading ${downloadProgress}%... Seek will be available when cached`
frontend/components/player/FullPlayer.tsx:600:                                        : "Downloading... Seeking will be available when cached"
backend/src/services/enrichment.ts:241:        // Step 3: Get artist image from multiple sources (Deezer → Fanart → MusicBrainz → Last.fm)
backend/src/services/enrichment.ts:400:        // Step 3: Get cover art from multiple sources (Deezer → MusicBrainz → Fanart)
frontend/app/mix/[id]/page.tsx:135:    const handleSaveAsPlaylist = async () => {
frontend/app/mix/[id]/page.tsx:140:            const result = await api.saveMixAsPlaylist(mixId);
frontend/app/mix/[id]/page.tsx:141:            toast.success(`Saved as "${result.name}" playlist!`);
frontend/app/mix/[id]/page.tsx:142:            window.dispatchEvent(new Event("playlist-created"));
frontend/app/mix/[id]/page.tsx:144:                router.push(`/playlist/${result.id}`);
frontend/app/mix/[id]/page.tsx:147:            console.error("Failed to save mix as playlist:", error);
frontend/app/mix/[id]/page.tsx:148:            const err = error as { status?: number; data?: { playlistId?: string } };
frontend/app/mix/[id]/page.tsx:150:                toast.info("You've already saved this mix as a playlist.");
frontend/app/mix/[id]/page.tsx:151:                if (err?.data?.playlistId) {
frontend/app/mix/[id]/page.tsx:153:                        router.push(`/playlist/${err.data!.playlistId}`);
frontend/app/mix/[id]/page.tsx:159:                toast.error("Failed to save mix as playlist");
frontend/app/mix/[id]/page.tsx:184:            {/* Compact Hero - Spotify Style */}
frontend/app/mix/[id]/page.tsx:275:                    {/* Save as Playlist Button */}
frontend/app/mix/[id]/page.tsx:277:                        onClick={handleSaveAsPlaylist}
frontend/app/mix/[id]/page.tsx:283:                            {isSaving ? "Saving..." : "Save as Playlist"}
backend/src/utils/stringNormalization.ts:5: * (Deezer, Last.fm) don't handle well. These utilities normalize strings
backend/src/tests/downloadDedup.test.ts:2: * Download Job Deduplication Test
backend/src/tests/downloadDedup.test.ts:4: * Tests the entire download flow to verify:
backend/src/tests/downloadDedup.test.ts:10: * Run with: npx tsx src/tests/downloadDedup.test.ts
backend/src/tests/downloadDedup.test.ts:14:import { simpleDownloadManager } from "../services/simpleDownloadManager";
backend/src/tests/downloadDedup.test.ts:36:    await prisma.downloadJob.deleteMany({
backend/src/tests/downloadDedup.test.ts:59:    const job1 = await prisma.downloadJob.create({
backend/src/tests/downloadDedup.test.ts:69:                downloadType: "library",
backend/src/tests/downloadDedup.test.ts:82:    console.log(`   Download ID: test-download-id-001`);
backend/src/tests/downloadDedup.test.ts:87:    const grabResult = await simpleDownloadManager.onDownloadGrabbed(
backend/src/tests/downloadDedup.test.ts:88:        "test-download-id-001",
backend/src/tests/downloadDedup.test.ts:102:    const jobsAfterGrab = await prisma.downloadJob.findMany({
backend/src/tests/downloadDedup.test.ts:150:    const job1 = await prisma.downloadJob.create({
backend/src/tests/downloadDedup.test.ts:157:            lidarrRef: "download-001",
backend/src/tests/downloadDedup.test.ts:164:    const job2 = await prisma.downloadJob.create({
backend/src/tests/downloadDedup.test.ts:177:    console.log(`   Job 1: ${job1.id} (MBID: ${TEST_MBID_1}, lidarrRef: download-001)`);
backend/src/tests/downloadDedup.test.ts:182:    console.log(`   downloadId: download-001`);
backend/src/tests/downloadDedup.test.ts:187:    const completeResult = await simpleDownloadManager.onDownloadComplete(
backend/src/tests/downloadDedup.test.ts:188:        "download-001",
backend/src/tests/downloadDedup.test.ts:197:    const jobsAfter = await prisma.downloadJob.findMany({
backend/src/tests/downloadDedup.test.ts:245:    const job1 = await prisma.downloadJob.create({
backend/src/tests/downloadDedup.test.ts:252:            lidarrRef: "download-002",
backend/src/tests/downloadDedup.test.ts:264:    await simpleDownloadManager.onDownloadComplete(
backend/src/tests/downloadDedup.test.ts:265:        "download-002",
backend/src/tests/downloadDedup.test.ts:273:    const job1After = await prisma.downloadJob.findUnique({ where: { id: job1.id } });
backend/src/tests/downloadDedup.test.ts:279:    const job2 = await prisma.downloadJob.create({
backend/src/tests/downloadDedup.test.ts:286:            lidarrRef: "download-003",
backend/src/tests/downloadDedup.test.ts:297:    await simpleDownloadManager.onDownloadComplete(
backend/src/tests/downloadDedup.test.ts:298:        "download-003",
backend/src/tests/downloadDedup.test.ts:306:    const allJobs = await prisma.downloadJob.findMany({ 
backend/src/tests/downloadDedup.test.ts:346:    const job1 = await prisma.downloadJob.create({
backend/src/tests/downloadDedup.test.ts:366:    console.log(`   Download ID: test-download-xyz`);
backend/src/tests/downloadDedup.test.ts:371:    const grabResult = await simpleDownloadManager.onDownloadGrabbed(
backend/src/tests/downloadDedup.test.ts:372:        "test-download-xyz",
backend/src/tests/downloadDedup.test.ts:384:    const jobsAfter = await prisma.downloadJob.findMany({
backend/src/tests/downloadDedup.test.ts:431:    const job1 = await prisma.downloadJob.create({
backend/src/tests/downloadDedup.test.ts:449:    const completeResult = await simpleDownloadManager.onDownloadComplete(
backend/src/tests/downloadDedup.test.ts:450:        "unknown-download-id",
backend/src/tests/downloadDedup.test.ts:459:    const jobAfter = await prisma.downloadJob.findUnique({ where: { id: job1.id } });
backend/src/tests/downloadDedup.test.ts:484:    const job1 = await prisma.downloadJob.create({
backend/src/tests/downloadDedup.test.ts:500:    const grabResult = await simpleDownloadManager.onDownloadGrabbed(
backend/src/tests/downloadDedup.test.ts:501:        "test-case-download",
backend/src/tests/downloadDedup.test.ts:512:    const testJobs = await prisma.downloadJob.findMany({
backend/src/tests/downloadDedup.test.ts:538:    const job1 = await prisma.downloadJob.create({
backend/src/tests/downloadDedup.test.ts:554:    const grabResult = await simpleDownloadManager.onDownloadGrabbed(
backend/src/tests/downloadDedup.test.ts:555:        "test-diff-album-download",
backend/src/tests/downloadDedup.test.ts:591:    const job1 = await prisma.downloadJob.create({
backend/src/tests/downloadDedup.test.ts:598:            lidarrRef: "idempotent-download",
backend/src/tests/downloadDedup.test.ts:609:    const result1 = await simpleDownloadManager.onDownloadComplete(
backend/src/tests/downloadDedup.test.ts:610:        "idempotent-download",
backend/src/tests/downloadDedup.test.ts:620:    const result2 = await simpleDownloadManager.onDownloadComplete(
backend/src/tests/downloadDedup.test.ts:621:        "idempotent-download",
backend/src/tests/downloadDedup.test.ts:629:    const jobAfter = await prisma.downloadJob.findUnique({ where: { id: job1.id } });
backend/src/tests/downloadDedup.test.ts:653:    const job1 = await prisma.downloadJob.create({
backend/src/tests/downloadDedup.test.ts:660:            lidarrRef: "discovery-download",
backend/src/tests/downloadDedup.test.ts:664:                downloadType: "discovery", // This is a discovery job!
backend/src/tests/downloadDedup.test.ts:671:    await simpleDownloadManager.onDownloadComplete(
backend/src/tests/downloadDedup.test.ts:672:        "discovery-download",
backend/src/tests/downloadDedup.test.ts:679:    const jobAfter = await prisma.downloadJob.findUnique({ where: { id: job1.id } });
backend/src/tests/downloadDedup.test.ts:700:    console.log("Scenario: Job has lidarrRef 'download-1', new grab comes with 'download-2'");
backend/src/tests/downloadDedup.test.ts:701:    console.log("Expected: lidarrRef should update to new download ID");
backend/src/tests/downloadDedup.test.ts:703:    const job1 = await prisma.downloadJob.create({
backend/src/tests/downloadDedup.test.ts:710:            lidarrRef: "old-download-id",
backend/src/tests/downloadDedup.test.ts:717:    console.log(`   Created job with lidarrRef: old-download-id`);
backend/src/tests/downloadDedup.test.ts:719:    // New grab (retry) with different download ID
backend/src/tests/downloadDedup.test.ts:720:    const grabResult = await simpleDownloadManager.onDownloadGrabbed(
backend/src/tests/downloadDedup.test.ts:721:        "new-download-id",
backend/src/tests/downloadDedup.test.ts:728:    const jobAfter = await prisma.downloadJob.findUnique({ where: { id: job1.id } });
backend/src/tests/downloadDedup.test.ts:730:    const passed = jobAfter?.lidarrRef === "new-download-id" && grabResult.jobId === job1.id;
backend/src/tests/downloadDedup.test.ts:736:        console.log(`   Expected: new-download-id`);
backend/src/tests/downloadDedup.test.ts:751:    const job1 = await prisma.downloadJob.create({
backend/src/tests/downloadDedup.test.ts:765:    const grabResult = await simpleDownloadManager.onDownloadGrabbed(
backend/src/tests/downloadDedup.test.ts:766:        "subject-only-download",
backend/src/tests/downloadDedup.test.ts:773:    const testJobs = await prisma.downloadJob.findMany({
backend/src/tests/downloadDedup.test.ts:797:    const job1 = await prisma.downloadJob.create({
backend/src/tests/downloadDedup.test.ts:804:            lidarrRef: "three-dup-download",
backend/src/tests/downloadDedup.test.ts:808:    const job2 = await prisma.downloadJob.create({
backend/src/tests/downloadDedup.test.ts:818:    const job3 = await prisma.downloadJob.create({
backend/src/tests/downloadDedup.test.ts:831:    await simpleDownloadManager.onDownloadComplete(
backend/src/tests/downloadDedup.test.ts:832:        "three-dup-download",
backend/src/tests/downloadDedup.test.ts:839:    const testJobs = await prisma.downloadJob.findMany({
backend/src/tests/downloadDedup.test.ts:867:    const job1 = await prisma.downloadJob.create({
backend/src/tests/downloadDedup.test.ts:885:    const grabResult = await simpleDownloadManager.onDownloadGrabbed(
backend/src/tests/downloadDedup.test.ts:886:        "whitespace-download",
backend/src/tests/downloadDedup.test.ts:896:    const testJobs = await prisma.downloadJob.findMany({
backend/src/tests/downloadDedup.test.ts:923:    const job1 = await prisma.downloadJob.create({
backend/src/tests/downloadDedup.test.ts:942:    const grabResult = await simpleDownloadManager.onDownloadGrabbed(
backend/src/tests/downloadDedup.test.ts:943:        `unicode-download-${uniqueId}`,
backend/src/tests/downloadDedup.test.ts:954:    const jobAfter = await prisma.downloadJob.findUnique({ where: { id: job1.id } });
backend/src/tests/downloadDedup.test.ts:978:    const job1 = await prisma.downloadJob.create({
backend/src/tests/downloadDedup.test.ts:996:        simpleDownloadManager.onDownloadGrabbed(
backend/src/tests/downloadDedup.test.ts:997:            "race-download-1",
backend/src/tests/downloadDedup.test.ts:1003:        simpleDownloadManager.onDownloadGrabbed(
backend/src/tests/downloadDedup.test.ts:1004:            "race-download-2",
backend/src/tests/downloadDedup.test.ts:1010:        simpleDownloadManager.onDownloadGrabbed(
backend/src/tests/downloadDedup.test.ts:1011:            "race-download-3",
backend/src/tests/downloadDedup.test.ts:1023:    const testJobs = await prisma.downloadJob.findMany({
backend/src/tests/downloadDedup.test.ts:1058:    const job1 = await prisma.downloadJob.create({
backend/src/tests/downloadDedup.test.ts:1076:    const result = await simpleDownloadManager.reconcileWithLidarr();
backend/src/tests/downloadDedup.test.ts:1103:    const job1 = await prisma.downloadJob.create({
backend/src/tests/downloadDedup.test.ts:1121:    const result = await simpleDownloadManager.markStaleJobsAsFailed();
backend/src/tests/downloadDedup.test.ts:1124:    const jobAfter = await prisma.downloadJob.findUnique({ where: { id: job1.id } });
backend/src/tests/downloadDedup.test.ts:1140:// Test 18: Spotify import jobs should NOT send notifications
backend/src/tests/downloadDedup.test.ts:1141:async function test18_SpotifyImportNoNotification(): Promise<boolean> {
backend/src/tests/downloadDedup.test.ts:1143:    console.log("TEST 18: Spotify Import Jobs Should NOT Send Notifications");
backend/src/tests/downloadDedup.test.ts:1145:    console.log("Scenario: Spotify import job completes");
backend/src/tests/downloadDedup.test.ts:1148:    const job1 = await prisma.downloadJob.create({
backend/src/tests/downloadDedup.test.ts:1155:            lidarrRef: "spotify-import-download",
backend/src/tests/downloadDedup.test.ts:1159:                spotifyImportJobId: "spotify-import-123", // This marks it as a Spotify import
backend/src/tests/downloadDedup.test.ts:1164:    console.log(`   Created Spotify import job: ${job1.id}`);
backend/src/tests/downloadDedup.test.ts:1166:    await simpleDownloadManager.onDownloadComplete(
backend/src/tests/downloadDedup.test.ts:1167:        "spotify-import-download",
backend/src/tests/downloadDedup.test.ts:1174:    const jobAfter = await prisma.downloadJob.findUnique({ where: { id: job1.id } });
backend/src/tests/downloadDedup.test.ts:1177:    // notificationSent should NOT be true for Spotify import jobs
backend/src/tests/downloadDedup.test.ts:1181:        console.log("\n[PASS] TEST 18 PASSED: Spotify import notification correctly skipped");
backend/src/tests/downloadDedup.test.ts:1183:        console.log("\n[FAIL] TEST 18 FAILED: Spotify import incorrectly sent notification");
backend/src/tests/downloadDedup.test.ts:1192:    console.log("DOWNLOAD JOB DEDUPLICATION TEST SUITE");
backend/src/tests/downloadDedup.test.ts:1324:        // Test 18: Spotify import no notification
backend/src/tests/downloadDedup.test.ts:1327:            name: "Spotify Import Skip Notification", 
backend/src/tests/downloadDedup.test.ts:1328:            passed: await test18_SpotifyImportNoNotification() 
backend/src/tests/downloadDedup.test.ts:1359:        console.log("\n🎉 ALL TESTS PASSED! Download deduplication is working correctly.");
backend/src/routes/soulseek.ts:3: * Simplified API for status and manual search/download
backend/src/routes/soulseek.ts:216: * POST /soulseek/download
backend/src/routes/soulseek.ts:217: * Download a track directly
backend/src/routes/soulseek.ts:219:router.post("/download", requireAuth, requireSoulseekConfigured, async (req, res) => {
backend/src/routes/soulseek.ts:238:        console.log(`[Soulseek] Downloading: "${artist} - ${title}"`);
backend/src/routes/soulseek.ts:240:        const result = await soulseekService.searchAndDownload(
backend/src/routes/soulseek.ts:255:                error: result.error || "Download failed",
backend/src/routes/soulseek.ts:259:        console.error("Soulseek download error:", error.message);
backend/src/routes/soulseek.ts:261:            error: "Download failed",
backend/src/routes/soulseek.ts:268: * POST /soulseek/download-file
backend/src/routes/soulseek.ts:269: * Download a specific file from a user (uses path + username)
backend/src/routes/soulseek.ts:272:    "/download-file",
backend/src/routes/soulseek.ts:302:                "/soulseek-downloads",
backend/src/routes/soulseek.ts:308:            const result = await soulseekService.downloadFile(
backend/src/routes/soulseek.ts:323:                    error: result.error || "Download failed",
backend/src/routes/soulseek.ts:327:            console.error("Soulseek file download error:", error.message);
backend/src/routes/soulseek.ts:329:                error: "Download failed",
backend/src/index.ts:21:import playlistsRoutes from "./routes/playlists";
backend/src/index.ts:24:import downloadsRoutes from "./routes/downloads";
backend/src/index.ts:36:import spotifyRoutes from "./routes/spotify";
backend/src/index.ts:149:app.use("/api/playlists", apiLimiter, playlistsRoutes);
backend/src/index.ts:152:app.use("/api/downloads", apiLimiter, downloadsRoutes);
backend/src/index.ts:164:app.use("/api/spotify", apiLimiter, spotifyRoutes);
backend/src/index.ts:257:    const { cleanupExpiredCache } = await import("./services/podcastDownload");
frontend/app/playlist/[id]/page.tsx:10:import { usePlaylistQuery } from "@/hooks/useQueries";
frontend/app/playlist/[id]/page.tsx:46:interface PlaylistItem {
frontend/app/playlist/[id]/page.tsx:66:export default function PlaylistDetailPage() {
frontend/app/playlist/[id]/page.tsx:73:    const playlistId = params.id as string;
frontend/app/playlist/[id]/page.tsx:94:    // Handle Deezer preview playback
frontend/app/playlist/[id]/page.tsx:112:            // Always fetch a fresh preview URL since Deezer URLs expire quickly
frontend/app/playlist/[id]/page.tsx:113:            const result = await api.getFreshPreviewUrl(playlistId, pendingId);
frontend/app/playlist/[id]/page.tsx:121:                console.error("Deezer preview playback failed:", e);
frontend/app/playlist/[id]/page.tsx:129:            console.error("Failed to play Deezer preview:", err);
frontend/app/playlist/[id]/page.tsx:135:    // Handle retry download for pending track
frontend/app/playlist/[id]/page.tsx:139:            const result = await api.retryPendingTrack(playlistId, pendingId);
frontend/app/playlist/[id]/page.tsx:148:                // If the backend emits a scan/download notification, refresh it
frontend/app/playlist/[id]/page.tsx:150:                // Refresh playlist data after a delay to allow download + scan to complete
frontend/app/playlist/[id]/page.tsx:153:                        queryKey: ["playlist", playlistId],
frontend/app/playlist/[id]/page.tsx:155:                }, 10000); // 10 seconds for download + scan
frontend/app/playlist/[id]/page.tsx:160:            console.error("Failed to retry download:", error);
frontend/app/playlist/[id]/page.tsx:161:            toast.error("Failed to retry download");
frontend/app/playlist/[id]/page.tsx:171:            await api.removePendingTrack(playlistId, pendingId);
frontend/app/playlist/[id]/page.tsx:172:            // Refresh playlist data
frontend/app/playlist/[id]/page.tsx:174:                queryKey: ["playlist", playlistId],
frontend/app/playlist/[id]/page.tsx:183:    // Use React Query hook for playlist
frontend/app/playlist/[id]/page.tsx:184:    const { data: playlist, isLoading } = usePlaylistQuery(playlistId);
frontend/app/playlist/[id]/page.tsx:186:    // Check if this is a shared playlist
frontend/app/playlist/[id]/page.tsx:187:    const isShared = playlist?.isOwner === false;
frontend/app/playlist/[id]/page.tsx:190:        if (!playlist) return;
frontend/app/playlist/[id]/page.tsx:193:            if (playlist.isHidden) {
frontend/app/playlist/[id]/page.tsx:194:                await api.unhidePlaylist(playlistId);
frontend/app/playlist/[id]/page.tsx:196:                await api.hidePlaylist(playlistId);
frontend/app/playlist/[id]/page.tsx:200:                new CustomEvent("playlist-updated", { detail: { playlistId } })
frontend/app/playlist/[id]/page.tsx:203:            if (!playlist.isHidden) {
frontend/app/playlist/[id]/page.tsx:204:                router.push("/playlists");
frontend/app/playlist/[id]/page.tsx:207:            console.error("Failed to toggle playlist visibility:", error);
frontend/app/playlist/[id]/page.tsx:213:    // Calculate cover arts from playlist tracks for mosaic (memoized)
frontend/app/playlist/[id]/page.tsx:215:        if (!playlist?.items || playlist.items.length === 0) return [];
frontend/app/playlist/[id]/page.tsx:217:        const tracksWithCovers = playlist.items.filter(
frontend/app/playlist/[id]/page.tsx:218:            (item: PlaylistItem) => item.track.album?.coverArt
frontend/app/playlist/[id]/page.tsx:228:    }, [playlist]);
frontend/app/playlist/[id]/page.tsx:232:            await api.removeTrackFromPlaylist(playlistId, trackId);
frontend/app/playlist/[id]/page.tsx:239:    const handleDeletePlaylist = async () => {
frontend/app/playlist/[id]/page.tsx:241:            await api.deletePlaylist(playlistId);
frontend/app/playlist/[id]/page.tsx:245:                new CustomEvent("playlist-deleted", { detail: { playlistId } })
frontend/app/playlist/[id]/page.tsx:248:            router.push("/playlists");
frontend/app/playlist/[id]/page.tsx:250:            console.error("Failed to delete playlist:", error);
frontend/app/playlist/[id]/page.tsx:254:    // Check if this playlist is currently playing
frontend/app/playlist/[id]/page.tsx:255:    const playlistTrackIds = useMemo(() => {
frontend/app/playlist/[id]/page.tsx:257:            playlist?.items?.map((item: PlaylistItem) => item.track.id) || []
frontend/app/playlist/[id]/page.tsx:259:    }, [playlist?.items]);
frontend/app/playlist/[id]/page.tsx:261:    const isThisPlaylistPlaying = useMemo(() => {
frontend/app/playlist/[id]/page.tsx:262:        if (!isPlaying || !currentTrack || !playlist?.items?.length)
frontend/app/playlist/[id]/page.tsx:264:        // Check if current track is in this playlist
frontend/app/playlist/[id]/page.tsx:265:        return playlistTrackIds.has(currentTrack.id);
frontend/app/playlist/[id]/page.tsx:266:    }, [isPlaying, currentTrack, playlistTrackIds, playlist?.items?.length]);
frontend/app/playlist/[id]/page.tsx:270:        if (!playlist?.items) return 0;
frontend/app/playlist/[id]/page.tsx:271:        return playlist.items.reduce(
frontend/app/playlist/[id]/page.tsx:272:            (sum: number, item: PlaylistItem) =>
frontend/app/playlist/[id]/page.tsx:276:    }, [playlist?.items]);
frontend/app/playlist/[id]/page.tsx:287:    const handlePlayPlaylist = () => {
frontend/app/playlist/[id]/page.tsx:288:        if (!playlist?.items || playlist.items.length === 0) return;
frontend/app/playlist/[id]/page.tsx:290:        // If this playlist is playing, toggle pause/resume
frontend/app/playlist/[id]/page.tsx:291:        if (isThisPlaylistPlaying) {
frontend/app/playlist/[id]/page.tsx:300:        const tracks = playlist.items.map((item: PlaylistItem) => ({
frontend/app/playlist/[id]/page.tsx:318:        if (!playlist?.items || playlist.items.length === 0) return;
frontend/app/playlist/[id]/page.tsx:320:        const tracks = playlist.items.map((item: PlaylistItem) => ({
frontend/app/playlist/[id]/page.tsx:369:    if (!playlist) {
frontend/app/playlist/[id]/page.tsx:372:                <p className="text-gray-500">Playlist not found</p>
frontend/app/playlist/[id]/page.tsx:379:            {/* Compact Hero - Spotify Style */}
frontend/app/playlist/[id]/page.tsx:430:                    {/* Playlist Info - Bottom Aligned */}
frontend/app/playlist/[id]/page.tsx:433:                            {isShared ? "Public Playlist" : "Playlist"}
frontend/app/playlist/[id]/page.tsx:436:                            {playlist.name}
frontend/app/playlist/[id]/page.tsx:439:                            {isShared && playlist.user?.username && (
frontend/app/playlist/[id]/page.tsx:442:                                        {playlist.user.username}
frontend/app/playlist/[id]/page.tsx:447:                            <span>{playlist.items?.length || 0} songs</span>
frontend/app/playlist/[id]/page.tsx:464:                    {playlist.items && playlist.items.length > 0 && (
frontend/app/playlist/[id]/page.tsx:466:                            onClick={handlePlayPlaylist}
frontend/app/playlist/[id]/page.tsx:469:                            {isThisPlaylistPlaying && isPlaying ? (
frontend/app/playlist/[id]/page.tsx:478:                    {playlist.items && playlist.items.length > 1 && (
frontend/app/playlist/[id]/page.tsx:482:                                    !playlist?.items ||
frontend/app/playlist/[id]/page.tsx:483:                                    playlist.items.length === 0
frontend/app/playlist/[id]/page.tsx:486:                                const tracks = playlist.items.map(
frontend/app/playlist/[id]/page.tsx:487:                                    (item: PlaylistItem) => ({
frontend/app/playlist/[id]/page.tsx:524:                            playlist.isHidden
frontend/app/playlist/[id]/page.tsx:530:                            playlist.isHidden
frontend/app/playlist/[id]/page.tsx:531:                                ? "Show playlist"
frontend/app/playlist/[id]/page.tsx:532:                                : "Hide playlist"
frontend/app/playlist/[id]/page.tsx:539:                    {playlist.isOwner && (
frontend/app/playlist/[id]/page.tsx:543:                            title="Delete Playlist"
frontend/app/playlist/[id]/page.tsx:554:                {playlist.pendingCount > 0 && (
frontend/app/playlist/[id]/page.tsx:558:                            {playlist.pendingCount} track
frontend/app/playlist/[id]/page.tsx:559:                            {playlist.pendingCount !== 1 ? "s" : ""} failed to
frontend/app/playlist/[id]/page.tsx:560:                            download - will auto-import when available
frontend/app/playlist/[id]/page.tsx:565:                {playlist.items?.length > 0 ||
frontend/app/playlist/[id]/page.tsx:566:                playlist.pendingTracks?.length > 0 ? (
frontend/app/playlist/[id]/page.tsx:578:                            {(playlist.mergedItems || playlist.items || []).map(
frontend/app/playlist/[id]/page.tsx:580:                                    item: PlaylistItem | PendingTrack,
frontend/app/playlist/[id]/page.tsx:614:                                                            title="Play 30s Deezer preview"
frontend/app/playlist/[id]/page.tsx:658:                                                        title="Retry download"
frontend/app/playlist/[id]/page.tsx:667:                                                    {playlist.isOwner && (
frontend/app/playlist/[id]/page.tsx:679:                                                            title="Remove from playlist"
frontend/app/playlist/[id]/page.tsx:694:                                    const playlistItem = item as PlaylistItem;
frontend/app/playlist/[id]/page.tsx:697:                                        playlistItem.track.id;
frontend/app/playlist/[id]/page.tsx:700:                                        playlist.items?.findIndex(
frontend/app/playlist/[id]/page.tsx:701:                                            (i: PlaylistItem) =>
frontend/app/playlist/[id]/page.tsx:702:                                                i.id === playlistItem.id
frontend/app/playlist/[id]/page.tsx:707:                                            key={playlistItem.id}
frontend/app/playlist/[id]/page.tsx:740:                                                    {playlistItem.track.album
frontend/app/playlist/[id]/page.tsx:744:                                                                playlistItem
frontend/app/playlist/[id]/page.tsx:750:                                                                playlistItem
frontend/app/playlist/[id]/page.tsx:771:                                                            playlistItem.track
frontend/app/playlist/[id]/page.tsx:777:                                                            playlistItem.track
frontend/app/playlist/[id]/page.tsx:787:                                                {playlistItem.track.album.title}
frontend/app/playlist/[id]/page.tsx:797:                                                            playlistItem.track
frontend/app/playlist/[id]/page.tsx:806:                                                        playlistItem.track
frontend/app/playlist/[id]/page.tsx:810:                                                {playlist.isOwner && (
frontend/app/playlist/[id]/page.tsx:816:                                                                playlistItem
frontend/app/playlist/[id]/page.tsx:820:                                                        title="Remove from Playlist"
frontend/app/playlist/[id]/page.tsx:851:                onConfirm={handleDeletePlaylist}
frontend/app/playlist/[id]/page.tsx:852:                title="Delete Playlist?"
frontend/app/playlist/[id]/page.tsx:853:                message={`Are you sure you want to delete "${playlist.name}"? This action cannot be undone.`}
backend/src/utils/envWriter.ts:64:        "Docker Paths": ["MUSIC_PATH", "DOWNLOAD_PATH"],
frontend/app/library/page.tsx:64:        addTrackToPlaylist,
frontend/app/library/page.tsx:415:                        onAddToPlaylist={addTrackToPlaylist}
backend/src/config.ts:97:    // Deezer - reads from database
backend/src/config.ts:98:    deezer: {
backend/src/config.ts:99:        apiKey: process.env.DEEZER_API_KEY || "", // Fallback to DB
backend/src/routes/notifications.ts:135:// Download History Endpoints
backend/src/routes/notifications.ts:139: * GET /notifications/downloads/history
backend/src/routes/notifications.ts:140: * Get completed/failed downloads that haven't been cleared
backend/src/routes/notifications.ts:143:    "/downloads/history",
backend/src/routes/notifications.ts:147:            const downloads = await prisma.downloadJob.findMany({
backend/src/routes/notifications.ts:156:            res.json(downloads);
backend/src/routes/notifications.ts:158:            console.error("Error fetching download history:", error);
backend/src/routes/notifications.ts:159:            res.status(500).json({ error: "Failed to fetch download history" });
backend/src/routes/notifications.ts:165: * GET /notifications/downloads/active
backend/src/routes/notifications.ts:166: * Get active downloads (pending/processing)
backend/src/routes/notifications.ts:169:    "/downloads/active",
backend/src/routes/notifications.ts:173:            const downloads = await prisma.downloadJob.findMany({
backend/src/routes/notifications.ts:180:            res.json(downloads);
backend/src/routes/notifications.ts:182:            console.error("Error fetching active downloads:", error);
backend/src/routes/notifications.ts:183:            res.status(500).json({ error: "Failed to fetch active downloads" });
backend/src/routes/notifications.ts:189: * POST /notifications/downloads/:id/clear
backend/src/routes/notifications.ts:190: * Clear a download from history
backend/src/routes/notifications.ts:193:    "/downloads/:id/clear",
backend/src/routes/notifications.ts:197:            await prisma.downloadJob.updateMany({
backend/src/routes/notifications.ts:206:            console.error("Error clearing download:", error);
backend/src/routes/notifications.ts:207:            res.status(500).json({ error: "Failed to clear download" });
backend/src/routes/notifications.ts:213: * POST /notifications/downloads/clear-all
backend/src/routes/notifications.ts:214: * Clear all completed/failed downloads from history
backend/src/routes/notifications.ts:217:    "/downloads/clear-all",
backend/src/routes/notifications.ts:221:            await prisma.downloadJob.updateMany({
backend/src/routes/notifications.ts:231:            console.error("Error clearing all downloads:", error);
backend/src/routes/notifications.ts:232:            res.status(500).json({ error: "Failed to clear all downloads" });
backend/src/routes/notifications.ts:238: * POST /notifications/downloads/:id/retry
backend/src/routes/notifications.ts:239: * Retry a failed download
backend/src/routes/notifications.ts:242:    "/downloads/:id/retry",
backend/src/routes/notifications.ts:246:            // Get the failed download
backend/src/routes/notifications.ts:247:            const failedJob = await prisma.downloadJob.findFirst({
backend/src/routes/notifications.ts:258:                    .json({ error: "Download not found or not failed" });
backend/src/routes/notifications.ts:266:            if (metadata?.downloadType === "pending-track-retry") {
backend/src/routes/notifications.ts:267:                const playlistId = metadata.playlistId as string | undefined;
backend/src/routes/notifications.ts:272:                if (!playlistId || !pendingTrackId) {
backend/src/routes/notifications.ts:274:                        error: "Cannot retry: missing playlistId or pendingTrackId",
backend/src/routes/notifications.ts:279:                await prisma.downloadJob.update({
backend/src/routes/notifications.ts:284:                // Validate playlist ownership and pending track exists
backend/src/routes/notifications.ts:285:                const playlist = await prisma.playlist.findUnique({
backend/src/routes/notifications.ts:286:                    where: { id: playlistId },
backend/src/routes/notifications.ts:288:                if (!playlist || playlist.userId !== req.user!.id) {
backend/src/routes/notifications.ts:291:                        .json({ error: "Playlist not found" });
backend/src/routes/notifications.ts:295:                    await prisma.playlistPendingTrack.findUnique({
backend/src/routes/notifications.ts:309:                const newJobRecord = await prisma.downloadJob.create({
backend/src/routes/notifications.ts:312:                        subject: `${pendingTrack.spotifyArtist} - ${pendingTrack.spotifyTitle}`,
backend/src/routes/notifications.ts:320:                            downloadType: "pending-track-retry",
backend/src/routes/notifications.ts:322:                            playlistId,
backend/src/routes/notifications.ts:324:                            spotifyArtist: pendingTrack.spotifyArtist,
backend/src/routes/notifications.ts:325:                            spotifyTitle: pendingTrack.spotifyTitle,
backend/src/routes/notifications.ts:326:                            spotifyAlbum: pendingTrack.spotifyAlbum,
backend/src/routes/notifications.ts:341:                    await prisma.downloadJob.update({
backend/src/routes/notifications.ts:360:                    await prisma.downloadJob.update({
backend/src/routes/notifications.ts:376:                    pendingTrack.spotifyAlbum !== "Unknown Album"
backend/src/routes/notifications.ts:377:                        ? pendingTrack.spotifyAlbum
backend/src/routes/notifications.ts:378:                        : pendingTrack.spotifyArtist;
backend/src/routes/notifications.ts:381:                    pendingTrack.spotifyArtist,
backend/src/routes/notifications.ts:382:                    pendingTrack.spotifyTitle
backend/src/routes/notifications.ts:389:                    await prisma.downloadJob.update({
backend/src/routes/notifications.ts:404:                // Start download in background (don't await)
backend/src/routes/notifications.ts:406:                    .downloadBestMatch(
backend/src/routes/notifications.ts:407:                        pendingTrack.spotifyArtist,
backend/src/routes/notifications.ts:408:                        pendingTrack.spotifyTitle,
backend/src/routes/notifications.ts:415:                            await prisma.downloadJob.update({
backend/src/routes/notifications.ts:448:                                // Best-effort; job status already reflects download
backend/src/routes/notifications.ts:451:                            await prisma.downloadJob.update({
backend/src/routes/notifications.ts:455:                                    error: result.error || "Download failed",
backend/src/routes/notifications.ts:462:                        await prisma.downloadJob.update({
backend/src/routes/notifications.ts:466:                                error: error?.message || "Download exception",
backend/src/routes/notifications.ts:475:            // If this was a spotify_import job, retry with Soulseek first
backend/src/routes/notifications.ts:476:            if (metadata?.downloadType === "spotify_import") {
backend/src/routes/notifications.ts:489:                await prisma.downloadJob.update({
backend/src/routes/notifications.ts:494:                // Create a NEW download job record for the retry
backend/src/routes/notifications.ts:495:                const newJobRecord = await prisma.downloadJob.create({
backend/src/routes/notifications.ts:525:                    await prisma.downloadJob.update({
backend/src/routes/notifications.ts:555:                    .searchAndDownloadBatch(tracks, musicPath, 4)
backend/src/routes/notifications.ts:558:                            await prisma.downloadJob.update({
backend/src/routes/notifications.ts:567:                                        tracksDownloaded: result.successful,
backend/src/routes/notifications.ts:573:                                `[Retry] ✓ Soulseek downloaded ${result.successful} tracks for ${artistName} - ${albumTitle}`
backend/src/routes/notifications.ts:584:                                source: "retry-spotify-import",
backend/src/routes/notifications.ts:596:                                const { simpleDownloadManager } = await import(
backend/src/routes/notifications.ts:597:                                    "../services/simpleDownloadManager"
backend/src/routes/notifications.ts:600:                                    await simpleDownloadManager.startDownload(
backend/src/routes/notifications.ts:610:                                    await prisma.downloadJob.update({
backend/src/routes/notifications.ts:622:                                await prisma.downloadJob.update({
backend/src/routes/notifications.ts:635:                        await prisma.downloadJob.update({
backend/src/routes/notifications.ts:656:            await prisma.downloadJob.update({
backend/src/routes/notifications.ts:670:            // Create a NEW download job record for the retry
backend/src/routes/notifications.ts:671:            const newJobRecord = await prisma.downloadJob.create({
backend/src/routes/notifications.ts:683:            // Import the download manager dynamically to avoid circular deps
backend/src/routes/notifications.ts:684:            const { simpleDownloadManager } = await import(
backend/src/routes/notifications.ts:685:                "../services/simpleDownloadManager"
backend/src/routes/notifications.ts:688:            // Start download with the correct positional arguments
backend/src/routes/notifications.ts:689:            // startDownload(jobId, artistName, albumTitle, albumMbid, userId, isDiscovery)
backend/src/routes/notifications.ts:690:            const result = await simpleDownloadManager.startDownload(
backend/src/routes/notifications.ts:705:            console.error("Error retrying download:", error);
backend/src/routes/notifications.ts:706:            res.status(500).json({ error: "Failed to retry download" });
frontend/features/podcast/types.ts:25:    autoDownloadEpisodes: boolean;
backend/src/routes/webhooks.ts:4: * Handles Lidarr webhooks for download tracking and Discovery Weekly integration.
backend/src/routes/webhooks.ts:5: * Uses the stateless simpleDownloadManager for all operations.
backend/src/routes/webhooks.ts:12:import { simpleDownloadManager } from "../services/simpleDownloadManager";
backend/src/routes/webhooks.ts:51:            case "Download":
backend/src/routes/webhooks.ts:52:            case "AlbumDownload":
backend/src/routes/webhooks.ts:55:                await handleDownload(req.body);
backend/src/routes/webhooks.ts:59:            case "DownloadFailed":
backend/src/routes/webhooks.ts:60:            case "DownloadFailure":
backend/src/routes/webhooks.ts:86: * Handle Grab event (download started by Lidarr)
backend/src/routes/webhooks.ts:89:    const downloadId = payload.downloadId;
backend/src/routes/webhooks.ts:97:    console.log(`   Download ID: ${downloadId}`);
backend/src/routes/webhooks.ts:100:    if (!downloadId) {
backend/src/routes/webhooks.ts:101:        console.log(`   Missing downloadId, skipping`);
backend/src/routes/webhooks.ts:105:    // Use the download manager's multi-strategy matching
backend/src/routes/webhooks.ts:106:    const result = await simpleDownloadManager.onDownloadGrabbed(
backend/src/routes/webhooks.ts:107:        downloadId,
backend/src/routes/webhooks.ts:115:        // Start queue cleaner to monitor this download
backend/src/routes/webhooks.ts:121: * Handle Download event (download complete + imported)
backend/src/routes/webhooks.ts:123:async function handleDownload(payload: any) {
backend/src/routes/webhooks.ts:124:    const downloadId = payload.downloadId;
backend/src/routes/webhooks.ts:143:    console.log(`   Download ID: ${downloadId}`);
backend/src/routes/webhooks.ts:147:    if (!downloadId) {
backend/src/routes/webhooks.ts:148:        console.log(`   Missing downloadId, skipping`);
backend/src/routes/webhooks.ts:152:    // Handle completion through download manager
backend/src/routes/webhooks.ts:153:    const result = await simpleDownloadManager.onDownloadComplete(
backend/src/routes/webhooks.ts:154:        downloadId,
backend/src/routes/webhooks.ts:162:        // Check if this is part of a download batch (artist download)
backend/src/routes/webhooks.ts:163:        if (result.downloadBatchId) {
backend/src/routes/webhooks.ts:165:            const batchComplete = await checkDownloadBatchComplete(
backend/src/routes/webhooks.ts:166:                result.downloadBatchId
backend/src/routes/webhooks.ts:180:            // Single album download (not part of discovery batch)
backend/src/routes/webhooks.ts:190:        // If part of discovery batch, the download manager already called checkBatchCompletion
backend/src/routes/webhooks.ts:192:        // No job found - this might be an external download not initiated by us
backend/src/routes/webhooks.ts:206: * Check if all jobs in a download batch are complete
backend/src/routes/webhooks.ts:208:async function checkDownloadBatchComplete(batchId: string): Promise<boolean> {
backend/src/routes/webhooks.ts:209:    const pendingJobs = await prisma.downloadJob.count({
backend/src/routes/webhooks.ts:229:    const downloadId = payload.downloadId;
backend/src/routes/webhooks.ts:236:    console.log(`   Download ID: ${downloadId}`);
backend/src/routes/webhooks.ts:239:    if (!downloadId) {
backend/src/routes/webhooks.ts:240:        console.log(`   Missing downloadId, skipping`);
backend/src/routes/webhooks.ts:244:    // Handle failure through download manager (handles retry logic)
backend/src/routes/webhooks.ts:245:    await simpleDownloadManager.onImportFailed(downloadId, reason, albumMbid);
frontend/features/home/hooks/useHomeData.ts:33:interface PlaylistPreview {
frontend/features/home/hooks/useHomeData.ts:54:    featuredPlaylists: PlaylistPreview[];
frontend/features/home/hooks/useHomeData.ts:168:        featuredPlaylists: browseData?.playlists || [],
backend/src/services/programmaticPlaylists.ts:234:export class ProgrammaticPlaylistService {
backend/src/services/programmaticPlaylists.ts:1022:     * Generate "Party Playlist" mix - upbeat dance, electronic, pop tracks
backend/src/services/programmaticPlaylists.ts:1132:            name: "Party Playlist",
backend/src/services/programmaticPlaylists.ts:1904:        // Require minimum 15 tracks for a meaningful playlist
backend/src/services/programmaticPlaylists.ts:3831:export const programmaticPlaylistService = new ProgrammaticPlaylistService();
backend/src/workers/cleanupDiscovery.ts:15:                downloadedAt: { lt: sevenDaysAgo },
backend/src/workers/cleanupDiscovery.ts:47:                // Keep if in any playlist (check playlist_items)
backend/src/workers/cleanupDiscovery.ts:49:                    const inPlaylist = await prisma.playlistItem.findFirst({
backend/src/workers/cleanupDiscovery.ts:52:                    if (inPlaylist) {
frontend/app/playlists/page.tsx:7:import { usePlaylistsQuery } from "@/hooks/useQueries";
frontend/app/playlists/page.tsx:20:interface PlaylistItem {
frontend/app/playlists/page.tsx:29:interface Playlist {
frontend/app/playlists/page.tsx:33:    items?: PlaylistItem[];
frontend/app/playlists/page.tsx:41:// Generate mosaic cover from playlist tracks
frontend/app/playlists/page.tsx:42:function PlaylistMosaic({
frontend/app/playlists/page.tsx:47:    items?: PlaylistItem[];
frontend/app/playlists/page.tsx:126:function PlaylistCard({
frontend/app/playlists/page.tsx:127:    playlist,
frontend/app/playlists/page.tsx:133:    playlist: Playlist;
frontend/app/playlists/page.tsx:135:    onPlay: (playlistId: string) => void;
frontend/app/playlists/page.tsx:136:    onToggleHide: (playlistId: string, hide: boolean) => void;
frontend/app/playlists/page.tsx:139:    const isShared = playlist.isOwner === false;
frontend/app/playlists/page.tsx:147:            await onToggleHide(playlist.id, !playlist.isHidden);
frontend/app/playlists/page.tsx:154:        <Link href={`/playlist/${playlist.id}`}>
frontend/app/playlists/page.tsx:166:                    <PlaylistMosaic
frontend/app/playlists/page.tsx:167:                        items={playlist.items}
frontend/app/playlists/page.tsx:171:                    {/* Hide/Unhide button for shared playlists */}
frontend/app/playlists/page.tsx:180:                                playlist.isHidden
frontend/app/playlists/page.tsx:186:                                playlist.isHidden
frontend/app/playlists/page.tsx:187:                                    ? "Show playlist"
frontend/app/playlists/page.tsx:188:                                    : "Hide playlist"
frontend/app/playlists/page.tsx:191:                            {playlist.isHidden ? (
frontend/app/playlists/page.tsx:204:                            onPlay(playlist.id);
frontend/app/playlists/page.tsx:213:                        title="Play playlist"
frontend/app/playlists/page.tsx:226:                    {playlist.name}
frontend/app/playlists/page.tsx:229:                    {isShared && playlist.user?.username ? (
frontend/app/playlists/page.tsx:231:                            By {playlist.user.username} ·{" "}
frontend/app/playlists/page.tsx:234:                    {playlist.trackCount || 0}{" "}
frontend/app/playlists/page.tsx:235:                    {playlist.trackCount === 1 ? "song" : "songs"}
frontend/app/playlists/page.tsx:242:export default function PlaylistsPage() {
frontend/app/playlists/page.tsx:249:    // Use React Query hook for playlists
frontend/app/playlists/page.tsx:250:    const { data: playlists = [], isLoading } = usePlaylistsQuery();
frontend/app/playlists/page.tsx:252:    // Separate visible and hidden playlists
frontend/app/playlists/page.tsx:253:    const { visiblePlaylists, hiddenPlaylists } = useMemo(() => {
frontend/app/playlists/page.tsx:254:        const visible: Playlist[] = [];
frontend/app/playlists/page.tsx:255:        const hidden: Playlist[] = [];
frontend/app/playlists/page.tsx:257:        playlists.forEach((p: Playlist) => {
frontend/app/playlists/page.tsx:265:        return { visiblePlaylists: visible, hiddenPlaylists: hidden };
frontend/app/playlists/page.tsx:266:    }, [playlists]);
frontend/app/playlists/page.tsx:268:    // Listen for playlist events and invalidate cache
frontend/app/playlists/page.tsx:270:        const handlePlaylistEvent = () => {
frontend/app/playlists/page.tsx:271:            queryClient.invalidateQueries({ queryKey: queryKeys.playlists() });
frontend/app/playlists/page.tsx:274:        window.addEventListener("playlist-created", handlePlaylistEvent);
frontend/app/playlists/page.tsx:275:        window.addEventListener("playlist-updated", handlePlaylistEvent);
frontend/app/playlists/page.tsx:276:        window.addEventListener("playlist-deleted", handlePlaylistEvent);
frontend/app/playlists/page.tsx:279:            window.removeEventListener("playlist-created", handlePlaylistEvent);
frontend/app/playlists/page.tsx:280:            window.removeEventListener("playlist-updated", handlePlaylistEvent);
frontend/app/playlists/page.tsx:281:            window.removeEventListener("playlist-deleted", handlePlaylistEvent);
frontend/app/playlists/page.tsx:285:    const handlePlayPlaylist = async (playlistId: string) => {
frontend/app/playlists/page.tsx:287:            const playlist = await api.getPlaylist(playlistId);
frontend/app/playlists/page.tsx:288:            if (playlist?.items && playlist.items.length > 0) {
frontend/app/playlists/page.tsx:289:                const tracks = playlist.items.map((item: any) => ({
frontend/app/playlists/page.tsx:306:            console.error("Failed to play playlist:", error);
frontend/app/playlists/page.tsx:310:    const handleToggleHide = async (playlistId: string, hide: boolean) => {
frontend/app/playlists/page.tsx:313:                await api.hidePlaylist(playlistId);
frontend/app/playlists/page.tsx:315:                await api.unhidePlaylist(playlistId);
frontend/app/playlists/page.tsx:317:            // Invalidate and refetch playlists
frontend/app/playlists/page.tsx:318:            queryClient.invalidateQueries({ queryKey: queryKeys.playlists() });
frontend/app/playlists/page.tsx:320:            console.error("Failed to toggle playlist visibility:", error);
frontend/app/playlists/page.tsx:332:    const displayedPlaylists = showHiddenTab
frontend/app/playlists/page.tsx:333:        ? hiddenPlaylists
frontend/app/playlists/page.tsx:334:        : visiblePlaylists;
frontend/app/playlists/page.tsx:355:                            Playlists
frontend/app/playlists/page.tsx:358:                            {visiblePlaylists.length}{" "}
frontend/app/playlists/page.tsx:359:                            {visiblePlaylists.length === 1
frontend/app/playlists/page.tsx:360:                                ? "playlist"
frontend/app/playlists/page.tsx:361:                                : "playlists"}
frontend/app/playlists/page.tsx:366:                        {/* Browse Public Playlists */}
frontend/app/playlists/page.tsx:368:                            href="/browse/playlists"
frontend/app/playlists/page.tsx:371:                            Browse Playlists
frontend/app/playlists/page.tsx:374:                        {/* Hidden Playlists Toggle */}
frontend/app/playlists/page.tsx:375:                        {hiddenPlaylists.length > 0 && (
frontend/app/playlists/page.tsx:387:                                    : `Hidden (${hiddenPlaylists.length})`}
frontend/app/playlists/page.tsx:396:                {/* Hidden playlists notice */}
frontend/app/playlists/page.tsx:400:                            Hidden playlists won't appear in your library. Hover
frontend/app/playlists/page.tsx:406:                {displayedPlaylists.length > 0 ? (
frontend/app/playlists/page.tsx:408:                        data-tv-section="playlists"
frontend/app/playlists/page.tsx:411:                        {displayedPlaylists.map(
frontend/app/playlists/page.tsx:412:                            (playlist: Playlist, index: number) => (
frontend/app/playlists/page.tsx:413:                                <PlaylistCard
frontend/app/playlists/page.tsx:414:                                    key={playlist.id}
frontend/app/playlists/page.tsx:415:                                    playlist={playlist}
frontend/app/playlists/page.tsx:417:                                    onPlay={handlePlayPlaylist}
frontend/app/playlists/page.tsx:431:                                ? "No hidden playlists"
frontend/app/playlists/page.tsx:432:                                : "No playlists yet"}
frontend/app/playlists/page.tsx:436:                                ? "You haven't hidden any playlists"
frontend/app/playlists/page.tsx:437:                                : "Create your first playlist by adding songs from albums or artists"}
frontend/app/playlists/page.tsx:441:                                href="/browse/playlists"
frontend/app/playlists/page.tsx:444:                                Browse Playlists
frontend/app/podcasts/page.tsx:25:    autoDownloadEpisodes: boolean;
backend/src/workers/discoverCron.ts:4: * Automatically generates Discover Weekly playlists on Sunday evenings
backend/src/workers/discoverCron.ts:36:                    playlistSize: true,
backend/src/utils/subsonicResponse.ts:298:export function parseSubsonicId(subsonicId: string): { type: "artist" | "album" | "track" | "playlist" | "unknown"; id: string } {
backend/src/utils/subsonicResponse.ts:309:        return { type: "playlist", id: subsonicId.substring(3) };
backend/src/workers/organizeSingles.ts:4: * With direct soulseek-ts integration, downloads go straight to Singles/Artist/Album/
backend/src/workers/organizeSingles.ts:12:import { sessionLog } from "../utils/playlistLogger";
backend/src/workers/organizeSingles.ts:175: * Clean up any legacy SLSKD download jobs that are stuck in processing
backend/src/workers/organizeSingles.ts:181:        const legacyJobs = await prisma.downloadJob.findMany({
backend/src/workers/organizeSingles.ts:195:                await prisma.downloadJob.update({
backend/src/workers/organizeSingles.ts:236:        const error = "MUSIC_PATH is not set. Cannot organize downloads.";
frontend/components/ui/ReleaseSelectionModal.tsx:7:import { useDownloadContext } from "@/lib/download-context";
frontend/components/ui/ReleaseSelectionModal.tsx:10:    Download,
frontend/components/ui/ReleaseSelectionModal.tsx:37:    const { addPendingDownload } = useDownloadContext();
frontend/components/ui/ReleaseSelectionModal.tsx:79:            // Add to pending downloads for UI feedback
frontend/components/ui/ReleaseSelectionModal.tsx:80:            addPendingDownload("album", `${artistName} - ${albumTitle}`, albumMbid);
frontend/components/ui/ReleaseSelectionModal.tsx:92:            toast.success(`Downloading "${albumTitle}"`, {
frontend/components/ui/ReleaseSelectionModal.tsx:99:            toast.error("Failed to start download", {
frontend/components/ui/ReleaseSelectionModal.tsx:226:            {/* Top row: Title + Download Button */}
frontend/components/ui/ReleaseSelectionModal.tsx:248:                {/* Download Button */}
frontend/components/ui/ReleaseSelectionModal.tsx:262:                        <Download className="w-4 h-4" />
backend/src/services/lastfm.ts:7:import { deezerService } from "./deezer";
backend/src/services/lastfm.ts:552:        // Priority: Fanart.tv (MBID) > Last.fm info > Deezer (strict match) > Last.fm search
backend/src/services/lastfm.ts:565:        // If still no image, try Deezer with strict name matching
backend/src/services/lastfm.ts:568:            resolvedImage = await deezerService
backend/src/services/lastfm.ts:613:            resolvedImage = await deezerService
backend/src/services/lastfm.ts:658:            albumArt = await deezerService
backend/src/services/lastfm.ts:849:                    // Fallback to Deezer (most reliable)
backend/src/services/lastfm.ts:852:                            const deezerImage =
backend/src/services/lastfm.ts:853:                                await deezerService.getArtistImage(artist.name);
backend/src/services/lastfm.ts:854:                            if (deezerImage) {
backend/src/services/lastfm.ts:855:                                image = deezerImage;
backend/src/routes/browse.ts:3:import { spotifyService } from "../services/spotify";
backend/src/routes/browse.ts:4:import { deezerService, DeezerPlaylistPreview, DeezerRadioStation } from "../services/deezer";
backend/src/routes/browse.ts:12: * Unified playlist preview type
backend/src/routes/browse.ts:14:interface PlaylistPreview {
backend/src/routes/browse.ts:16:    source: "deezer" | "spotify";
backend/src/routes/browse.ts:17:    type: "playlist" | "radio";
backend/src/routes/browse.ts:27: * Convert Deezer playlist to unified format
backend/src/routes/browse.ts:29:function deezerPlaylistToUnified(playlist: DeezerPlaylistPreview): PlaylistPreview {
backend/src/routes/browse.ts:31:        id: playlist.id,
backend/src/routes/browse.ts:32:        source: "deezer",
backend/src/routes/browse.ts:33:        type: "playlist",
backend/src/routes/browse.ts:34:        title: playlist.title,
backend/src/routes/browse.ts:35:        description: playlist.description,
backend/src/routes/browse.ts:36:        creator: playlist.creator,
backend/src/routes/browse.ts:37:        imageUrl: playlist.imageUrl,
backend/src/routes/browse.ts:38:        trackCount: playlist.trackCount,
backend/src/routes/browse.ts:39:        url: `https://www.deezer.com/playlist/${playlist.id}`,
backend/src/routes/browse.ts:44: * Convert Deezer radio to unified format
backend/src/routes/browse.ts:46:function deezerRadioToUnified(radio: DeezerRadioStation): PlaylistPreview {
backend/src/routes/browse.ts:49:        source: "deezer",
backend/src/routes/browse.ts:53:        creator: "Deezer",
backend/src/routes/browse.ts:56:        url: `https://www.deezer.com/radio-${radio.id}`,
backend/src/routes/browse.ts:61:// Playlist Endpoints
backend/src/routes/browse.ts:65: * GET /api/browse/playlists/featured
backend/src/routes/browse.ts:66: * Get featured/chart playlists from Deezer
backend/src/routes/browse.ts:68:router.get("/playlists/featured", async (req, res) => {
backend/src/routes/browse.ts:71:        console.log(`[Browse] Fetching featured playlists (limit: ${limit})...`);
backend/src/routes/browse.ts:73:        const playlists = await deezerService.getFeaturedPlaylists(limit);
backend/src/routes/browse.ts:74:        console.log(`[Browse] Got ${playlists.length} Deezer playlists`);
backend/src/routes/browse.ts:77:            playlists: playlists.map(deezerPlaylistToUnified),
backend/src/routes/browse.ts:78:            total: playlists.length,
backend/src/routes/browse.ts:79:            source: "deezer",
backend/src/routes/browse.ts:82:        console.error("Browse featured playlists error:", error);
backend/src/routes/browse.ts:83:        res.status(500).json({ error: error.message || "Failed to fetch playlists" });
backend/src/routes/browse.ts:88: * GET /api/browse/playlists/search
backend/src/routes/browse.ts:89: * Search for playlists on Deezer
backend/src/routes/browse.ts:91:router.get("/playlists/search", async (req, res) => {
backend/src/routes/browse.ts:99:        console.log(`[Browse] Searching playlists for "${query}"...`);
backend/src/routes/browse.ts:101:        const playlists = await deezerService.searchPlaylists(query, limit);
backend/src/routes/browse.ts:102:        console.log(`[Browse] Search "${query}": ${playlists.length} results`);
backend/src/routes/browse.ts:105:            playlists: playlists.map(deezerPlaylistToUnified),
backend/src/routes/browse.ts:106:            total: playlists.length,
backend/src/routes/browse.ts:108:            source: "deezer",
backend/src/routes/browse.ts:111:        console.error("Browse search playlists error:", error);
backend/src/routes/browse.ts:112:        res.status(500).json({ error: error.message || "Failed to search playlists" });
backend/src/routes/browse.ts:117: * GET /api/browse/playlists/:id
backend/src/routes/browse.ts:118: * Get full details of a Deezer playlist
backend/src/routes/browse.ts:120:router.get("/playlists/:id", async (req, res) => {
backend/src/routes/browse.ts:123:        const playlist = await deezerService.getPlaylist(id);
backend/src/routes/browse.ts:125:        if (!playlist) {
backend/src/routes/browse.ts:126:            return res.status(404).json({ error: "Playlist not found" });
backend/src/routes/browse.ts:130:            ...playlist,
backend/src/routes/browse.ts:131:            source: "deezer",
backend/src/routes/browse.ts:132:            url: `https://www.deezer.com/playlist/${id}`,
backend/src/routes/browse.ts:135:        console.error("Playlist fetch error:", error);
backend/src/routes/browse.ts:136:        res.status(500).json({ error: error.message || "Failed to fetch playlist" });
backend/src/routes/browse.ts:151:        const radios = await deezerService.getRadioStations();
backend/src/routes/browse.ts:154:            radios: radios.map(deezerRadioToUnified),
backend/src/routes/browse.ts:156:            source: "deezer",
backend/src/routes/browse.ts:171:        const genresWithRadios = await deezerService.getRadiosByGenre();
backend/src/routes/browse.ts:177:            radios: genre.radios.map(deezerRadioToUnified),
backend/src/routes/browse.ts:183:            source: "deezer",
backend/src/routes/browse.ts:193: * Get tracks from a radio station (as playlist format for import)
backend/src/routes/browse.ts:200:        const radioPlaylist = await deezerService.getRadioTracks(id);
backend/src/routes/browse.ts:202:        if (!radioPlaylist) {
backend/src/routes/browse.ts:207:            ...radioPlaylist,
backend/src/routes/browse.ts:208:            source: "deezer",
backend/src/routes/browse.ts:228:        const genres = await deezerService.getGenres();
backend/src/routes/browse.ts:233:            source: "deezer",
backend/src/routes/browse.ts:243: * Get content for a specific genre (playlists + radios)
backend/src/routes/browse.ts:253:        const content = await deezerService.getEditorialContent(genreId);
backend/src/routes/browse.ts:257:            playlists: content.playlists.map(deezerPlaylistToUnified),
backend/src/routes/browse.ts:258:            radios: content.radios.map(deezerRadioToUnified),
backend/src/routes/browse.ts:259:            source: "deezer",
backend/src/routes/browse.ts:268: * GET /api/browse/genres/:id/playlists
backend/src/routes/browse.ts:269: * Get playlists for a specific genre (by name search)
backend/src/routes/browse.ts:271:router.get("/genres/:id/playlists", async (req, res) => {
backend/src/routes/browse.ts:277:        const genres = await deezerService.getGenres();
backend/src/routes/browse.ts:284:        const playlists = await deezerService.getGenrePlaylists(genre.name, limit);
backend/src/routes/browse.ts:287:            playlists: playlists.map(deezerPlaylistToUnified),
backend/src/routes/browse.ts:288:            total: playlists.length,
backend/src/routes/browse.ts:290:            source: "deezer",
backend/src/routes/browse.ts:293:        console.error("Genre playlists error:", error);
backend/src/routes/browse.ts:294:        res.status(500).json({ error: error.message || "Failed to fetch genre playlists" });
backend/src/routes/browse.ts:299:// URL Parsing (supports both Spotify & Deezer)
backend/src/routes/browse.ts:303: * POST /api/browse/playlists/parse
backend/src/routes/browse.ts:304: * Parse a Spotify or Deezer URL and return playlist info
backend/src/routes/browse.ts:307:router.post("/playlists/parse", async (req, res) => {
backend/src/routes/browse.ts:314:        // Try Deezer first (our primary source)
backend/src/routes/browse.ts:315:        const deezerParsed = deezerService.parseUrl(url);
backend/src/routes/browse.ts:316:        if (deezerParsed && deezerParsed.type === "playlist") {
backend/src/routes/browse.ts:318:                source: "deezer",
backend/src/routes/browse.ts:319:                type: "playlist",
backend/src/routes/browse.ts:320:                id: deezerParsed.id,
backend/src/routes/browse.ts:321:                url: `https://www.deezer.com/playlist/${deezerParsed.id}`,
backend/src/routes/browse.ts:325:        // Try Spotify (still supported for URL imports)
backend/src/routes/browse.ts:326:        const spotifyParsed = spotifyService.parseUrl(url);
backend/src/routes/browse.ts:327:        if (spotifyParsed && spotifyParsed.type === "playlist") {
backend/src/routes/browse.ts:329:                source: "spotify",
backend/src/routes/browse.ts:330:                type: "playlist",
backend/src/routes/browse.ts:331:                id: spotifyParsed.id,
backend/src/routes/browse.ts:332:                url: `https://open.spotify.com/playlist/${spotifyParsed.id}`,
backend/src/routes/browse.ts:337:            error: "Invalid or unsupported URL. Please provide a Spotify or Deezer playlist URL." 
backend/src/routes/browse.ts:351: * Get a combined view of featured content (playlists, genres)
backend/src/routes/browse.ts:352: * Note: Radio stations are now internal (library-based), not from Deezer
backend/src/routes/browse.ts:356:        console.log("[Browse] Fetching browse content (playlists + genres)...");
backend/src/routes/browse.ts:358:        // Only fetch playlists and genres - radios are now internal library-based
backend/src/routes/browse.ts:359:        const [playlists, genres] = await Promise.all([
backend/src/routes/browse.ts:360:            deezerService.getFeaturedPlaylists(200),
backend/src/routes/browse.ts:361:            deezerService.getGenres(),
backend/src/routes/browse.ts:365:            playlists: playlists.map(deezerPlaylistToUnified),
backend/src/routes/browse.ts:369:            source: "deezer",
backend/src/utils/playlistLogger.ts:5: * Dedicated logger for Spotify Import and Playlist operations.
backend/src/utils/playlistLogger.ts:8: * This logger defaults to writing under ./logs/playlists (relative to process.cwd()).
backend/src/utils/playlistLogger.ts:10: * Override with PLAYLIST_LOG_DIR if you want a different location.
backend/src/utils/playlistLogger.ts:18:const LOGS_DIR = process.env.PLAYLIST_LOG_DIR
backend/src/utils/playlistLogger.ts:19:    ? path.resolve(process.env.PLAYLIST_LOG_DIR)
backend/src/utils/playlistLogger.ts:20:    : path.join(process.cwd(), 'logs', 'playlists');
backend/src/utils/playlistLogger.ts:31:        console.error('Failed to create playlist logs directory:', {
backend/src/utils/playlistLogger.ts:46:  SPOTIFY IMPORT SESSION LOG
backend/src/utils/playlistLogger.ts:117:class PlaylistLogger {
backend/src/utils/playlistLogger.ts:130:        this.write('INFO', `=== SPOTIFY IMPORT JOB: ${jobId} ===`);
backend/src/utils/playlistLogger.ts:142:            console.error(`[Playlist Logger] ${message}`);
backend/src/utils/playlistLogger.ts:144:            console.log(`[Playlist Logger] ${message}`);
backend/src/utils/playlistLogger.ts:156:            console.error(`[Playlist Logger] Failed to write to ${this.logFile}:`, error);
backend/src/utils/playlistLogger.ts:182:    logJobStart(playlistName: string, trackCount: number, userId: string): void {
backend/src/utils/playlistLogger.ts:183:        this.info(`Playlist: "${playlistName}" (${trackCount} tracks)`);
backend/src/utils/playlistLogger.ts:207:    logAlbumDownloadStart(count: number): void {
backend/src/utils/playlistLogger.ts:209:        this.info('--- ALBUM DOWNLOADS ---');
backend/src/utils/playlistLogger.ts:236:    logSlskdDownloadQueued(filesQueued: number, username: string): void {
backend/src/utils/playlistLogger.ts:240:    logSlskdDownloadFailed(reason: string): void {
backend/src/utils/playlistLogger.ts:241:        this.error(`✗ Soulseek download failed: ${reason}`);
backend/src/utils/playlistLogger.ts:244:    logDownloadProgress(completed: number, failed: number, pending: number): void {
backend/src/utils/playlistLogger.ts:245:        this.info(`Download status: ${completed} completed, ${failed} failed, ${pending} pending`);
backend/src/utils/playlistLogger.ts:248:    logPlaylistCreationStart(): void {
backend/src/utils/playlistLogger.ts:250:        this.info('--- PLAYLIST CREATION ---');
backend/src/utils/playlistLogger.ts:253:    logPlaylistCreated(playlistId: string, trackCount: number, totalTracks: number): void {
backend/src/utils/playlistLogger.ts:254:        this.info(`Created playlist: ${playlistId}`);
backend/src/utils/playlistLogger.ts:258:    logJobComplete(tracksMatched: number, tracksTotal: number, playlistId: string | null): void {
backend/src/utils/playlistLogger.ts:262:        if (playlistId) {
backend/src/utils/playlistLogger.ts:263:            this.info(`Playlist ID: ${playlistId}`);
backend/src/utils/playlistLogger.ts:281:export function createPlaylistLogger(jobId: string): PlaylistLogger {
backend/src/utils/playlistLogger.ts:282:    return new PlaylistLogger(jobId);
backend/src/utils/playlistLogger.ts:286:export function logPlaylistEvent(message: string): void {
backend/src/utils/playlistLogger.ts:291:    console.log(`[Playlist] ${message}`);
backend/src/workers/index.ts:13:import { downloadQueueManager } from "../services/downloadQueue";
backend/src/workers/index.ts:17:import { simpleDownloadManager } from "../services/simpleDownloadManager";
backend/src/workers/index.ts:31:// Register download queue callback for unavailable albums
backend/src/workers/index.ts:32:downloadQueueManager.onUnavailableAlbum(async (info) => {
backend/src/workers/index.ts:46:            orderBy: { downloadedAt: "desc" },
backend/src/workers/index.ts:108:            `Discover job ${job.id} completed: ${result.playlistName} (${result.songCount} songs)`
backend/src/workers/index.ts:209:// Run stale download cleanup every 2 minutes
backend/src/workers/index.ts:210:// This catches downloads that timed out even if the queue cleaner isn't running
backend/src/workers/index.ts:214:        const staleCount = await simpleDownloadManager.markStaleJobsAsFailed();
backend/src/workers/index.ts:217:                `⏰ Periodic cleanup: marked ${staleCount} stale download(s) as failed`
backend/src/workers/index.ts:221:        console.error("Stale download cleanup failed:", err);
backend/src/workers/index.ts:226:console.log("Stale download cleanup scheduled (every 2 minutes)");
backend/src/workers/index.ts:233:        const result = await simpleDownloadManager.clearLidarrQueue();
backend/src/workers/index.ts:236:                `Periodic Lidarr cleanup: removed ${result.removed} stuck download(s)`
backend/src/workers/index.ts:252:        const result = await simpleDownloadManager.clearLidarrQueue();
backend/src/workers/index.ts:255:                `Initial cleanup: removed ${result.removed} stuck download(s)`
backend/src/workers/index.ts:281:    // Shutdown download queue manager
backend/src/workers/index.ts:282:    downloadQueueManager.shutdown();
backend/src/workers/dataIntegrity.ts:10: * 6. Clean up old completed/failed DownloadJob records
backend/src/workers/dataIntegrity.ts:26:    oldDownloadJobs: number;
backend/src/workers/dataIntegrity.ts:40:        oldDownloadJobs: 0,
backend/src/workers/dataIntegrity.ts:147:    // - Discovery tracks have featured artists that don't match the download job
backend/src/workers/dataIntegrity.ts:148:    // - Lidarr downloads a different album than requested (e.g., "Broods" album vs "Evergreen" album)
backend/src/workers/dataIntegrity.ts:152:    const discoveryJobs = await prisma.downloadJob.findMany({
backend/src/workers/dataIntegrity.ts:177:    // This catches albums where Lidarr downloaded a different album than requested
backend/src/workers/dataIntegrity.ts:198:        // 1. BOTH album title AND artist name match a discovery download, OR
backend/src/workers/dataIntegrity.ts:199:        // 2. Artist MBID matches a discovery download
backend/src/workers/dataIntegrity.ts:380:    // 9. Clean up old DownloadJob records (older than 30 days, completed/failed)
backend/src/workers/dataIntegrity.ts:384:    const oldJobs = await prisma.downloadJob.deleteMany({
backend/src/workers/dataIntegrity.ts:390:    report.oldDownloadJobs = oldJobs.count;
backend/src/workers/dataIntegrity.ts:392:        console.log(`     Removed ${oldJobs.count} old download jobs`);
backend/src/workers/dataIntegrity.ts:406:    console.log(`   - Old download jobs: ${report.oldDownloadJobs}`);
frontend/features/settings/components/sections/LidarrSection.tsx:94:            title="Download Services"
frontend/features/settings/components/sections/LidarrSection.tsx:95:            description="Automate music downloads and library management"
frontend/features/settings/components/sections/LidarrSection.tsx:132:                        description="Quality profile for new downloads"
backend/src/utils/artistNormalization.ts:41:export function isVariousArtistsById(platform: 'deezer' | 'spotify', id: string | number): boolean {
backend/src/utils/artistNormalization.ts:42:    if (platform === 'deezer' && String(id) === '5080') {
backend/src/workers/artistEnrichment.ts:6:import { deezerService } from "../services/deezer";
backend/src/workers/artistEnrichment.ts:167:                    // Fallback to Deezer
backend/src/workers/artistEnrichment.ts:170:                            `${logPrefix} Deezer: Fetching for "${artist.name}"...`
backend/src/workers/artistEnrichment.ts:173:                            heroUrl = await deezerService.getArtistImage(
backend/src/workers/artistEnrichment.ts:177:                                imageSource = "deezer";
backend/src/workers/artistEnrichment.ts:179:                                    `${logPrefix} Deezer: SUCCESS - ${heroUrl.substring(
backend/src/workers/artistEnrichment.ts:186:                                    `${logPrefix} Deezer: No image found`
backend/src/workers/artistEnrichment.ts:191:                                `${logPrefix} Deezer: FAILED - ${
backend/src/workers/artistEnrichment.ts:381: * 2. For temp MBIDs or CAA failures: Use imageProviderService (Deezer -> Fanart -> Last.fm)
backend/src/workers/artistEnrichment.ts:429:                        // Strategy 2: Fallback to Deezer/other providers
backend/src/workers/artistEnrichment.ts:524:                        // Try imageProviderService which does Deezer -> CAA -> Fanart.tv
backend/src/routes/podcasts.ts:14: * Downloads and caches all podcast/episode covers locally
backend/src/routes/podcasts.ts:84:                autoDownloadEpisodes: false, // Per-podcast auto-download not yet implemented
backend/src/routes/podcasts.ts:485:                        downloads: {
backend/src/routes/podcasts.ts:506:            isDownloaded: episode.downloads.length > 0,
backend/src/routes/podcasts.ts:530:            autoDownloadEpisodes: false,
backend/src/routes/podcasts.ts:750:        // Also delete any downloaded episodes
backend/src/routes/podcasts.ts:751:        await prisma.podcastDownload.deleteMany({
backend/src/routes/podcasts.ts:870: * Also returns download progress if downloading
backend/src/routes/podcasts.ts:876:        const { getCachedFilePath, isDownloading, getDownloadProgress } =
backend/src/routes/podcasts.ts:877:            await import("../services/podcastDownload");
backend/src/routes/podcasts.ts:880:        const downloading = isDownloading(episodeId);
backend/src/routes/podcasts.ts:881:        const progress = getDownloadProgress(episodeId);
backend/src/routes/podcasts.ts:886:            downloading,
backend/src/routes/podcasts.ts:887:            downloadProgress: progress?.progress ?? null, // 0-100 or null
backend/src/routes/podcasts.ts:932:        // Import podcast download service
backend/src/routes/podcasts.ts:933:        const { getCachedFilePath, downloadInBackground, isDownloading } =
backend/src/routes/podcasts.ts:934:            await import("../services/podcastDownload");
backend/src/routes/podcasts.ts:1083:        // Not cached yet - trigger background download while streaming from RSS
backend/src/routes/podcasts.ts:1084:        if (userId && !isDownloading(episodeId)) {
backend/src/routes/podcasts.ts:1085:            console.log(`   Triggering background download for caching`);
backend/src/routes/podcasts.ts:1086:            downloadInBackground(episodeId, episode.audioUrl, userId);
frontend/components/ui/PlaylistSelector.tsx:8:interface PlaylistSelectorProps {
frontend/components/ui/PlaylistSelector.tsx:11:    onSelectPlaylist: (playlistId: string) => Promise<void>;
frontend/components/ui/PlaylistSelector.tsx:16:export function PlaylistSelector({
frontend/components/ui/PlaylistSelector.tsx:19:    onSelectPlaylist,
frontend/components/ui/PlaylistSelector.tsx:22:}: PlaylistSelectorProps) {
frontend/components/ui/PlaylistSelector.tsx:23:    const [playlists, setPlaylists] = useState<any[]>([]);
frontend/components/ui/PlaylistSelector.tsx:24:    const [newPlaylistName, setNewPlaylistName] = useState("");
frontend/components/ui/PlaylistSelector.tsx:31:            loadPlaylists();
frontend/components/ui/PlaylistSelector.tsx:35:    const loadPlaylists = async () => {
frontend/components/ui/PlaylistSelector.tsx:38:            const data = await api.getPlaylists();
frontend/components/ui/PlaylistSelector.tsx:39:            setPlaylists(Array.isArray(data) ? data : []);
frontend/components/ui/PlaylistSelector.tsx:41:            console.error("Failed to load playlists:", error);
frontend/components/ui/PlaylistSelector.tsx:47:    const handleCreatePlaylist = async () => {
frontend/components/ui/PlaylistSelector.tsx:48:        if (!newPlaylistName.trim()) return;
frontend/components/ui/PlaylistSelector.tsx:52:            const playlist = await api.createPlaylist(
frontend/components/ui/PlaylistSelector.tsx:53:                newPlaylistName.trim(),
frontend/components/ui/PlaylistSelector.tsx:56:            await onSelectPlaylist(playlist.id);
frontend/components/ui/PlaylistSelector.tsx:57:            setNewPlaylistName("");
frontend/components/ui/PlaylistSelector.tsx:61:                new CustomEvent("playlist-created", { detail: playlist })
frontend/components/ui/PlaylistSelector.tsx:66:            console.error("Failed to create playlist:", error);
frontend/components/ui/PlaylistSelector.tsx:72:    const handleSelectPlaylist = async (playlistId: string) => {
frontend/components/ui/PlaylistSelector.tsx:74:            await onSelectPlaylist(playlistId);
frontend/components/ui/PlaylistSelector.tsx:76:                new CustomEvent("playlist-updated", { detail: { playlistId } })
frontend/components/ui/PlaylistSelector.tsx:78:            await loadPlaylists();
frontend/components/ui/PlaylistSelector.tsx:81:            console.error("Failed to add to playlist:", error);
frontend/components/ui/PlaylistSelector.tsx:98:                        Add to Playlist
frontend/components/ui/PlaylistSelector.tsx:120:                    ) : playlists.length === 0 ? (
frontend/components/ui/PlaylistSelector.tsx:123:                            <p className="text-gray-400">No playlists yet</p>
frontend/components/ui/PlaylistSelector.tsx:129:                        playlists.map((playlist) => (
frontend/components/ui/PlaylistSelector.tsx:131:                                key={playlist.id}
frontend/components/ui/PlaylistSelector.tsx:133:                                    handleSelectPlaylist(playlist.id)
frontend/components/ui/PlaylistSelector.tsx:141:                                            {playlist.name}
frontend/components/ui/PlaylistSelector.tsx:144:                                            {playlist.trackCount || 0}{" "}
frontend/components/ui/PlaylistSelector.tsx:145:                                            {playlist.trackCount === 1
frontend/components/ui/PlaylistSelector.tsx:159:                        Create New Playlist
frontend/components/ui/PlaylistSelector.tsx:164:                            placeholder="Enter playlist name..."
frontend/components/ui/PlaylistSelector.tsx:165:                            value={newPlaylistName}
frontend/components/ui/PlaylistSelector.tsx:166:                            onChange={(e) => setNewPlaylistName(e.target.value)}
frontend/components/ui/PlaylistSelector.tsx:168:                                e.key === "Enter" && handleCreatePlaylist()
frontend/components/ui/PlaylistSelector.tsx:173:                            onClick={handleCreatePlaylist}
frontend/components/ui/PlaylistSelector.tsx:175:                                !newPlaylistName.trim() ||
frontend/features/settings/components/sections/StoragePathsSection.tsx:33:                label="Download path"
frontend/features/settings/components/sections/StoragePathsSection.tsx:34:                description="Path for new downloads"
frontend/features/settings/components/sections/StoragePathsSection.tsx:37:                    value={settings.downloadPath}
frontend/features/settings/components/sections/StoragePathsSection.tsx:38:                    onChange={(v) => onUpdate({ downloadPath: v })}
frontend/features/settings/components/sections/StoragePathsSection.tsx:39:                    placeholder="/downloads"
backend/src/routes/releases.ts:33:    canDownload: boolean;
backend/src/routes/releases.ts:123:                canDownload: !inLibrary && !isUpcoming,
backend/src/routes/releases.ts:184: * Get recently released albums (last X days) that user might want to download
backend/src/routes/releases.ts:196:        // Get library albums to mark what's already downloaded
backend/src/routes/releases.ts:223: * POST /releases/download/:albumMbid
backend/src/routes/releases.ts:225: * Download a release from the radar
backend/src/routes/releases.ts:227:router.post("/download/:albumMbid", async (req, res) => {
backend/src/routes/releases.ts:236:        console.log(`[Releases] Download requested for album: ${albumMbid}`);
backend/src/routes/releases.ts:238:        // Use Lidarr to download the album
backend/src/routes/releases.ts:239:        const result = await lidarrService.downloadAlbum(albumMbid);
backend/src/routes/releases.ts:244:                message: "Download started",
backend/src/routes/releases.ts:249:                error: "Album not found in Lidarr or download failed" 
backend/src/routes/releases.ts:253:        console.error("[Releases] Download error:", error.message);
backend/src/routes/releases.ts:254:        res.status(500).json({ error: "Failed to start download" });
frontend/features/home/components/FeaturedPlaylistsGrid.tsx:8:interface PlaylistPreview {
frontend/features/home/components/FeaturedPlaylistsGrid.tsx:20:interface FeaturedPlaylistsGridProps {
frontend/features/home/components/FeaturedPlaylistsGrid.tsx:21:    playlists: PlaylistPreview[];
frontend/features/home/components/FeaturedPlaylistsGrid.tsx:24:// Deezer icon
frontend/features/home/components/FeaturedPlaylistsGrid.tsx:25:const DeezerIcon = ({ className }: { className?: string }) => (
frontend/features/home/components/FeaturedPlaylistsGrid.tsx:31:interface PlaylistCardProps {
frontend/features/home/components/FeaturedPlaylistsGrid.tsx:32:    playlist: PlaylistPreview;
frontend/features/home/components/FeaturedPlaylistsGrid.tsx:36:const PlaylistCard = memo(function PlaylistCard({ 
frontend/features/home/components/FeaturedPlaylistsGrid.tsx:37:    playlist, 
frontend/features/home/components/FeaturedPlaylistsGrid.tsx:39:}: PlaylistCardProps) {
frontend/features/home/components/FeaturedPlaylistsGrid.tsx:47:                    {playlist.imageUrl ? (
frontend/features/home/components/FeaturedPlaylistsGrid.tsx:49:                            src={playlist.imageUrl}
frontend/features/home/components/FeaturedPlaylistsGrid.tsx:50:                            alt={playlist.title}
frontend/features/home/components/FeaturedPlaylistsGrid.tsx:66:                    {/* Deezer badge */}
frontend/features/home/components/FeaturedPlaylistsGrid.tsx:68:                        <DeezerIcon className="w-4 h-4 text-[#AD47FF] drop-shadow-lg" />
frontend/features/home/components/FeaturedPlaylistsGrid.tsx:72:                    {playlist.title}
frontend/features/home/components/FeaturedPlaylistsGrid.tsx:75:                    {playlist.trackCount} songs
frontend/features/home/components/FeaturedPlaylistsGrid.tsx:82:export function FeaturedPlaylistsGrid({ playlists }: FeaturedPlaylistsGridProps) {
frontend/features/home/components/FeaturedPlaylistsGrid.tsx:85:    const handlePlaylistClick = (playlist: PlaylistPreview) => {
frontend/features/home/components/FeaturedPlaylistsGrid.tsx:86:        router.push(`/browse/playlists/${playlist.id}`);
frontend/features/home/components/FeaturedPlaylistsGrid.tsx:89:    if (!playlists || playlists.length === 0) {
frontend/features/home/components/FeaturedPlaylistsGrid.tsx:95:            {playlists.slice(0, 20).map((playlist, index) => (
frontend/features/home/components/FeaturedPlaylistsGrid.tsx:96:                <PlaylistCard 
frontend/features/home/components/FeaturedPlaylistsGrid.tsx:97:                    key={`home-playlist-${playlist.id}-${index}`}
frontend/features/home/components/FeaturedPlaylistsGrid.tsx:98:                    playlist={playlist} 
frontend/features/home/components/FeaturedPlaylistsGrid.tsx:99:                    onClick={() => handlePlaylistClick(playlist)} 
frontend/features/settings/components/sections/DownloadPreferencesSection.tsx:6:interface DownloadPreferencesSectionProps {
frontend/features/settings/components/sections/DownloadPreferencesSection.tsx:11:export function DownloadPreferencesSection({
frontend/features/settings/components/sections/DownloadPreferencesSection.tsx:14:}: DownloadPreferencesSectionProps) {
frontend/features/settings/components/sections/DownloadPreferencesSection.tsx:17:            id="download-preferences"
frontend/features/settings/components/sections/DownloadPreferencesSection.tsx:18:            title="Download Preferences"
frontend/features/settings/components/sections/DownloadPreferencesSection.tsx:19:            description="Configure how music is downloaded for playlists and discovery"
frontend/features/settings/components/sections/DownloadPreferencesSection.tsx:22:                label="Primary Download Source"
frontend/features/settings/components/sections/DownloadPreferencesSection.tsx:23:                description="Choose how to download music for imported playlists"
frontend/features/settings/components/sections/DownloadPreferencesSection.tsx:26:                    value={settings.downloadSource || "soulseek"}
frontend/features/settings/components/sections/DownloadPreferencesSection.tsx:28:                        onUpdate({ downloadSource: v as "soulseek" | "lidarr" })
frontend/features/settings/components/sections/DownloadPreferencesSection.tsx:37:            {settings.downloadSource === "soulseek" && (
frontend/features/settings/components/sections/DownloadPreferencesSection.tsx:53:                                label: "Download full album via Lidarr",
backend/src/services/imageProvider.ts:5: * 1. Deezer (most reliable, high quality)
backend/src/services/imageProvider.ts:22:    source: "deezer" | "fanart" | "musicbrainz" | "lastfm" | "spotify";
backend/src/services/imageProvider.ts:28:    private readonly DEEZER_API_URL = "https://api.deezer.com";
backend/src/services/imageProvider.ts:43:        // Try Deezer first (most reliable)
backend/src/services/imageProvider.ts:45:            const deezerImage = await this.getArtistImageFromDeezer(
backend/src/services/imageProvider.ts:49:            if (deezerImage) {
backend/src/services/imageProvider.ts:50:                console.log(`  Found image from Deezer`);
backend/src/services/imageProvider.ts:51:                return deezerImage;
backend/src/services/imageProvider.ts:55:                `    Deezer failed: ${
backend/src/services/imageProvider.ts:138:        // Try Deezer first (most reliable)
backend/src/services/imageProvider.ts:140:            const deezerCover = await this.getAlbumCoverFromDeezer(
backend/src/services/imageProvider.ts:145:            if (deezerCover) {
backend/src/services/imageProvider.ts:146:                console.log(`  Found cover from Deezer`);
backend/src/services/imageProvider.ts:147:                return deezerCover;
backend/src/services/imageProvider.ts:151:                `    Deezer failed: ${
backend/src/services/imageProvider.ts:202:     * Search Deezer for artist image
backend/src/services/imageProvider.ts:204:    private async getArtistImageFromDeezer(
backend/src/services/imageProvider.ts:209:        const response = await rateLimiter.execute("deezer", () =>
backend/src/services/imageProvider.ts:210:            axios.get(`${this.DEEZER_API_URL}/search/artist`, {
backend/src/services/imageProvider.ts:218:            // Deezer provides: picture, picture_small, picture_medium, picture_big, picture_xl
backend/src/services/imageProvider.ts:224:                    source: "deezer",
backend/src/services/imageProvider.ts:234:     * Search Deezer for album cover
backend/src/services/imageProvider.ts:236:    private async getAlbumCoverFromDeezer(
backend/src/services/imageProvider.ts:243:        const response = await rateLimiter.execute("deezer", () =>
backend/src/services/imageProvider.ts:244:            axios.get(`${this.DEEZER_API_URL}/search/album`, {
backend/src/services/imageProvider.ts:267:            // Deezer provides: cover, cover_small, cover_medium, cover_big, cover_xl
backend/src/services/imageProvider.ts:272:                    source: "deezer",
backend/src/routes/subsonic.ts:1222: * download.view - Download original file
backend/src/routes/subsonic.ts:1224:router.get("/download.view", async (req: Request, res: Response) => {
backend/src/routes/subsonic.ts:1271:        res.download(absolutePath, filename);
backend/src/routes/subsonic.ts:1273:        console.error("[Subsonic] download error:", error);
backend/src/routes/subsonic.ts:1277:            "Failed to download",
backend/src/routes/subsonic.ts:1407:        // Download, cache, and serve external URL
backend/src/routes/subsonic.ts:1481:// PLAYLIST ENDPOINTS
backend/src/routes/subsonic.ts:1485: * getPlaylists.view - Get all playlists
backend/src/routes/subsonic.ts:1487:router.get("/getPlaylists.view", async (req: Request, res: Response) => {
backend/src/routes/subsonic.ts:1491:        const playlists = await prisma.playlist.findMany({
backend/src/routes/subsonic.ts:1499:        const playlistList = playlists.map((pl) => ({
backend/src/routes/subsonic.ts:1512:            { playlists: { playlist: playlistList } },
backend/src/routes/subsonic.ts:1517:        console.error("[Subsonic] getPlaylists error:", error);
backend/src/routes/subsonic.ts:1521:            "Failed to fetch playlists",
backend/src/routes/subsonic.ts:1529: * getPlaylist.view - Get playlist with tracks
backend/src/routes/subsonic.ts:1531:router.get("/getPlaylist.view", async (req: Request, res: Response) => {
backend/src/routes/subsonic.ts:1546:        const { id: playlistId } = parseSubsonicId(id as string);
backend/src/routes/subsonic.ts:1548:        const playlist = await prisma.playlist.findUnique({
backend/src/routes/subsonic.ts:1549:            where: { id: playlistId },
backend/src/routes/subsonic.ts:1568:        if (!playlist || playlist.userId !== req.user!.id) {
backend/src/routes/subsonic.ts:1572:                "Playlist not found",
backend/src/routes/subsonic.ts:1578:        // Get play data for all tracks in playlist
backend/src/routes/subsonic.ts:1579:        const trackIds = playlist.items.filter(item => item.track?.album).map(item => item.track.id);
backend/src/routes/subsonic.ts:1589:        const songs = playlist.items
backend/src/routes/subsonic.ts:1607:        const totalDuration = playlist.items.reduce(
backend/src/routes/subsonic.ts:1615:                playlist: {
backend/src/routes/subsonic.ts:1616:                    id: `pl-${playlist.id}`,
backend/src/routes/subsonic.ts:1617:                    name: playlist.name,
backend/src/routes/subsonic.ts:1622:                    created: playlist.createdAt.toISOString(),
backend/src/routes/subsonic.ts:1623:                    changed: playlist.createdAt.toISOString(), // No updatedAt field
backend/src/routes/subsonic.ts:1631:        console.error("[Subsonic] getPlaylist error:", error);
backend/src/routes/subsonic.ts:1635:            "Failed to fetch playlist",
backend/src/routes/subsonic.ts:1643: * createPlaylist.view - Create or update playlist
backend/src/routes/subsonic.ts:1645:router.get("/createPlaylist.view", async (req: Request, res: Response) => {
backend/src/routes/subsonic.ts:1647:    const { playlistId, name } = req.query;
backend/src/routes/subsonic.ts:1656:        if (playlistId) {
backend/src/routes/subsonic.ts:1657:            // Update existing playlist
backend/src/routes/subsonic.ts:1658:            const { id: plId } = parseSubsonicId(playlistId as string);
backend/src/routes/subsonic.ts:1661:            const existingPlaylist = await prisma.playlist.findUnique({
backend/src/routes/subsonic.ts:1666:            if (!existingPlaylist || existingPlaylist.userId !== req.user!.id) {
backend/src/routes/subsonic.ts:1670:                    "Not authorized to modify this playlist",
backend/src/routes/subsonic.ts:1677:                await prisma.playlist.update({
backend/src/routes/subsonic.ts:1685:                await prisma.playlistItem.deleteMany({
backend/src/routes/subsonic.ts:1686:                    where: { playlistId: plId },
backend/src/routes/subsonic.ts:1691:                await prisma.playlistItem.createMany({
backend/src/routes/subsonic.ts:1693:                        playlistId: plId,
backend/src/routes/subsonic.ts:1702:            // Create new playlist
backend/src/routes/subsonic.ts:1703:            const playlist = await prisma.playlist.create({
backend/src/routes/subsonic.ts:1713:                await prisma.playlistItem.createMany({
backend/src/routes/subsonic.ts:1715:                        playlistId: playlist.id,
backend/src/routes/subsonic.ts:1727:                "Required parameter 'name' or 'playlistId' is missing",
backend/src/routes/subsonic.ts:1733:        console.error("[Subsonic] createPlaylist error:", error);
backend/src/routes/subsonic.ts:1737:            "Failed to create/update playlist",
backend/src/routes/subsonic.ts:1745: * updatePlaylist.view - Update playlist (add/remove songs)
backend/src/routes/subsonic.ts:1747:router.get("/updatePlaylist.view", async (req: Request, res: Response) => {
backend/src/routes/subsonic.ts:1749:    const { playlistId, name, songIdToAdd, songIndexToRemove } = req.query;
backend/src/routes/subsonic.ts:1751:    if (!playlistId) {
backend/src/routes/subsonic.ts:1755:            "Required parameter 'playlistId' is missing",
backend/src/routes/subsonic.ts:1762:        const { id: plId } = parseSubsonicId(playlistId as string);
backend/src/routes/subsonic.ts:1765:        const playlist = await prisma.playlist.findUnique({
backend/src/routes/subsonic.ts:1770:        if (!playlist || playlist.userId !== req.user!.id) {
backend/src/routes/subsonic.ts:1774:                "Not authorized to modify this playlist",
backend/src/routes/subsonic.ts:1782:            await prisma.playlist.update({
backend/src/routes/subsonic.ts:1791:            const currentMax = await prisma.playlistItem.aggregate({
backend/src/routes/subsonic.ts:1792:                where: { playlistId: plId },
backend/src/routes/subsonic.ts:1799:            await prisma.playlistItem.createMany({
backend/src/routes/subsonic.ts:1801:                    playlistId: plId,
backend/src/routes/subsonic.ts:1814:            const items = await prisma.playlistItem.findMany({
backend/src/routes/subsonic.ts:1815:                where: { playlistId: plId },
backend/src/routes/subsonic.ts:1824:                await prisma.playlistItem.deleteMany({
backend/src/routes/subsonic.ts:1832:        console.error("[Subsonic] updatePlaylist error:", error);
backend/src/routes/subsonic.ts:1836:            "Failed to update playlist",
backend/src/routes/subsonic.ts:1844: * deletePlaylist.view - Delete a playlist
backend/src/routes/subsonic.ts:1846:router.get("/deletePlaylist.view", async (req: Request, res: Response) => {
backend/src/routes/subsonic.ts:1861:        const { id: playlistId } = parseSubsonicId(id as string);
backend/src/routes/subsonic.ts:1864:        const playlist = await prisma.playlist.findUnique({
backend/src/routes/subsonic.ts:1865:            where: { id: playlistId },
backend/src/routes/subsonic.ts:1868:        if (!playlist || playlist.userId !== req.user!.id) {
backend/src/routes/subsonic.ts:1872:                "Not authorized to delete this playlist",
backend/src/routes/subsonic.ts:1879:        await prisma.playlistItem.deleteMany({
backend/src/routes/subsonic.ts:1880:            where: { playlistId },
backend/src/routes/subsonic.ts:1883:        await prisma.playlist.delete({
backend/src/routes/subsonic.ts:1884:            where: { id: playlistId },
backend/src/routes/subsonic.ts:1889:        console.error("[Subsonic] deletePlaylist error:", error);
backend/src/routes/subsonic.ts:1893:            "Failed to delete playlist",
backend/src/routes/subsonic.ts:1990:                downloadRole: true,
backend/src/routes/subsonic.ts:1992:                playlistRole: true,
backend/src/routes/subsonic.ts:2024:    // TODO: Implement starring (add to favorites playlist)
frontend/features/settings/components/sections/SoulseekSection.tsx:39:            description="Configure direct Soulseek connection for P2P music downloads"
frontend/features/settings/components/sections/SoulseekSection.tsx:96:                    Downloads will be saved to your Singles folder automatically
frontend/components/ui/PlayableCard.tsx:6:import { Play, Pause, Check, Download, Search } from "lucide-react";
frontend/components/ui/PlayableCard.tsx:22:    onDownload?: (e: React.MouseEvent) => void;
frontend/components/ui/PlayableCard.tsx:26:    badge?: "owned" | "download" | null;
frontend/components/ui/PlayableCard.tsx:27:    isDownloading?: boolean;
frontend/components/ui/PlayableCard.tsx:40:    onDownload,
frontend/components/ui/PlayableCard.tsx:45:    isDownloading = false,
frontend/components/ui/PlayableCard.tsx:137:                    {badge === "download" && (
frontend/components/ui/PlayableCard.tsx:139:                            {/* Download Button - Icon only */}
frontend/components/ui/PlayableCard.tsx:145:                                    if (!isDownloading && onDownload) {
frontend/components/ui/PlayableCard.tsx:146:                                        onDownload(e);
frontend/components/ui/PlayableCard.tsx:152:                                disabled={isDownloading}
frontend/components/ui/PlayableCard.tsx:155:                                    isDownloading
frontend/components/ui/PlayableCard.tsx:159:                                title={isDownloading ? "Downloading..." : "Quick Download"}
frontend/components/ui/PlayableCard.tsx:161:                                <Download
frontend/components/ui/PlayableCard.tsx:164:                                        isDownloading && "animate-pulse"
frontend/components/ui/PlayableCard.tsx:175:                                        if (!isDownloading) {
frontend/components/ui/PlayableCard.tsx:182:                                    disabled={isDownloading}
frontend/components/ui/PlayableCard.tsx:185:                                        isDownloading
backend/src/routes/library.ts:16:import { deezerService } from "../services/deezer";
backend/src/routes/library.ts:128:        // First, organize any SLSKD downloads from Docker container to music library
backend/src/routes/library.ts:134:            console.log("[Scan] Organizing SLSKD downloads before scan...");
backend/src/routes/library.ts:504:                        // Fallback to Deezer
backend/src/routes/library.ts:507:                                coverArt = await deezerService.getArtistImage(
backend/src/routes/library.ts:511:                                // Deezer failed, continue to next source
backend/src/routes/library.ts:663:                    // Fallback to Deezer
backend/src/routes/library.ts:666:                            coverArt = await deezerService.getArtistImage(
backend/src/routes/library.ts:670:                            // Deezer failed, continue to next source
backend/src/routes/library.ts:1095:                    ? `${tempMbidCount} artists have temp MBIDs - Fanart.tv won't work for them, relies on Deezer/Last.fm`
backend/src/routes/library.ts:1289:        // ========== Supplement with MusicBrainz discography for "available to download" ==========
backend/src/routes/library.ts:1676:                            // Try to get cover via track search on Deezer (most reliable for popular tracks)
backend/src/routes/library.ts:1678:                                const trackInfo = await deezerService.getTrackPreviewWithInfo(
backend/src/routes/library.ts:1684:                                    // Also update album title if we got it from Deezer
backend/src/routes/library.ts:1823:                // Fetch images in parallel from Deezer (cached in Redis)
backend/src/routes/library.ts:1833:                        // If no library image, try Deezer
backend/src/routes/library.ts:1837:                                const cacheKey = `deezer-artist-image:${s.name}`;
backend/src/routes/library.ts:1842:                                    image = await deezerService.getArtistImage(
backend/src/routes/library.ts:1854:                                // Deezer failed, leave null
backend/src/routes/library.ts:1947:                        // Fetch images in parallel (Deezer only - fastest source)
backend/src/routes/library.ts:1959:                                            await deezerService.getArtistImage(
backend/src/routes/library.ts:1963:                                        // Deezer failed, leave null
backend/src/routes/library.ts:2408:                // Native cover file missing - try to find album and fetch from Deezer
backend/src/routes/library.ts:2410:                    `[COVER-ART] Native cover not found: ${coverCachePath}, trying Deezer fallback`
backend/src/routes/library.ts:2422:                        const deezerCover = await deezerService.getAlbumCover(
backend/src/routes/library.ts:2427:                        if (deezerCover) {
backend/src/routes/library.ts:2428:                            // Update album with Deezer cover
backend/src/routes/library.ts:2431:                                data: { coverUrl: deezerCover },
backend/src/routes/library.ts:2434:                            // Redirect to the Deezer cover
backend/src/routes/library.ts:2435:                            return res.redirect(deezerCover);
backend/src/routes/library.ts:2440:                        `[COVER-ART] Failed to fetch Deezer fallback for ${albumId}:`,
backend/src/routes/library.ts:2586:// Returns a redirect to the cover image (Deezer -> CAA -> Fanart.tv fallback chain)
backend/src/routes/library.ts:2592:        const { artist, album, json } = req.query; // Optional: artist/album name for Deezer search
backend/src/routes/library.ts:2648:                // 4. Cache miss - fetch using imageProviderService (Deezer -> CAA -> Fanart.tv)
backend/src/routes/library.ts:2657:                    // Cache the URL lookup result (7 days) - much faster than re-querying Deezer
backend/src/routes/artists.ts:5:import { deezerService } from "../services/deezer";
backend/src/routes/artists.ts:62:        // Fetch from Deezer (fast)
backend/src/routes/artists.ts:63:        const image = await deezerService.getArtistImage(artistName);
backend/src/routes/artists.ts:196:                // Try to get an image from Deezer
backend/src/routes/artists.ts:199:                    image = await deezerService.getArtistImage(rec.artistName);
backend/src/routes/artists.ts:393:                    image = await deezerService.getArtistImage(rec.artistName);
backend/src/routes/artists.ts:423:// GET /artists/preview/:artistName/:trackTitle - Get Deezer preview URL for a track
backend/src/routes/artists.ts:443:        const previewInfo = await deezerService.getTrackPreviewWithInfo(
backend/src/routes/artists.ts:477:        const previewInfo = await deezerService.getTrackPreviewWithInfo(
backend/src/routes/artists.ts:577:        // for external API compatibility (Last.fm, Deezer won't recognize "ＧＨＯＳＴ")
backend/src/routes/artists.ts:648:        // Fallback to Deezer
backend/src/routes/artists.ts:651:                image = await deezerService.getArtistImage(artistName);
backend/src/routes/artists.ts:653:                    console.log(`Deezer image for ${artistName}`);
backend/src/routes/artists.ts:656:                console.log(`✗ Failed to get Deezer image for ${artistName}`);
backend/src/routes/artists.ts:726:                                // Frontend will fetch this, endpoint handles Deezer -> CAA -> Fanart.tv fallback
backend/src/routes/artists.ts:744:                            rgMbid: rg.id, // Release group MBID - used for downloads
backend/src/routes/artists.ts:795:                // Fallback to Deezer
backend/src/routes/artists.ts:798:                        const deezerImage = await deezerService.getArtistImage(
backend/src/routes/artists.ts:801:                        if (deezerImage) {
backend/src/routes/artists.ts:802:                            image = deezerImage;
backend/src/routes/artists.ts:980:                    `✗ Cover Art Archive 404 for ${albumTitle}, trying Deezer...`
backend/src/routes/artists.ts:985:                `✗ Cover Art Archive check failed for ${albumTitle}, trying Deezer...`
backend/src/routes/artists.ts:989:        // Fallback to Deezer if Cover Art Archive doesn't have it
backend/src/routes/artists.ts:992:                const deezerCover = await deezerService.getAlbumCover(
backend/src/routes/artists.ts:996:                if (deezerCover) {
backend/src/routes/artists.ts:997:                    coverUrl = deezerCover;
backend/src/routes/artists.ts:998:                    console.log(`Deezer has cover for ${albumTitle}`);
backend/src/routes/artists.ts:1004:                console.log(`✗ Deezer lookup failed for ${albumTitle}`);
backend/src/routes/systemSettings.ts:100:    // Download Services
backend/src/routes/systemSettings.ts:122:    // Spotify (for playlist import)
backend/src/routes/systemSettings.ts:123:    spotifyClientId: z.string().nullable().optional(),
backend/src/routes/systemSettings.ts:124:    spotifyClientSecret: z.string().nullable().optional(),
backend/src/routes/systemSettings.ts:128:    downloadPath: z.string().optional(),
backend/src/routes/systemSettings.ts:135:    maxConcurrentDownloads: z.number().optional(),
backend/src/routes/systemSettings.ts:136:    downloadRetryAttempts: z.number().optional(),
backend/src/routes/systemSettings.ts:139:    // Download Preferences
backend/src/routes/systemSettings.ts:140:    downloadSource: z.enum(["soulseek", "lidarr"]).optional(),
backend/src/routes/systemSettings.ts:164:                    downloadPath: "/downloads",
backend/src/routes/systemSettings.ts:167:                    maxConcurrentDownloads: 3,
backend/src/routes/systemSettings.ts:168:                    downloadRetryAttempts: 3,
backend/src/routes/systemSettings.ts:183:            spotifyClientSecret: safeDecrypt(settings.spotifyClientSecret),
backend/src/routes/systemSettings.ts:218:        if (data.spotifyClientSecret)
backend/src/routes/systemSettings.ts:219:            encryptedData.spotifyClientSecret = encrypt(data.spotifyClientSecret);
backend/src/routes/systemSettings.ts:322:                    onAlbumDownload: true,
backend/src/routes/systemSettings.ts:323:                    onDownloadFailure: true,
backend/src/routes/systemSettings.ts:331:                    supportsOnAlbumDownload: true,
backend/src/routes/systemSettings.ts:332:                    supportsOnDownloadFailure: true,
backend/src/routes/systemSettings.ts:645:// Test Spotify credentials
backend/src/routes/systemSettings.ts:646:router.post("/test-spotify", async (req, res) => {
backend/src/routes/systemSettings.ts:656:        // Import spotifyService to test credentials
backend/src/routes/systemSettings.ts:657:        const { spotifyService } = await import("../services/spotify");
backend/src/routes/systemSettings.ts:658:        const result = await spotifyService.testCredentials(clientId, clientSecret);
backend/src/routes/systemSettings.ts:663:                message: "Spotify credentials are valid",
backend/src/routes/systemSettings.ts:667:                error: result.error || "Invalid Spotify credentials",
backend/src/routes/systemSettings.ts:671:        console.error("Spotify test error:", error.message);
backend/src/routes/systemSettings.ts:673:            error: "Failed to test Spotify credentials",
frontend/features/library/hooks/useLibraryActions.ts:101:    const addTrackToPlaylist = async (playlistId: string, trackId: string) => {
frontend/features/library/hooks/useLibraryActions.ts:103:            await api.addTrackToPlaylist(playlistId, trackId);
frontend/features/library/hooks/useLibraryActions.ts:105:            console.error("Error adding track to playlist:", error);
frontend/features/library/hooks/useLibraryActions.ts:141:        addTrackToPlaylist,
backend/src/workers/processors/scanProcessor.ts:9:    albumMbid?: string; // Optional: if scan triggered by download completion
backend/src/workers/processors/scanProcessor.ts:10:    artistMbid?: string; // Optional: if scan triggered by download completion
backend/src/workers/processors/scanProcessor.ts:11:    source?: string; // Optional: source of scan (e.g., "lidarr-webhook", "discover-weekly-completion", "spotify-import")
backend/src/workers/processors/scanProcessor.ts:12:    downloadId?: string; // Optional: Lidarr download ID for precise job linking
backend/src/workers/processors/scanProcessor.ts:14:    spotifyImportJobId?: string; // Optional: Spotify Import job ID
backend/src/workers/processors/scanProcessor.ts:38:        downloadId,
backend/src/workers/processors/scanProcessor.ts:40:        spotifyImportJobId,
backend/src/workers/processors/scanProcessor.ts:164:        // If this scan was triggered by a download completion, mark download jobs as completed
backend/src/workers/processors/scanProcessor.ts:167:            (albumMbid || artistMbid || downloadId)
backend/src/workers/processors/scanProcessor.ts:170:                `[ScanJob ${job.id}] Marking download jobs as completed after successful scan`
backend/src/workers/processors/scanProcessor.ts:175:                await prisma.downloadJob.updateMany({
backend/src/workers/processors/scanProcessor.ts:187:                    `[ScanJob ${job.id}] Marked artist download as completed: ${artistMbid}`
backend/src/workers/processors/scanProcessor.ts:219:                const updatedByMbid = await prisma.downloadJob.updateMany({
backend/src/workers/processors/scanProcessor.ts:233:                        `[ScanJob ${job.id}] Marked ${updatedByMbid.count} album download(s) as completed by MBID: ${albumMbid}`
backend/src/workers/processors/scanProcessor.ts:236:                    // Fallback: Try to find the album by artist+title and match download jobs
backend/src/workers/processors/scanProcessor.ts:238:                        `[ScanJob ${job.id}] No downloads matched by MBID, trying artist+title match...`
backend/src/workers/processors/scanProcessor.ts:248:                            await prisma.downloadJob.updateMany({
backend/src/workers/processors/scanProcessor.ts:265:                                `[ScanJob ${job.id}] Marked ${updatedByName.count} album download(s) as completed by title match: ${album.artist.name} - ${album.title}`
backend/src/workers/processors/scanProcessor.ts:269:                                `[ScanJob ${job.id}]   No pending downloads found for: ${album.artist.name} - ${album.title}`
backend/src/workers/processors/scanProcessor.ts:307:            if (downloadId) {
backend/src/workers/processors/scanProcessor.ts:308:                const updated = await prisma.downloadJob.updateMany({
backend/src/workers/processors/scanProcessor.ts:310:                        lidarrRef: downloadId,
backend/src/workers/processors/scanProcessor.ts:320:                        `[ScanJob ${job.id}] Linked Lidarr download ${downloadId} to ${updated.count} job(s)`
backend/src/workers/processors/scanProcessor.ts:324:                        `[ScanJob ${job.id}]   No download jobs found for Lidarr ID ${downloadId}`
backend/src/workers/processors/scanProcessor.ts:330:        // If this scan was for Discovery Weekly, build the final playlist
backend/src/workers/processors/scanProcessor.ts:333:                `[ScanJob ${job.id}]  Building Discovery Weekly playlist for batch ${discoveryBatchId}...`
backend/src/workers/processors/scanProcessor.ts:339:                await discoverWeeklyService.buildFinalPlaylist(
backend/src/workers/processors/scanProcessor.ts:343:                    `[ScanJob ${job.id}] Discovery Weekly playlist complete!`
backend/src/workers/processors/scanProcessor.ts:347:                    `[ScanJob ${job.id}]  Failed to build Discovery playlist:`,
backend/src/workers/processors/scanProcessor.ts:353:        // If this scan was for Spotify Import, build the final playlist
backend/src/workers/processors/scanProcessor.ts:354:        if (source === "spotify-import" && spotifyImportJobId) {
backend/src/workers/processors/scanProcessor.ts:356:                `[ScanJob ${job.id}]  Building Spotify Import playlist for job ${spotifyImportJobId}...`
backend/src/workers/processors/scanProcessor.ts:359:                const { spotifyImportService } = await import(
backend/src/workers/processors/scanProcessor.ts:360:                    "../../services/spotifyImport"
backend/src/workers/processors/scanProcessor.ts:362:                await spotifyImportService.buildPlaylistAfterScan(
backend/src/workers/processors/scanProcessor.ts:363:                    spotifyImportJobId
backend/src/workers/processors/scanProcessor.ts:366:                    `[ScanJob ${job.id}] Spotify Import playlist complete!`
backend/src/workers/processors/scanProcessor.ts:370:                    `[ScanJob ${job.id}]  Failed to build Spotify Import playlist:`,
backend/src/workers/processors/scanProcessor.ts:392:        // Reconcile pending tracks from Spotify playlist imports
backend/src/workers/processors/scanProcessor.ts:398:                console.log(`[ScanJob ${job.id}] Checking for pending playlist tracks to reconcile...`);
backend/src/workers/processors/scanProcessor.ts:399:                const { spotifyImportService } = await import(
backend/src/workers/processors/scanProcessor.ts:400:                    "../../services/spotifyImport"
backend/src/workers/processors/scanProcessor.ts:402:                const reconcileResult = await spotifyImportService.reconcilePendingTracks();
backend/src/workers/processors/scanProcessor.ts:405:                        `[ScanJob ${job.id}] ✓ Reconciled ${reconcileResult.tracksAdded} pending tracks to ${reconcileResult.playlistsUpdated} playlists`
backend/src/workers/processors/scanProcessor.ts:416:                                "Playlist Tracks Matched",
backend/src/workers/processors/scanProcessor.ts:417:                                `${reconcileResult.tracksAdded} previously unmatched tracks were added to your playlists`
backend/src/routes/spotify.ts:4:import { spotifyService } from "../services/spotify";
backend/src/routes/spotify.ts:5:import { spotifyImportService } from "../services/spotifyImport";
backend/src/routes/spotify.ts:6:import { deezerService } from "../services/deezer";
backend/src/routes/spotify.ts:7:import { readSessionLog, getSessionLogPath } from "../utils/playlistLogger";
backend/src/routes/spotify.ts:20:    spotifyPlaylistId: z.string(),
backend/src/routes/spotify.ts:22:    playlistName: z.string().min(1).max(200),
backend/src/routes/spotify.ts:23:    albumMbidsToDownload: z.array(z.string()),
backend/src/routes/spotify.ts:27: * POST /api/spotify/parse
backend/src/routes/spotify.ts:28: * Parse a Spotify URL and return basic info
backend/src/routes/spotify.ts:34:        const parsed = spotifyService.parseUrl(url);
backend/src/routes/spotify.ts:37:                error: "Invalid Spotify URL. Please provide a valid playlist URL.",
backend/src/routes/spotify.ts:41:        // For now, only support playlists
backend/src/routes/spotify.ts:42:        if (parsed.type !== "playlist") {
backend/src/routes/spotify.ts:44:                error: `Only playlist imports are supported. Got: ${parsed.type}`,
backend/src/routes/spotify.ts:51:            url: `https://open.spotify.com/playlist/${parsed.id}`,
backend/src/routes/spotify.ts:54:        console.error("Spotify parse error:", error);
backend/src/routes/spotify.ts:63: * POST /api/spotify/preview
backend/src/routes/spotify.ts:64: * Generate a preview of what will be imported from a Spotify or Deezer playlist
backend/src/routes/spotify.ts:70:        console.log(`[Playlist Import] Generating preview for: ${url}`);
backend/src/routes/spotify.ts:72:        // Detect if it's a Deezer URL
backend/src/routes/spotify.ts:73:        if (url.includes("deezer.com")) {
backend/src/routes/spotify.ts:74:            // Extract playlist ID from Deezer URL
backend/src/routes/spotify.ts:75:            const deezerMatch = url.match(/playlist[\/:](\d+)/);
backend/src/routes/spotify.ts:76:            if (!deezerMatch) {
backend/src/routes/spotify.ts:79:                    .json({ error: "Invalid Deezer playlist URL" });
backend/src/routes/spotify.ts:82:            const playlistId = deezerMatch[1];
backend/src/routes/spotify.ts:83:            const deezerPlaylist = await deezerService.getPlaylist(playlistId);
backend/src/routes/spotify.ts:85:            if (!deezerPlaylist) {
backend/src/routes/spotify.ts:88:                    .json({ error: "Deezer playlist not found" });
backend/src/routes/spotify.ts:91:            // Convert Deezer format to Spotify Import format
backend/src/routes/spotify.ts:93:                await spotifyImportService.generatePreviewFromDeezer(
backend/src/routes/spotify.ts:94:                    deezerPlaylist
backend/src/routes/spotify.ts:98:                `[Playlist Import] Deezer preview generated: ${preview.summary.total} tracks, ${preview.summary.inLibrary} in library`
backend/src/routes/spotify.ts:102:            // Handle Spotify URL
backend/src/routes/spotify.ts:103:            const preview = await spotifyImportService.generatePreview(url);
backend/src/routes/spotify.ts:106:                `[Spotify Import] Preview generated: ${preview.summary.total} tracks, ${preview.summary.inLibrary} in library`
backend/src/routes/spotify.ts:111:        console.error("Playlist preview error:", error);
backend/src/routes/spotify.ts:122: * POST /api/spotify/import
backend/src/routes/spotify.ts:123: * Start importing a Spotify playlist
backend/src/routes/spotify.ts:127:        const { spotifyPlaylistId, url, playlistName, albumMbidsToDownload } =
backend/src/routes/spotify.ts:134:            `https://open.spotify.com/playlist/${spotifyPlaylistId}`;
backend/src/routes/spotify.ts:137:        if (effectiveUrl.includes("deezer.com")) {
backend/src/routes/spotify.ts:138:            const deezerMatch = effectiveUrl.match(/playlist[\/:](\d+)/);
backend/src/routes/spotify.ts:139:            if (!deezerMatch) {
backend/src/routes/spotify.ts:142:                    .json({ error: "Invalid Deezer playlist URL" });
backend/src/routes/spotify.ts:144:            const playlistId = deezerMatch[1];
backend/src/routes/spotify.ts:145:            const deezerPlaylist = await deezerService.getPlaylist(playlistId);
backend/src/routes/spotify.ts:146:            if (!deezerPlaylist) {
backend/src/routes/spotify.ts:149:                    .json({ error: "Deezer playlist not found" });
backend/src/routes/spotify.ts:151:            preview = await spotifyImportService.generatePreviewFromDeezer(
backend/src/routes/spotify.ts:152:                deezerPlaylist
backend/src/routes/spotify.ts:155:            preview = await spotifyImportService.generatePreview(effectiveUrl);
backend/src/routes/spotify.ts:159:            `[Spotify Import] Starting import for user ${userId}: ${playlistName}`
backend/src/routes/spotify.ts:162:            `[Spotify Import] Downloading ${albumMbidsToDownload.length} albums`
backend/src/routes/spotify.ts:165:        const job = await spotifyImportService.startImport(
backend/src/routes/spotify.ts:167:            spotifyPlaylistId,
backend/src/routes/spotify.ts:168:            playlistName,
backend/src/routes/spotify.ts:169:            albumMbidsToDownload,
backend/src/routes/spotify.ts:179:        console.error("Spotify import error:", error);
backend/src/routes/spotify.ts:190: * GET /api/spotify/import/:jobId/status
backend/src/routes/spotify.ts:198:        const job = await spotifyImportService.getJob(jobId);
backend/src/routes/spotify.ts:212:        console.error("Spotify job status error:", error);
backend/src/routes/spotify.ts:220: * GET /api/spotify/imports
backend/src/routes/spotify.ts:226:        const jobs = await spotifyImportService.getUserJobs(userId);
backend/src/routes/spotify.ts:229:        console.error("Spotify imports error:", error);
backend/src/routes/spotify.ts:237: * POST /api/spotify/import/:jobId/refresh
backend/src/routes/spotify.ts:238: * Re-match pending tracks and add newly downloaded ones to the playlist
backend/src/routes/spotify.ts:245:        const job = await spotifyImportService.getJob(jobId);
backend/src/routes/spotify.ts:257:        const result = await spotifyImportService.refreshJobMatches(jobId);
backend/src/routes/spotify.ts:262:                    ? `Added ${result.added} newly downloaded track(s)`
backend/src/routes/spotify.ts:263:                    : "No new tracks found yet. Albums may still be downloading.",
backend/src/routes/spotify.ts:268:        console.error("Spotify refresh error:", error);
backend/src/routes/spotify.ts:276: * POST /api/spotify/import/:jobId/cancel
backend/src/routes/spotify.ts:277: * Cancel an import job and create playlist with whatever succeeded
backend/src/routes/spotify.ts:284:        const job = await spotifyImportService.getJob(jobId);
backend/src/routes/spotify.ts:296:        const result = await spotifyImportService.cancelJob(jobId);
backend/src/routes/spotify.ts:299:            message: result.playlistCreated
backend/src/routes/spotify.ts:300:                ? `Import cancelled. Playlist created with ${result.tracksMatched} track(s).`
backend/src/routes/spotify.ts:301:                : "Import cancelled. No tracks were downloaded.",
backend/src/routes/spotify.ts:302:            playlistId: result.playlistId,
backend/src/routes/spotify.ts:306:        console.error("Spotify cancel error:", error);
backend/src/routes/spotify.ts:314: * GET /api/spotify/import/session-log
backend/src/routes/mixes.ts:3:import { programmaticPlaylistService } from "../services/programmaticPlaylists";
backend/src/routes/mixes.ts:87:        const mixes = await programmaticPlaylistService.generateAllMixes(
backend/src/routes/mixes.ts:217:        const mix = await programmaticPlaylistService.generateMoodOnDemand(
backend/src/routes/mixes.ts:714:        const mixes = await programmaticPlaylistService.generateAllMixes(
backend/src/routes/mixes.ts:733: *     summary: Save a mix as a playlist
backend/src/routes/mixes.ts:734: *     description: Creates a new playlist with all tracks from the specified mix
backend/src/routes/mixes.ts:745: *         description: Mix ID to save as playlist
backend/src/routes/mixes.ts:755: *                 description: Optional custom name for the playlist (defaults to mix name)
backend/src/routes/mixes.ts:758: *         description: Playlist created successfully
backend/src/routes/mixes.ts:800:            mixes = await programmaticPlaylistService.generateAllMixes(userId);
backend/src/routes/mixes.ts:810:        const existingPlaylist = await prisma.playlist.findFirst({
backend/src/routes/mixes.ts:821:        if (existingPlaylist) {
backend/src/routes/mixes.ts:823:                error: "Mix already saved as playlist",
backend/src/routes/mixes.ts:824:                playlistId: existingPlaylist.id,
backend/src/routes/mixes.ts:825:                name: existingPlaylist.name,
backend/src/routes/mixes.ts:829:        // Create playlist
backend/src/routes/mixes.ts:830:        const playlist = await prisma.playlist.create({
backend/src/routes/mixes.ts:839:        // Add all tracks to the playlist
backend/src/routes/mixes.ts:840:        const playlistItems = mix.trackIds.map(
backend/src/routes/mixes.ts:842:                playlistId: playlist.id,
backend/src/routes/mixes.ts:848:        await prisma.playlistItem.createMany({
backend/src/routes/mixes.ts:849:            data: playlistItems,
backend/src/routes/mixes.ts:853:            `[MIXES] Saved mix ${mixId} as playlist ${playlist.id} (${mix.trackIds.length} tracks)`
backend/src/routes/mixes.ts:857:            id: playlist.id,
backend/src/routes/mixes.ts:858:            name: playlist.name,
backend/src/routes/mixes.ts:862:        console.error("Save mix as playlist error:", error);
backend/src/routes/mixes.ts:863:        res.status(500).json({ error: "Failed to save mix as playlist" });
backend/src/routes/mixes.ts:942:            mixes = await programmaticPlaylistService.generateAllMixes(userId);
backend/src/services/notificationService.ts:7:    | "download_complete"
backend/src/services/notificationService.ts:8:    | "download_failed"
backend/src/services/notificationService.ts:9:    | "playlist_ready"
backend/src/services/notificationService.ts:137:     * Notify user that a download completed
backend/src/services/notificationService.ts:139:    async notifyDownloadComplete(
backend/src/services/notificationService.ts:147:            type: "download_complete",
backend/src/services/notificationService.ts:148:            title: "Download Complete",
backend/src/services/notificationService.ts:149:            message: `${subject} has been downloaded and added to your library`,
backend/src/services/notificationService.ts:155:     * Notify user that a download failed
backend/src/services/notificationService.ts:157:    async notifyDownloadFailed(
backend/src/services/notificationService.ts:164:            type: "download_failed",
backend/src/services/notificationService.ts:165:            title: "Download Failed",
backend/src/services/notificationService.ts:166:            message: `Failed to download ${subject}${
backend/src/services/notificationService.ts:174:     * Notify user that a playlist is ready
backend/src/services/notificationService.ts:176:    async notifyPlaylistReady(
backend/src/services/notificationService.ts:178:        playlistName: string,
backend/src/services/notificationService.ts:179:        playlistId: string,
backend/src/services/notificationService.ts:184:            type: "playlist_ready",
backend/src/services/notificationService.ts:185:            title: "Playlist Ready",
backend/src/services/notificationService.ts:186:            message: `"${playlistName}" is ready with ${trackCount} tracks`,
backend/src/services/notificationService.ts:187:            metadata: { playlistId, playlistName, trackCount },
backend/src/services/notificationService.ts:192:     * Notify user that a Spotify import completed
backend/src/services/notificationService.ts:196:        playlistName: string,
backend/src/services/notificationService.ts:197:        playlistId: string,
backend/src/services/notificationService.ts:201:        const message = `"${playlistName}" imported with ${matchedTracks} of ${totalTracks} tracks`;
backend/src/services/notificationService.ts:208:            metadata: { playlistId, playlistName, matchedTracks, totalTracks },
backend/src/workers/processors/discoverProcessor.ts:10:    playlistName: string;
backend/src/workers/processors/discoverProcessor.ts:27:        // Note: The discoverWeeklyService.generatePlaylist doesn't have progress callback yet
backend/src/workers/processors/discoverProcessor.ts:32:            `[DiscoverJob ${job.id}] Calling discoverWeeklyService.generatePlaylist...`
backend/src/workers/processors/discoverProcessor.ts:34:        const result = await discoverWeeklyService.generatePlaylist(userId);
backend/src/workers/processors/discoverProcessor.ts:38:            playlistName: result.playlistName,
backend/src/workers/processors/discoverProcessor.ts:64:            playlistName: "",
backend/src/services/spotifyImport.ts:1:import { spotifyService, SpotifyTrack, SpotifyPlaylist } from "./spotify";
backend/src/services/spotifyImport.ts:5:import { deezerService } from "./deezer";
backend/src/services/spotifyImport.ts:7:    createPlaylistLogger,
backend/src/services/spotifyImport.ts:8:    logPlaylistEvent,
backend/src/services/spotifyImport.ts:9:} from "../utils/playlistLogger";
backend/src/services/spotifyImport.ts:15:// Note: We DON'T use simpleDownloadManager here because it has same-artist fallback logic
backend/src/services/spotifyImport.ts:16:// For Spotify Import, we need EXACT album matching - no substitutions
backend/src/services/spotifyImport.ts:19:const jobLoggers = new Map<string, ReturnType<typeof createPlaylistLogger>>();
backend/src/services/spotifyImport.ts:22: * Spotify Import Service
backend/src/services/spotifyImport.ts:24: * Handles matching Spotify tracks to local library and managing imports
backend/src/services/spotifyImport.ts:28:    spotifyTrack: SpotifyTrack;
backend/src/services/spotifyImport.ts:40:export interface AlbumToDownload {
backend/src/services/spotifyImport.ts:41:    spotifyAlbumId: string;
backend/src/services/spotifyImport.ts:48:    tracksNeeded: SpotifyTrack[];
backend/src/services/spotifyImport.ts:52:    playlist: {
backend/src/services/spotifyImport.ts:61:    albumsToDownload: AlbumToDownload[];
backend/src/services/spotifyImport.ts:65:        downloadable: number;
backend/src/services/spotifyImport.ts:73:    spotifyPlaylistId: string;
backend/src/services/spotifyImport.ts:74:    playlistName: string;
backend/src/services/spotifyImport.ts:77:        | "downloading"
backend/src/services/spotifyImport.ts:79:        | "creating_playlist"
backend/src/services/spotifyImport.ts:89:    tracksDownloadable: number; // Tracks from albums being downloaded
backend/src/services/spotifyImport.ts:90:    createdPlaylistId: string | null;
backend/src/services/spotifyImport.ts:94:    // Store the original track list so we can match after downloads
backend/src/services/spotifyImport.ts:112:    await prisma.spotifyImportJob.upsert({
backend/src/services/spotifyImport.ts:117:            spotifyPlaylistId: job.spotifyPlaylistId,
backend/src/services/spotifyImport.ts:118:            playlistName: job.playlistName,
backend/src/services/spotifyImport.ts:125:            tracksDownloadable: job.tracksDownloadable,
backend/src/services/spotifyImport.ts:126:            createdPlaylistId: job.createdPlaylistId,
backend/src/services/spotifyImport.ts:135:            createdPlaylistId: job.createdPlaylistId,
backend/src/services/spotifyImport.ts:177:    const dbJob = await prisma.spotifyImportJob.findUnique({
backend/src/services/spotifyImport.ts:187:        spotifyPlaylistId: dbJob.spotifyPlaylistId,
backend/src/services/spotifyImport.ts:188:        playlistName: dbJob.playlistName,
backend/src/services/spotifyImport.ts:195:        tracksDownloadable: dbJob.tracksDownloadable,
backend/src/services/spotifyImport.ts:196:        createdPlaylistId: dbJob.createdPlaylistId,
backend/src/services/spotifyImport.ts:317:class SpotifyImportService {
backend/src/services/spotifyImport.ts:319:     * Match a Spotify track to the local library
backend/src/services/spotifyImport.ts:322:        spotifyTrack: SpotifyTrack
backend/src/services/spotifyImport.ts:324:        const normalizedTitle = normalizeString(spotifyTrack.title);
backend/src/services/spotifyImport.ts:325:        const normalizedArtist = normalizeString(spotifyTrack.artist);
backend/src/services/spotifyImport.ts:326:        const normalizedAlbum = normalizeString(spotifyTrack.album);
backend/src/services/spotifyImport.ts:337:                        equals: spotifyTrack.album,
backend/src/services/spotifyImport.ts:342:                    equals: spotifyTrack.title,
backend/src/services/spotifyImport.ts:356:                spotifyTrack,
backend/src/services/spotifyImport.ts:396:                normalizeTrackTitle(spotifyTrack.title),
backend/src/services/spotifyImport.ts:400:                spotifyTrack.artist,
backend/src/services/spotifyImport.ts:415:                spotifyTrack,
backend/src/services/spotifyImport.ts:429:            spotifyTrack,
backend/src/services/spotifyImport.ts:437:     * Look up album info from MusicBrainz for downloading
backend/src/services/spotifyImport.ts:488:        tracks: SpotifyTrack[],
backend/src/services/spotifyImport.ts:489:        playlistMeta: {
backend/src/services/spotifyImport.ts:497:        source: "Spotify" | "Deezer"
backend/src/services/spotifyImport.ts:500:            source === "Spotify" ? "[Spotify Import]" : "[Deezer Import]";
backend/src/services/spotifyImport.ts:503:        const unmatchedByAlbum = new Map<string, SpotifyTrack[]>();
backend/src/services/spotifyImport.ts:517:        const albumsToDownload: AlbumToDownload[] = [];
backend/src/services/spotifyImport.ts:604:                        `${logPrefix} ℹ But can still download via Soulseek (track-based search)`
backend/src/services/spotifyImport.ts:609:            const albumToDownload: AlbumToDownload = {
backend/src/services/spotifyImport.ts:610:                spotifyAlbumId: albumTracks[0].albumId,
backend/src/services/spotifyImport.ts:620:            console.log(`${logPrefix} Download strategy:`);
backend/src/services/spotifyImport.ts:645:            albumsToDownload.push(albumToDownload);
backend/src/services/spotifyImport.ts:652:        // All albums are now downloadable via Soulseek (either album-based with MBID or track-based without)
backend/src/services/spotifyImport.ts:653:        const downloadableAlbums = albumsToDownload;
backend/src/services/spotifyImport.ts:656:        const notFoundAlbums: AlbumToDownload[] = [];
backend/src/services/spotifyImport.ts:658:        const downloadable = downloadableAlbums.reduce(
backend/src/services/spotifyImport.ts:668:            playlist: playlistMeta,
backend/src/services/spotifyImport.ts:670:            albumsToDownload,
backend/src/services/spotifyImport.ts:672:                total: playlistMeta.trackCount,
backend/src/services/spotifyImport.ts:674:                downloadable,
backend/src/services/spotifyImport.ts:683:    async generatePreview(spotifyUrl: string): Promise<ImportPreview> {
backend/src/services/spotifyImport.ts:688:        const playlist = await spotifyService.getPlaylist(spotifyUrl);
backend/src/services/spotifyImport.ts:689:        if (!playlist) {
backend/src/services/spotifyImport.ts:691:                "Could not fetch playlist from Spotify. Make sure it's a valid public playlist URL."
backend/src/services/spotifyImport.ts:696:            playlist.tracks,
backend/src/services/spotifyImport.ts:698:                id: playlist.id,
backend/src/services/spotifyImport.ts:699:                name: playlist.name,
backend/src/services/spotifyImport.ts:700:                description: playlist.description,
backend/src/services/spotifyImport.ts:701:                owner: playlist.owner,
backend/src/services/spotifyImport.ts:702:                imageUrl: playlist.imageUrl,
backend/src/services/spotifyImport.ts:703:                trackCount: playlist.trackCount,
backend/src/services/spotifyImport.ts:705:            "Spotify"
backend/src/services/spotifyImport.ts:710:     * Generate a preview from a Deezer playlist
backend/src/services/spotifyImport.ts:711:     * Converts Deezer tracks to Spotify format and processes them
backend/src/services/spotifyImport.ts:713:    async generatePreviewFromDeezer(
backend/src/services/spotifyImport.ts:714:        deezerPlaylist: any
backend/src/services/spotifyImport.ts:720:            "[Deezer Debug] Sample track from Deezer:",
backend/src/services/spotifyImport.ts:721:            JSON.stringify(deezerPlaylist.tracks[0], null, 2)
backend/src/services/spotifyImport.ts:724:        const spotifyTracks: SpotifyTrack[] = deezerPlaylist.tracks.map(
backend/src/services/spotifyImport.ts:726:                spotifyId: track.deezerId,
backend/src/services/spotifyImport.ts:736:                coverUrl: track.coverUrl || deezerPlaylist.imageUrl || null,
backend/src/services/spotifyImport.ts:741:            "[Deezer Debug] Sample converted track:",
backend/src/services/spotifyImport.ts:742:            JSON.stringify(spotifyTracks[0], null, 2)
backend/src/services/spotifyImport.ts:746:            spotifyTracks,
backend/src/services/spotifyImport.ts:748:                id: deezerPlaylist.id,
backend/src/services/spotifyImport.ts:749:                name: deezerPlaylist.title,
backend/src/services/spotifyImport.ts:750:                description: deezerPlaylist.description || null,
backend/src/services/spotifyImport.ts:751:                owner: deezerPlaylist.creator || "Deezer",
backend/src/services/spotifyImport.ts:752:                imageUrl: deezerPlaylist.imageUrl || null,
backend/src/services/spotifyImport.ts:753:                trackCount: deezerPlaylist.trackCount || spotifyTracks.length,
backend/src/services/spotifyImport.ts:755:            "Deezer"
backend/src/services/spotifyImport.ts:764:        spotifyPlaylistId: string,
backend/src/services/spotifyImport.ts:765:        playlistName: string,
backend/src/services/spotifyImport.ts:766:        albumMbidsToDownload: string[],
backend/src/services/spotifyImport.ts:774:        const logger = createPlaylistLogger(jobId);
backend/src/services/spotifyImport.ts:777:        logger.logJobStart(playlistName, preview.summary.total, userId);
backend/src/services/spotifyImport.ts:778:        logger.info(`Playlist ID: ${spotifyPlaylistId}`);
backend/src/services/spotifyImport.ts:779:        logger.info(`Albums to download: ${albumMbidsToDownload.length}`);
backend/src/services/spotifyImport.ts:782:        // Calculate tracks that will come from downloads
backend/src/services/spotifyImport.ts:783:        const tracksFromDownloads = preview.albumsToDownload
backend/src/services/spotifyImport.ts:784:            .filter((a) => albumMbidsToDownload.includes(a.albumMbid!))
backend/src/services/spotifyImport.ts:787:        // Extract the track info we need to match after downloads
backend/src/services/spotifyImport.ts:790:        // NOTE: `PlaylistPendingTrack.spotifyAlbum` should reflect Spotify's album name.
backend/src/services/spotifyImport.ts:791:        // Only fall back to a resolved album name when Spotify returns "Unknown Album".
backend/src/services/spotifyImport.ts:793:            const spotifyAlbum = m.spotifyTrack.album;
backend/src/services/spotifyImport.ts:794:            const spotifyAlbumId = m.spotifyTrack.albumId;
backend/src/services/spotifyImport.ts:796:            const albumToDownload = spotifyAlbumId
backend/src/services/spotifyImport.ts:797:                ? preview.albumsToDownload.find(
backend/src/services/spotifyImport.ts:798:                      (a) => a.spotifyAlbumId === spotifyAlbumId
backend/src/services/spotifyImport.ts:803:                spotifyAlbum && spotifyAlbum !== "Unknown Album"
backend/src/services/spotifyImport.ts:804:                    ? spotifyAlbum
backend/src/services/spotifyImport.ts:805:                    : albumToDownload?.albumName || spotifyAlbum;
backend/src/services/spotifyImport.ts:808:                artist: m.spotifyTrack.artist,
backend/src/services/spotifyImport.ts:809:                title: m.spotifyTrack.title,
backend/src/services/spotifyImport.ts:818:            spotifyPlaylistId,
backend/src/services/spotifyImport.ts:819:            playlistName,
backend/src/services/spotifyImport.ts:822:            albumsTotal: albumMbidsToDownload.length,
backend/src/services/spotifyImport.ts:826:            tracksDownloadable: tracksFromDownloads,
backend/src/services/spotifyImport.ts:827:            createdPlaylistId: null,
backend/src/services/spotifyImport.ts:838:        this.processImport(job, albumMbidsToDownload, preview).catch(
backend/src/services/spotifyImport.ts:852:     * Process the import (download albums, create playlist)
backend/src/services/spotifyImport.ts:853:     * Uses simpleDownloadManager for proper webhook tracking and Lidarr release iteration
backend/src/services/spotifyImport.ts:857:        albumMbidsToDownload: string[],
backend/src/services/spotifyImport.ts:862:        // Import simpleDownloadManager here to avoid circular deps
backend/src/services/spotifyImport.ts:863:        const { simpleDownloadManager } = await import(
backend/src/services/spotifyImport.ts:864:            "./simpleDownloadManager"
backend/src/services/spotifyImport.ts:868:            // Phase 1: Download albums based on user's download preferences
backend/src/services/spotifyImport.ts:869:            if (albumMbidsToDownload.length > 0) {
backend/src/services/spotifyImport.ts:870:                job.status = "downloading";
backend/src/services/spotifyImport.ts:874:                logger?.logAlbumDownloadStart(albumMbidsToDownload.length);
backend/src/services/spotifyImport.ts:876:                // Playlist imports always use Soulseek for per-track downloads
backend/src/services/spotifyImport.ts:877:                // (ignores global downloadSource setting - that's for album browsing/discovery)
backend/src/services/spotifyImport.ts:879:                const downloadSource = "soulseek"; // Always Soulseek for playlist imports
backend/src/services/spotifyImport.ts:883:                    `[Spotify Import] Using Soulseek for per-track downloads (fallback: ${soulseekFallback})`
backend/src/services/spotifyImport.ts:886:                    `Download source: Soulseek (per-track), fallback: ${soulseekFallback}`
backend/src/services/spotifyImport.ts:905:                            `[Spotify Import] Soulseek not available, using Lidarr as fallback`
backend/src/services/spotifyImport.ts:908:                            `Soulseek not available, using Lidarr for downloads`
backend/src/services/spotifyImport.ts:912:                            "Soulseek is not available. Cannot download missing tracks."
backend/src/services/spotifyImport.ts:918:                const albumConcurrency = downloadSource === "soulseek" ? 4 : 2;
backend/src/services/spotifyImport.ts:924:                    `[Spotify Import] Processing ${albumMbidsToDownload.length} albums with concurrency ${albumConcurrency}`
backend/src/services/spotifyImport.ts:927:                    `Processing ${albumMbidsToDownload.length} albums in parallel (concurrency: ${albumConcurrency})`
backend/src/services/spotifyImport.ts:930:                const albumPromises = albumMbidsToDownload.map(
backend/src/services/spotifyImport.ts:933:                            // albumIdentifier can be either albumMbid or spotifyAlbumId (for Unknown Album)
backend/src/services/spotifyImport.ts:934:                            const album = preview.albumsToDownload.find(
backend/src/services/spotifyImport.ts:937:                                    a.spotifyAlbumId === albumIdentifier
backend/src/services/spotifyImport.ts:942:                                // Create a DownloadJob record for tracking
backend/src/services/spotifyImport.ts:943:                                const downloadJobId = `spotify_${job.id}_${albumIdentifier}`;
backend/src/services/spotifyImport.ts:945:                                // For Unknown Album tracks, we only support Soulseek (track-based download)
backend/src/services/spotifyImport.ts:959:                                    }, downloadJobId=${downloadJobId})`
backend/src/services/spotifyImport.ts:964:                                    await prisma.downloadJob.findUnique({
backend/src/services/spotifyImport.ts:965:                                        where: { id: downloadJobId },
backend/src/services/spotifyImport.ts:969:                                    await prisma.downloadJob.create({
backend/src/services/spotifyImport.ts:971:                                            id: downloadJobId,
backend/src/services/spotifyImport.ts:979:                                                spotifyImportJobId: job.id,
backend/src/services/spotifyImport.ts:983:                                                downloadType: "spotify_import",
backend/src/services/spotifyImport.ts:984:                                                downloadSource: downloadSource,
backend/src/services/spotifyImport.ts:987:                                                spotifyAlbumId:
backend/src/services/spotifyImport.ts:988:                                                    album.spotifyAlbumId,
backend/src/services/spotifyImport.ts:995:                                    `[Spotify Import] Requesting: ${album.artistName} - ${album.albumName}`
backend/src/services/spotifyImport.ts:1007:                                let downloadSuccess = false;
backend/src/services/spotifyImport.ts:1009:                                // For Unknown Album, force Soulseek (track-based download)
backend/src/services/spotifyImport.ts:1012:                                        `[Spotify Import] Unknown Album detected - using Soulseek track-based download`
backend/src/services/spotifyImport.ts:1022:                                        await this.trySoulseekDownload(
backend/src/services/spotifyImport.ts:1025:                                            downloadJobId,
backend/src/services/spotifyImport.ts:1030:                                        downloadSuccess = true;
backend/src/services/spotifyImport.ts:1032:                                            `[Spotify Import] ✓ Soulseek completed: ${album.tracksNeeded
backend/src/services/spotifyImport.ts:1043:                                            } downloaded)`
backend/src/services/spotifyImport.ts:1047:                                            `[Spotify Import] ✗ Failed to download Unknown Album tracks: ${soulseekResult.error}`
backend/src/services/spotifyImport.ts:1049:                                        await prisma.downloadJob
backend/src/services/spotifyImport.ts:1051:                                                where: { id: downloadJobId },
backend/src/services/spotifyImport.ts:1056:                                                        "Soulseek download failed",
backend/src/services/spotifyImport.ts:1062:                                } else if (downloadSource === "soulseek") {
backend/src/services/spotifyImport.ts:1063:                                    // === SOULSEEK PRIMARY: Per-track downloads ===
backend/src/services/spotifyImport.ts:1065:                                        `[Spotify Import] Using Soulseek for per-track download`
backend/src/services/spotifyImport.ts:1069:                                        await this.trySoulseekDownload(
backend/src/services/spotifyImport.ts:1072:                                            downloadJobId,
backend/src/services/spotifyImport.ts:1077:                                        downloadSuccess = true;
backend/src/services/spotifyImport.ts:1079:                                            `[Spotify Import] ✓ Soulseek queued: ${album.albumName}`
backend/src/services/spotifyImport.ts:1086:                                            } (tracksDownloaded=${
backend/src/services/spotifyImport.ts:1096:                                            `[Spotify Import] Soulseek failed, trying Lidarr for full album: ${album.albumName}`
backend/src/services/spotifyImport.ts:1103:                                            await simpleDownloadManager.startDownload(
backend/src/services/spotifyImport.ts:1104:                                                downloadJobId,
backend/src/services/spotifyImport.ts:1113:                                            downloadSuccess = true;
backend/src/services/spotifyImport.ts:1115:                                                `[Spotify Import] ✓ Lidarr fallback queued: ${album.albumName}`
backend/src/services/spotifyImport.ts:1135:                                    if (!downloadSuccess) {
backend/src/services/spotifyImport.ts:1138:                                            "No download sources available";
backend/src/services/spotifyImport.ts:1140:                                            `[Spotify Import] ✗ Failed: ${album.albumName} - ${errorMsg}`
backend/src/services/spotifyImport.ts:1148:                                        // Update download job to failed status
backend/src/services/spotifyImport.ts:1149:                                        await prisma.downloadJob
backend/src/services/spotifyImport.ts:1151:                                                where: { id: downloadJobId },
backend/src/services/spotifyImport.ts:1161:                                    // === LIDARR PRIMARY: Full album downloads ===
backend/src/services/spotifyImport.ts:1163:                                        await simpleDownloadManager.startDownload(
backend/src/services/spotifyImport.ts:1164:                                            downloadJobId,
backend/src/services/spotifyImport.ts:1173:                                        downloadSuccess = true;
backend/src/services/spotifyImport.ts:1175:                                            `[Spotify Import] ✓ Queued: ${album.albumName}`
backend/src/services/spotifyImport.ts:1193:                                            await this.trySoulseekDownload(
backend/src/services/spotifyImport.ts:1196:                                                downloadJobId,
backend/src/services/spotifyImport.ts:1201:                                            downloadSuccess = true;
backend/src/services/spotifyImport.ts:1207:                                                } (tracksDownloaded=${
backend/src/services/spotifyImport.ts:1224:                                    if (!downloadSuccess) {
backend/src/services/spotifyImport.ts:1227:                                            "No download sources available";
backend/src/services/spotifyImport.ts:1229:                                            `[Spotify Import] ✗ Failed: ${album.albumName} - ${errorMsg}`
backend/src/services/spotifyImport.ts:1237:                                        // Update download job to failed status
backend/src/services/spotifyImport.ts:1238:                                        await prisma.downloadJob
backend/src/services/spotifyImport.ts:1240:                                                where: { id: downloadJobId },
backend/src/services/spotifyImport.ts:1261:                                    } (queuedOrDownloaded=${
backend/src/services/spotifyImport.ts:1262:                                        downloadSuccess ? "yes" : "no"
backend/src/services/spotifyImport.ts:1267:                                    `[Spotify Import] Failed: ${album.artistName} - ${album.albumName}:`,
backend/src/services/spotifyImport.ts:1276:                                const downloadJobId = `spotify_${job.id}_${
backend/src/services/spotifyImport.ts:1278:                                    album.spotifyAlbumId ||
backend/src/services/spotifyImport.ts:1281:                                await prisma.downloadJob
backend/src/services/spotifyImport.ts:1283:                                        where: { id: downloadJobId },
backend/src/services/spotifyImport.ts:1295:                // Wait for all album downloads to complete
backend/src/services/spotifyImport.ts:1299:                    `Initial queueing phase finished for ${albumMbidsToDownload.length} album(s). Checking completion state...`
backend/src/services/spotifyImport.ts:1305:                // If still downloading, wait for webhooks/organization
backend/src/services/spotifyImport.ts:1306:                if (job.status === "downloading") {
backend/src/services/spotifyImport.ts:1308:                        downloadSource === "soulseek" ? "Soulseek" : "Lidarr";
backend/src/services/spotifyImport.ts:1310:                        `[Spotify Import] Job ${job.id}: Waiting for ${waitingFor} downloads...`
backend/src/services/spotifyImport.ts:1313:                        `Waiting for ${waitingFor} downloads to complete...`
backend/src/services/spotifyImport.ts:1319:            // No downloads needed - all tracks already in library
backend/src/services/spotifyImport.ts:1320:            // Create playlist immediately
backend/src/services/spotifyImport.ts:1321:            await this.buildPlaylist(job);
backend/src/services/spotifyImport.ts:1331:     * Try Soulseek for downloading tracks
backend/src/services/spotifyImport.ts:1333:     * Downloads directly to Singles/Artist/Album/ using soulseek-ts
backend/src/services/spotifyImport.ts:1335:    private async trySoulseekDownload(
backend/src/services/spotifyImport.ts:1337:        album: AlbumToDownload,
backend/src/services/spotifyImport.ts:1338:        downloadJobId: string,
backend/src/services/spotifyImport.ts:1339:        logger: ReturnType<typeof createPlaylistLogger> | undefined
backend/src/services/spotifyImport.ts:1345:                `[Spotify Import] Soulseek not available, skipping fallback`
backend/src/services/spotifyImport.ts:1351:            `[Spotify Import] Trying Soulseek for: ${album.artistName} - ${album.albumName}`
backend/src/services/spotifyImport.ts:1354:            `[Spotify Import] Searching for ${album.tracksNeeded.length} individual track(s)`
backend/src/services/spotifyImport.ts:1358:        // Get music path for direct download
backend/src/services/spotifyImport.ts:1366:            // Prepare track list for batch download - normalize titles for better search results
backend/src/services/spotifyImport.ts:1375:                `[Spotify Import] Soulseek: Searching for ${tracks.length} track(s):`
backend/src/services/spotifyImport.ts:1390:            // Use parallel batch download (4 concurrent by default)
backend/src/services/spotifyImport.ts:1391:            const result = await soulseekService.searchAndDownloadBatch(
backend/src/services/spotifyImport.ts:1398:                console.log(`[Spotify Import] Soulseek: No tracks downloaded`);
backend/src/services/spotifyImport.ts:1403:            // Calculate total size of downloaded files
backend/src/services/spotifyImport.ts:1415:                `[Spotify Import] ✓ Soulseek: Downloaded ${result.successful}/${
backend/src/services/spotifyImport.ts:1426:            logger?.logSlskdDownloadQueued(result.successful, "direct");
backend/src/services/spotifyImport.ts:1428:            // Mark download job as completed immediately - files are already in place!
backend/src/services/spotifyImport.ts:1429:            await prisma.downloadJob
backend/src/services/spotifyImport.ts:1431:                    where: { id: downloadJobId },
backend/src/services/spotifyImport.ts:1437:                            spotifyImportJobId: job.id,
backend/src/services/spotifyImport.ts:1440:                            downloadType: "spotify_import",
backend/src/services/spotifyImport.ts:1442:                            tracksDownloaded: result.successful,
backend/src/services/spotifyImport.ts:1452:            console.error(`[Spotify Import] Soulseek error:`, error.message);
backend/src/services/spotifyImport.ts:1463:     * Check if all downloads for this import are complete (called by webhook handler)
backend/src/services/spotifyImport.ts:1467:            `\n[Spotify Import] Checking completion for job ${importJobId}...`
backend/src/services/spotifyImport.ts:1478:        // Check download jobs for this import
backend/src/services/spotifyImport.ts:1479:        const downloadJobs = await prisma.downloadJob.findMany({
backend/src/services/spotifyImport.ts:1481:                id: { startsWith: `spotify_${importJobId}_` },
backend/src/services/spotifyImport.ts:1485:        const total = downloadJobs.length;
backend/src/services/spotifyImport.ts:1486:        const completed = downloadJobs.filter(
backend/src/services/spotifyImport.ts:1489:        const failed = downloadJobs.filter((j) => j.status === "failed").length;
backend/src/services/spotifyImport.ts:1494:                "No download jobs were created for this import. This usually means the import preview did not include the selected albums.";
backend/src/services/spotifyImport.ts:1506:            `   Download status: ${completed}/${total} completed, ${failed} failed, ${pending} pending`
backend/src/services/spotifyImport.ts:1508:        logger?.logDownloadProgress(completed, failed, pending);
backend/src/services/spotifyImport.ts:1513:                ? 30 + Math.round((completed / total) * 40) // 30-70% for downloads
backend/src/services/spotifyImport.ts:1518:            // Check how long we've been waiting for these downloads
backend/src/services/spotifyImport.ts:1519:            const oldestPending = downloadJobs
backend/src/services/spotifyImport.ts:1536:                    `   Still waiting for ${pending} downloads... (${waitTimeMins} min elapsed)`
backend/src/services/spotifyImport.ts:1538:                logger?.info(`Waiting for Soulseek downloads to complete...`);
backend/src/services/spotifyImport.ts:1544:                `   Timeout: ${pending} downloads still pending after ${waitTimeMins} minutes, proceeding anyway`
backend/src/services/spotifyImport.ts:1547:                `Download timeout: ${pending} pending after ${waitTimeMins}m, proceeding with available tracks`
backend/src/services/spotifyImport.ts:1551:            await prisma.downloadJob.updateMany({
backend/src/services/spotifyImport.ts:1553:                    id: { startsWith: `spotify_${importJobId}_` },
backend/src/services/spotifyImport.ts:1558:                    error: "Timed out waiting for download",
backend/src/services/spotifyImport.ts:1564:        // All downloads finished (completed or failed)
backend/src/services/spotifyImport.ts:1565:        console.log(`   All downloads finished! Triggering library scan...`);
backend/src/services/spotifyImport.ts:1567:            `All ${total} download jobs finished (${completed} completed, ${failed} failed)`
backend/src/services/spotifyImport.ts:1570:        // Trigger library scan to import the new files from soulseek-downloads
backend/src/services/spotifyImport.ts:1574:            musicPath: "/soulseek-downloads", // Soulseek downloads go here (main library is read-only)
backend/src/services/spotifyImport.ts:1575:            source: "spotify-import",
backend/src/services/spotifyImport.ts:1576:            spotifyImportJobId: importJobId,
backend/src/services/spotifyImport.ts:1590:     * Build playlist after library scan completes (called by scan worker)
backend/src/services/spotifyImport.ts:1592:    async buildPlaylistAfterScan(importJobId: string): Promise<void> {
backend/src/services/spotifyImport.ts:1594:            `\n[Spotify Import] Building playlist for job ${importJobId}...`
backend/src/services/spotifyImport.ts:1603:        await this.buildPlaylist(job);
backend/src/services/spotifyImport.ts:1607:     * Internal: Build the playlist with matched tracks
backend/src/services/spotifyImport.ts:1609:    private async buildPlaylist(job: ImportJob): Promise<void> {
backend/src/services/spotifyImport.ts:1612:        job.status = "creating_playlist";
backend/src/services/spotifyImport.ts:1617:        logger?.logPlaylistCreationStart();
backend/src/services/spotifyImport.ts:1628:            // This ensures tracks found during preview are included in the final playlist
backend/src/services/spotifyImport.ts:1715:            // e.g., database has "Ain't" but Spotify has "Ain't" (different apostrophe after normalization still differs)
backend/src/services/spotifyImport.ts:1766:                    const spotifyNorm = cleanedTitle.toLowerCase();
backend/src/services/spotifyImport.ts:1769:                        libraryNorm.startsWith(spotifyNorm) ||
backend/src/services/spotifyImport.ts:1770:                        spotifyNorm.startsWith(libraryNorm)
backend/src/services/spotifyImport.ts:2029:                `   Removed ${removed} duplicate track references before playlist creation`
backend/src/services/spotifyImport.ts:2032:                `Removed ${removed} duplicate track references before playlist creation`
backend/src/services/spotifyImport.ts:2042:        // Create the playlist with Spotify metadata
backend/src/services/spotifyImport.ts:2043:        const playlist = await prisma.playlist.create({
backend/src/services/spotifyImport.ts:2046:                name: job.playlistName,
backend/src/services/spotifyImport.ts:2048:                spotifyPlaylistId: job.spotifyPlaylistId,
backend/src/services/spotifyImport.ts:2068:        // Recalculate unmatched - tracks that weren't added to playlist
backend/src/services/spotifyImport.ts:2118:                `   Fetching Deezer preview URLs for pending tracks...`
backend/src/services/spotifyImport.ts:2124:            // Fetch Deezer previews in parallel for all pending tracks
backend/src/services/spotifyImport.ts:2127:                    let deezerPreviewUrl: string | null = null;
backend/src/services/spotifyImport.ts:2129:                        deezerPreviewUrl = await deezerService.getTrackPreview(
backend/src/services/spotifyImport.ts:2138:                        deezerPreviewUrl,
backend/src/services/spotifyImport.ts:2144:                (t) => t.deezerPreviewUrl
backend/src/services/spotifyImport.ts:2147:                `   Found ${previewsFound}/${pendingTracksToSave.length} Deezer preview URLs`
backend/src/services/spotifyImport.ts:2153:            await prisma.playlistPendingTrack.createMany({
backend/src/services/spotifyImport.ts:2155:                    playlistId: playlist.id,
backend/src/services/spotifyImport.ts:2156:                    spotifyArtist: track.artist,
backend/src/services/spotifyImport.ts:2157:                    spotifyTitle: track.title,
backend/src/services/spotifyImport.ts:2158:                    spotifyAlbum: track.album,
backend/src/services/spotifyImport.ts:2159:                    deezerPreviewUrl: track.deezerPreviewUrl,
backend/src/services/spotifyImport.ts:2166:        job.createdPlaylistId = playlist.id;
backend/src/services/spotifyImport.ts:2173:        console.log(`[Spotify Import] Job ${job.id} completed:`);
backend/src/services/spotifyImport.ts:2174:        console.log(`   Playlist created: ${playlist.id}`);
backend/src/services/spotifyImport.ts:2179:        logger?.logPlaylistCreated(
backend/src/services/spotifyImport.ts:2180:            playlist.id,
backend/src/services/spotifyImport.ts:2187:            playlist.id
backend/src/services/spotifyImport.ts:2194:                job.playlistName,
backend/src/services/spotifyImport.ts:2195:                playlist.id,
backend/src/services/spotifyImport.ts:2205:     * Re-match pending tracks and add newly downloaded ones to the playlist
backend/src/services/spotifyImport.ts:2215:        if (!job.createdPlaylistId) {
backend/src/services/spotifyImport.ts:2216:            throw new Error("No playlist created for this job");
backend/src/services/spotifyImport.ts:2221:        // Get existing tracks in playlist
backend/src/services/spotifyImport.ts:2222:        const existingItems = await prisma.playlistItem.findMany({
backend/src/services/spotifyImport.ts:2223:            where: { playlistId: job.createdPlaylistId },
backend/src/services/spotifyImport.ts:2231:        const maxSortResult = await prisma.playlistItem.aggregate({
backend/src/services/spotifyImport.ts:2232:            where: { playlistId: job.createdPlaylistId },
backend/src/services/spotifyImport.ts:2257:                // Add to playlist
backend/src/services/spotifyImport.ts:2258:                await prisma.playlistItem.create({
backend/src/services/spotifyImport.ts:2260:                        playlistId: job.createdPlaylistId,
backend/src/services/spotifyImport.ts:2274:            `[Spotify Import] Refresh job ${jobId}: added ${added} newly downloaded tracks`
backend/src/services/spotifyImport.ts:2277:            `Refresh: added ${added} newly downloaded track(s), totalMatchedNow=${job.tracksMatched}`
backend/src/services/spotifyImport.ts:2295:        const dbJobs = await prisma.spotifyImportJob.findMany({
backend/src/services/spotifyImport.ts:2304:                spotifyPlaylistId: dbJob.spotifyPlaylistId,
backend/src/services/spotifyImport.ts:2305:                playlistName: dbJob.playlistName,
backend/src/services/spotifyImport.ts:2312:                tracksDownloadable: dbJob.tracksDownloadable,
backend/src/services/spotifyImport.ts:2313:                createdPlaylistId: dbJob.createdPlaylistId,
backend/src/services/spotifyImport.ts:2323:     * Cancel an import job without creating a playlist.
backend/src/services/spotifyImport.ts:2324:     * All pending downloads are marked as failed and the job is marked as cancelled.
backend/src/services/spotifyImport.ts:2327:        playlistCreated: boolean;
backend/src/services/spotifyImport.ts:2328:        playlistId: string | null;
backend/src/services/spotifyImport.ts:2337:        console.log(`[Spotify Import] Cancelling job ${jobId}...`);
backend/src/services/spotifyImport.ts:2347:                playlistCreated: !!job.createdPlaylistId,
backend/src/services/spotifyImport.ts:2348:                playlistId: job.createdPlaylistId || null,
backend/src/services/spotifyImport.ts:2353:        // Mark any pending download jobs as cancelled
backend/src/services/spotifyImport.ts:2354:        await prisma.downloadJob.updateMany({
backend/src/services/spotifyImport.ts:2356:                id: { startsWith: `spotify_${jobId}_` },
backend/src/services/spotifyImport.ts:2366:        // Mark job as cancelled - do NOT create a playlist
backend/src/services/spotifyImport.ts:2369:        logger?.info(`Import cancelled by user - no playlist created`);
backend/src/services/spotifyImport.ts:2372:            playlistCreated: false,
backend/src/services/spotifyImport.ts:2373:            playlistId: null,
backend/src/services/spotifyImport.ts:2379:     * Reconcile pending tracks for ALL playlists after a library scan
backend/src/services/spotifyImport.ts:2381:     * and automatically adds them to their playlists
backend/src/services/spotifyImport.ts:2384:        playlistsUpdated: number;
backend/src/services/spotifyImport.ts:2388:            `\n[Spotify Import] Reconciling pending tracks across all playlists...`
backend/src/services/spotifyImport.ts:2391:        // Get all pending tracks grouped by playlist
backend/src/services/spotifyImport.ts:2392:        const allPendingTracks = await prisma.playlistPendingTrack.findMany({
backend/src/services/spotifyImport.ts:2394:                playlist: {
backend/src/services/spotifyImport.ts:2402:            orderBy: [{ playlistId: "asc" }, { sort: "asc" }],
backend/src/services/spotifyImport.ts:2407:            return { playlistsUpdated: 0, tracksAdded: 0 };
backend/src/services/spotifyImport.ts:2411:            `   Found ${allPendingTracks.length} pending tracks across playlists`
backend/src/services/spotifyImport.ts:2415:        const playlistsWithAdditions = new Set<string>();
backend/src/services/spotifyImport.ts:2418:        // Group by playlist for efficient processing
backend/src/services/spotifyImport.ts:2419:        const tracksByPlaylist = new Map<string, typeof allPendingTracks>();
backend/src/services/spotifyImport.ts:2421:            const existing = tracksByPlaylist.get(pt.playlistId) || [];
backend/src/services/spotifyImport.ts:2423:            tracksByPlaylist.set(pt.playlistId, existing);
backend/src/services/spotifyImport.ts:2426:        for (const [playlistId, pendingTracks] of tracksByPlaylist) {
backend/src/services/spotifyImport.ts:2427:            // Get current max sort position in playlist
backend/src/services/spotifyImport.ts:2428:            const maxSortResult = await prisma.playlistItem.aggregate({
backend/src/services/spotifyImport.ts:2429:                where: { playlistId },
backend/src/services/spotifyImport.ts:2434:            // Get existing track IDs in playlist to avoid duplicates
backend/src/services/spotifyImport.ts:2435:            const existingItems = await prisma.playlistItem.findMany({
backend/src/services/spotifyImport.ts:2436:                where: { playlistId },
backend/src/services/spotifyImport.ts:2445:                    pendingTrack.spotifyArtist
backend/src/services/spotifyImport.ts:2449:                    pendingTrack.spotifyTitle
backend/src/services/spotifyImport.ts:2454:                    `   Trying to match: "${pendingTrack.spotifyTitle}" by ${pendingTrack.spotifyArtist}`
backend/src/services/spotifyImport.ts:2504:                // Try to find a matching track (using same strategies as buildPlaylist)
backend/src/services/spotifyImport.ts:2582:                        const spotifyNorm = cleanedTitle.toLowerCase();
backend/src/services/spotifyImport.ts:2585:                            libraryNorm.startsWith(spotifyNorm) ||
backend/src/services/spotifyImport.ts:2586:                            spotifyNorm.startsWith(libraryNorm)
backend/src/services/spotifyImport.ts:2634:                            pendingTrack.spotifyArtist,
backend/src/services/spotifyImport.ts:2660:                    // Add to playlist
backend/src/services/spotifyImport.ts:2661:                    await prisma.playlistItem.create({
backend/src/services/spotifyImport.ts:2663:                            playlistId,
backend/src/services/spotifyImport.ts:2672:                    playlistsWithAdditions.add(playlistId);
backend/src/services/spotifyImport.ts:2675:                        `   ✓ Matched: "${pendingTrack.spotifyTitle}" by ${pendingTrack.spotifyArtist}`
backend/src/services/spotifyImport.ts:2683:            await prisma.playlistPendingTrack.deleteMany({
backend/src/services/spotifyImport.ts:2688:        // Send notifications for each playlist that was updated
backend/src/services/spotifyImport.ts:2689:        if (playlistsWithAdditions.size > 0) {
backend/src/services/spotifyImport.ts:2694:            for (const playlistId of playlistsWithAdditions) {
backend/src/services/spotifyImport.ts:2695:                const playlist = await prisma.playlist.findUnique({
backend/src/services/spotifyImport.ts:2696:                    where: { id: playlistId },
backend/src/services/spotifyImport.ts:2700:                if (playlist) {
backend/src/services/spotifyImport.ts:2701:                    const tracksAddedToPlaylist = matchedPendingTrackIds.filter(
backend/src/services/spotifyImport.ts:2705:                                    pt.id === id && pt.playlistId === playlistId
backend/src/services/spotifyImport.ts:2710:                        userId: playlist.userId,
backend/src/services/spotifyImport.ts:2711:                        type: "playlist_ready",
backend/src/services/spotifyImport.ts:2712:                        title: "Playlist Updated",
backend/src/services/spotifyImport.ts:2713:                        message: `${tracksAddedToPlaylist} new track${
backend/src/services/spotifyImport.ts:2714:                            tracksAddedToPlaylist !== 1 ? "s" : ""
backend/src/services/spotifyImport.ts:2715:                        } added to "${playlist.name}"`,
backend/src/services/spotifyImport.ts:2717:                            playlistId: playlist.id,
backend/src/services/spotifyImport.ts:2718:                            tracksAdded: tracksAddedToPlaylist,
backend/src/services/spotifyImport.ts:2726:            `   Reconciliation complete: ${totalTracksAdded} tracks added to ${playlistsWithAdditions.size} playlists`
backend/src/services/spotifyImport.ts:2730:            playlistsUpdated: playlistsWithAdditions.size,
backend/src/services/spotifyImport.ts:2736:     * Get pending tracks count for a playlist
backend/src/services/spotifyImport.ts:2738:    async getPendingTracksCount(playlistId: string): Promise<number> {
backend/src/services/spotifyImport.ts:2739:        return prisma.playlistPendingTrack.count({
backend/src/services/spotifyImport.ts:2740:            where: { playlistId },
backend/src/services/spotifyImport.ts:2745:     * Get pending tracks for a playlist
backend/src/services/spotifyImport.ts:2747:    async getPendingTracks(playlistId: string): Promise<
backend/src/services/spotifyImport.ts:2755:        const tracks = await prisma.playlistPendingTrack.findMany({
backend/src/services/spotifyImport.ts:2756:            where: { playlistId },
backend/src/services/spotifyImport.ts:2762:            artist: t.spotifyArtist,
backend/src/services/spotifyImport.ts:2763:            title: t.spotifyTitle,
backend/src/services/spotifyImport.ts:2764:            album: t.spotifyAlbum,
backend/src/services/spotifyImport.ts:2769:export const spotifyImportService = new SpotifyImportService();
backend/src/routes/offline.ts:10:const downloadAlbumSchema = z.object({
backend/src/routes/offline.ts:14:// POST /offline/albums/:id/download
backend/src/routes/offline.ts:15:router.post("/albums/:id/download", async (req, res) => {
backend/src/routes/offline.ts:19:        const { quality } = downloadAlbumSchema.parse(req.body);
backend/src/routes/offline.ts:83:        // Create download job (tracks to be downloaded by mobile client)
backend/src/routes/offline.ts:84:        const downloadJob = {
backend/src/routes/offline.ts:99:        res.json(downloadJob);
backend/src/routes/offline.ts:106:        console.error("Create download job error:", error);
backend/src/routes/offline.ts:107:        res.status(500).json({ error: "Failed to create download job" });
backend/src/routes/offline.ts:111:// POST /offline/tracks/:id/complete (called by mobile after download)
backend/src/routes/offline.ts:148:        console.error("Complete track download error:", error);
backend/src/routes/offline.ts:149:        res.status(500).json({ error: "Failed to complete download" });
backend/src/routes/enrichment.ts:349: * Repair albums missing cover art using Deezer/CAA fallback
backend/src/routes/enrichment.ts:357:            description: "Albums without covers will be fetched from Deezer/CAA"
backend/src/routes/enrichment.ts:592:                // Fallback to Deezer/other providers
frontend/features/library/components/TracksList.tsx:8:import { PlaylistSelector } from "@/components/ui/PlaylistSelector";
frontend/features/library/components/TracksList.tsx:18:  onAddToPlaylist: (playlistId: string, trackId: string) => void;
frontend/features/library/components/TracksList.tsx:36:  onShowAddToPlaylist: (trackId: string) => void;
frontend/features/library/components/TracksList.tsx:46:  onShowAddToPlaylist,
frontend/features/library/components/TracksList.tsx:127:            onShowAddToPlaylist(track.id);
frontend/features/library/components/TracksList.tsx:130:          title="Add to Playlist"
frontend/features/library/components/TracksList.tsx:162:  onAddToPlaylist,
frontend/features/library/components/TracksList.tsx:167:  const [showPlaylistSelector, setShowPlaylistSelector] = useState(false);
frontend/features/library/components/TracksList.tsx:170:  const handleShowAddToPlaylist = useCallback((trackId: string) => {
frontend/features/library/components/TracksList.tsx:172:    setShowPlaylistSelector(true);
frontend/features/library/components/TracksList.tsx:175:  const handleAddToPlaylist = useCallback(async (playlistId: string) => {
frontend/features/library/components/TracksList.tsx:177:    onAddToPlaylist(playlistId, selectedTrackId);
frontend/features/library/components/TracksList.tsx:178:    setShowPlaylistSelector(false);
frontend/features/library/components/TracksList.tsx:180:  }, [selectedTrackId, onAddToPlaylist]);
frontend/features/library/components/TracksList.tsx:221:              onShowAddToPlaylist={handleShowAddToPlaylist}
frontend/features/library/components/TracksList.tsx:228:      <PlaylistSelector
frontend/features/library/components/TracksList.tsx:229:        isOpen={showPlaylistSelector}
frontend/features/library/components/TracksList.tsx:231:          setShowPlaylistSelector(false);
frontend/features/library/components/TracksList.tsx:234:        onSelectPlaylist={handleAddToPlaylist}
frontend/features/search/hooks/useSoulseekSearch.ts:15:    downloadingFiles: Set<string>;
frontend/features/search/hooks/useSoulseekSearch.ts:16:    handleDownload: (result: SoulseekResult) => Promise<void>;
frontend/features/search/hooks/useSoulseekSearch.ts:28:    const [downloadingFiles, setDownloadingFiles] = useState<Set<string>>(
frontend/features/search/hooks/useSoulseekSearch.ts:92:    // Handle downloads
frontend/features/search/hooks/useSoulseekSearch.ts:93:    const handleDownload = useCallback(async (result: SoulseekResult) => {
frontend/features/search/hooks/useSoulseekSearch.ts:95:            setDownloadingFiles((prev) => new Set([...prev, result.filename]));
frontend/features/search/hooks/useSoulseekSearch.ts:97:            await api.downloadFromSoulseek(
frontend/features/search/hooks/useSoulseekSearch.ts:118:                setDownloadingFiles((prev) => {
frontend/features/search/hooks/useSoulseekSearch.ts:125:            console.error("Download error:", error);
frontend/features/search/hooks/useSoulseekSearch.ts:126:            toast.error(error.message || "Failed to start download");
frontend/features/search/hooks/useSoulseekSearch.ts:127:            setDownloadingFiles((prev) => {
frontend/features/search/hooks/useSoulseekSearch.ts:140:        downloadingFiles,
frontend/features/search/hooks/useSoulseekSearch.ts:141:        handleDownload,
backend/src/services/rateLimiter.ts:26:    deezer: RateLimitConfig;
backend/src/services/rateLimiter.ts:48:    deezer: {
backend/src/services/rateLimiter.ts:49:        intervalCap: 25, // Deezer is more lenient
frontend/features/artist/hooks/useArtistData.ts:6:import { useDownloadContext } from "@/lib/download-context";
frontend/features/artist/hooks/useArtistData.ts:24:    const { downloadStatus } = useDownloadContext();
frontend/features/artist/hooks/useArtistData.ts:25:    const prevActiveCountRef = useRef(downloadStatus.activeDownloads.length);
frontend/features/artist/hooks/useArtistData.ts:29:    // Use React Query - no polling needed, webhook events trigger refresh via download context
frontend/features/artist/hooks/useArtistData.ts:72:    // Refetch when downloads complete (active count decreases)
frontend/features/artist/hooks/useArtistData.ts:74:        const currentActiveCount = downloadStatus.activeDownloads.length;
frontend/features/artist/hooks/useArtistData.ts:79:            // Downloads have completed, refresh data
frontend/features/artist/hooks/useArtistData.ts:83:    }, [downloadStatus.activeDownloads.length, refetch]);
frontend/components/DownloadNotifications.tsx:8:    Download,
frontend/components/DownloadNotifications.tsx:12:import { DownloadJob } from "@/hooks/useDownloadStatus";
frontend/components/DownloadNotifications.tsx:15:import { useDownloadContext } from "@/lib/download-context";
frontend/components/DownloadNotifications.tsx:19:export function DownloadNotifications() {
frontend/components/DownloadNotifications.tsx:20:    const { downloadStatus } = useDownloadContext();
frontend/components/DownloadNotifications.tsx:95:    // Auto-open when there are active downloads or failures
frontend/components/DownloadNotifications.tsx:97:        downloadStatus.hasActiveDownloads ||
frontend/components/DownloadNotifications.tsx:98:        downloadStatus.failedDownloads.length > 0 ||
frontend/components/DownloadNotifications.tsx:99:        downloadStatus.recentDownloads.length > 0;
frontend/components/DownloadNotifications.tsx:113:    // Function to manually close modal (even if there are downloads)
frontend/components/DownloadNotifications.tsx:119:    // Function to clear completed/failed downloads
frontend/components/DownloadNotifications.tsx:123:                ...downloadStatus.recentDownloads.map((j) => j.id),
frontend/components/DownloadNotifications.tsx:124:                ...downloadStatus.failedDownloads.map((j) => j.id),
frontend/components/DownloadNotifications.tsx:137:                        .deleteDownload(id)
frontend/components/DownloadNotifications.tsx:148:            console.error("Failed to clear downloads:", error);
frontend/components/DownloadNotifications.tsx:153:        ...downloadStatus.activeDownloads,
frontend/components/DownloadNotifications.tsx:154:        ...downloadStatus.recentDownloads,
frontend/components/DownloadNotifications.tsx:174:                            <Download className="w-4 h-4 text-white/60" />
frontend/components/DownloadNotifications.tsx:176:                                Downloads
frontend/components/DownloadNotifications.tsx:178:                            {downloadStatus.hasActiveDownloads && (
frontend/components/DownloadNotifications.tsx:180:                                    {downloadStatus.activeDownloads.length}{" "}
frontend/components/DownloadNotifications.tsx:193:                    {/* Compact Download List - max 3 visible */}
frontend/components/DownloadNotifications.tsx:197:                                No downloads
frontend/components/DownloadNotifications.tsx:202:                                    <DownloadJobItemCompact
frontend/components/DownloadNotifications.tsx:222:                    {(downloadStatus.recentDownloads.length > 0 ||
frontend/components/DownloadNotifications.tsx:223:                        downloadStatus.failedDownloads.length > 0) && (
frontend/components/DownloadNotifications.tsx:267:                        <Download className="w-4 h-4 text-white/60" />
frontend/components/DownloadNotifications.tsx:269:                            Downloads
frontend/components/DownloadNotifications.tsx:271:                        {downloadStatus.hasActiveDownloads && (
frontend/components/DownloadNotifications.tsx:273:                                {downloadStatus.activeDownloads.length} active
frontend/components/DownloadNotifications.tsx:288:                {/* Download List */}
frontend/components/DownloadNotifications.tsx:292:                            No recent downloads
frontend/components/DownloadNotifications.tsx:297:                                <DownloadJobItem
frontend/components/DownloadNotifications.tsx:312:                {(downloadStatus.recentDownloads.length > 0 ||
frontend/components/DownloadNotifications.tsx:313:                    downloadStatus.failedDownloads.length > 0) && (
frontend/components/DownloadNotifications.tsx:335:function DownloadJobItem({
frontend/components/DownloadNotifications.tsx:339:    job: DownloadJob;
frontend/components/DownloadNotifications.tsx:354:                return <Download className="w-4 h-4 text-white/40" />;
frontend/components/DownloadNotifications.tsx:379:            await api.deleteDownload(job.id);
frontend/components/DownloadNotifications.tsx:381:            console.error("Failed to delete download:", error);
frontend/components/DownloadNotifications.tsx:439:function DownloadJobItemCompact({
frontend/components/DownloadNotifications.tsx:443:    job: DownloadJob;
frontend/components/DownloadNotifications.tsx:456:                return <Download className="w-3 h-3 text-white/40" />;
frontend/features/artist/hooks/usePreviewPlayer.ts:47:        toast("No Deezer preview available", { duration: 1500 });
frontend/features/artist/hooks/usePreviewPlayer.ts:98:                    // Store album info from Deezer
backend/src/services/soulseek.ts:11:import { sessionLog } from "../utils/playlistLogger";
backend/src/services/soulseek.ts:46:    private readonly DOWNLOAD_TIMEOUT = 180000; // 3 minutes per download attempt
backend/src/services/soulseek.ts:47:    private readonly MAX_DOWNLOAD_RETRIES = 3; // Try up to 3 different users
backend/src/services/soulseek.ts:555:     * Download a track directly to the music library with timeout
backend/src/services/soulseek.ts:557:    async downloadTrack(
backend/src/services/soulseek.ts:579:            `Downloading from ${match.username}: ${match.filename} -> ${destPath}`
backend/src/services/soulseek.ts:584:            let download: { stream: NodeJS.ReadableStream } | null = null;
backend/src/services/soulseek.ts:586:            // Timeout handler - 3 minutes max per download attempt
backend/src/services/soulseek.ts:592:                        `Download timed out after ${
backend/src/services/soulseek.ts:593:                            this.DOWNLOAD_TIMEOUT / 1000
backend/src/services/soulseek.ts:605:                    if (download) {
backend/src/services/soulseek.ts:606:                        (download.stream as any).destroy?.(
backend/src/services/soulseek.ts:607:                            new Error("Download timed out")
backend/src/services/soulseek.ts:610:                    resolve({ success: false, error: "Download timed out" });
backend/src/services/soulseek.ts:612:            }, this.DOWNLOAD_TIMEOUT);
backend/src/services/soulseek.ts:634:                        `✓ Downloaded: ${match.filename} (${Math.round(
backend/src/services/soulseek.ts:642:                        `Download failed: ${errorMessage || "unknown error"}`,
backend/src/services/soulseek.ts:647:                        error: errorMessage || "Download failed",
backend/src/services/soulseek.ts:654:                    download = (await this.client!.download(
backend/src/services/soulseek.ts:660:                    download.stream.on("error", (err: any) =>
backend/src/services/soulseek.ts:668:                    download.stream.pipe(writeStream);
backend/src/services/soulseek.ts:670:                    finalize(false, err?.message || "Download failed");
backend/src/services/soulseek.ts:677:     * Download a specific file path from a user (no search)
backend/src/services/soulseek.ts:679:    async downloadFile(
backend/src/services/soulseek.ts:697:        return this.downloadTrack(match, destPath);
backend/src/services/soulseek.ts:701:     * Search and download a track in one operation
backend/src/services/soulseek.ts:704:    async searchAndDownload(
backend/src/services/soulseek.ts:721:        // Try up to MAX_DOWNLOAD_RETRIES different users
backend/src/services/soulseek.ts:724:            this.MAX_DOWNLOAD_RETRIES
backend/src/services/soulseek.ts:737:            // Build destination path: /soulseek-downloads/Artist/Album/filename
backend/src/services/soulseek.ts:740:                "/soulseek-downloads",
backend/src/services/soulseek.ts:746:            // Download with timeout
backend/src/services/soulseek.ts:747:            const downloadResult = await this.downloadTrack(match, destPath);
backend/src/services/soulseek.ts:749:            if (downloadResult.success) {
backend/src/services/soulseek.ts:762:            const errorMsg = downloadResult.error || "Unknown error";
backend/src/services/soulseek.ts:776:            `All ${matchesToTry.length} download attempts failed for: ${artistName} - ${trackTitle}`,
backend/src/services/soulseek.ts:788:     * Download best match from pre-searched results
backend/src/services/soulseek.ts:791:    async downloadBestMatch(
backend/src/services/soulseek.ts:806:        // Try up to MAX_DOWNLOAD_RETRIES different users
backend/src/services/soulseek.ts:807:        const matchesToTry = allMatches.slice(0, this.MAX_DOWNLOAD_RETRIES);
backend/src/services/soulseek.ts:819:            // Build destination path: /soulseek-downloads/Artist/Album/filename
backend/src/services/soulseek.ts:822:                "/soulseek-downloads",
backend/src/services/soulseek.ts:828:            // Download with timeout
backend/src/services/soulseek.ts:829:            const downloadResult = await this.downloadTrack(match, destPath);
backend/src/services/soulseek.ts:831:            if (downloadResult.success) {
backend/src/services/soulseek.ts:844:            const errorMsg = downloadResult.error || "Unknown error";
backend/src/services/soulseek.ts:863:     * Search and download multiple tracks in parallel
backend/src/services/soulseek.ts:865:     * - Downloads limited to concurrency of 4 to prevent network saturation
backend/src/services/soulseek.ts:867:    async searchAndDownloadBatch(
backend/src/services/soulseek.ts:877:        const downloadQueue = new PQueue({ concurrency });
backend/src/services/soulseek.ts:907:        // Phase 2: Queue downloads with concurrency limit
backend/src/services/soulseek.ts:913:            `Found matches for ${tracksWithMatches.length}/${tracks.length} tracks, downloading with concurrency ${concurrency}...`
backend/src/services/soulseek.ts:927:        // Queue downloads for tracks with matches
backend/src/services/soulseek.ts:928:        const downloadPromises = tracksWithMatches.map(({ track, result }) =>
backend/src/services/soulseek.ts:929:            downloadQueue.add(async () => {
backend/src/services/soulseek.ts:930:                const downloadResult = await this.downloadWithRetry(
backend/src/services/soulseek.ts:937:                if (downloadResult.success && downloadResult.filePath) {
backend/src/services/soulseek.ts:939:                    results.files.push(downloadResult.filePath);
backend/src/services/soulseek.ts:944:                            downloadResult.error || "Unknown error"
backend/src/services/soulseek.ts:951:        await Promise.all(downloadPromises);
backend/src/services/soulseek.ts:962:     * Download with retry logic (extracted for use by batch downloads)
backend/src/services/soulseek.ts:964:    private async downloadWithRetry(
backend/src/services/soulseek.ts:974:        const matchesToTry = allMatches.slice(0, this.MAX_DOWNLOAD_RETRIES);
backend/src/services/soulseek.ts:988:                "/soulseek-downloads",
backend/src/services/soulseek.ts:994:            const result = await this.downloadTrack(match, destPath);
backend/src/routes/subsonic.yuzic.ts:1300: * download.view - Download original file
backend/src/routes/subsonic.yuzic.ts:1302:router.get("/download.view", async (req: Request, res: Response) => {
backend/src/routes/subsonic.yuzic.ts:1349:        res.download(absolutePath, filename);
backend/src/routes/subsonic.yuzic.ts:1351:        console.error("[Subsonic] download error:", error);
backend/src/routes/subsonic.yuzic.ts:1355:            "Failed to download",
backend/src/routes/subsonic.yuzic.ts:1485:        // Download, cache, and serve external URL
backend/src/routes/subsonic.yuzic.ts:1559:// PLAYLIST ENDPOINTS
backend/src/routes/subsonic.yuzic.ts:1563: * getPlaylists.view - Get all playlists
backend/src/routes/subsonic.yuzic.ts:1565:router.get("/getPlaylists.view", async (req: Request, res: Response) => {
backend/src/routes/subsonic.yuzic.ts:1569:        const playlists = await prisma.playlist.findMany({
backend/src/routes/subsonic.yuzic.ts:1577:        const playlistList = playlists.map((pl) => ({
backend/src/routes/subsonic.yuzic.ts:1590:            { playlists: { playlist: playlistList } },
backend/src/routes/subsonic.yuzic.ts:1595:        console.error("[Subsonic] getPlaylists error:", error);
backend/src/routes/subsonic.yuzic.ts:1599:            "Failed to fetch playlists",
backend/src/routes/subsonic.yuzic.ts:1607: * getPlaylist.view - Get playlist with tracks
backend/src/routes/subsonic.yuzic.ts:1609:router.get("/getPlaylist.view", async (req: Request, res: Response) => {
backend/src/routes/subsonic.yuzic.ts:1624:        const { id: playlistId } = parseSubsonicId(id as string);
backend/src/routes/subsonic.yuzic.ts:1626:        const playlist = await prisma.playlist.findUnique({
backend/src/routes/subsonic.yuzic.ts:1627:            where: { id: playlistId },
backend/src/routes/subsonic.yuzic.ts:1646:        if (!playlist || playlist.userId !== req.user!.id) {
backend/src/routes/subsonic.yuzic.ts:1650:                "Playlist not found",
backend/src/routes/subsonic.yuzic.ts:1656:        // Get play data for all tracks in playlist
backend/src/routes/subsonic.yuzic.ts:1657:        const trackIds = playlist.items.filter(item => item.track?.album).map(item => item.track.id);
backend/src/routes/subsonic.yuzic.ts:1667:        const songs = playlist.items
backend/src/routes/subsonic.yuzic.ts:1685:        const totalDuration = playlist.items.reduce(
backend/src/routes/subsonic.yuzic.ts:1693:                playlist: {
backend/src/routes/subsonic.yuzic.ts:1694:                    id: `pl-${playlist.id}`,
backend/src/routes/subsonic.yuzic.ts:1695:                    name: playlist.name,
backend/src/routes/subsonic.yuzic.ts:1700:                    created: playlist.createdAt.toISOString(),
backend/src/routes/subsonic.yuzic.ts:1701:                    changed: playlist.createdAt.toISOString(), // No updatedAt field
backend/src/routes/subsonic.yuzic.ts:1709:        console.error("[Subsonic] getPlaylist error:", error);
backend/src/routes/subsonic.yuzic.ts:1713:            "Failed to fetch playlist",
backend/src/routes/subsonic.yuzic.ts:1721: * createPlaylist.view - Create or update playlist
backend/src/routes/subsonic.yuzic.ts:1723:router.get("/createPlaylist.view", async (req: Request, res: Response) => {
backend/src/routes/subsonic.yuzic.ts:1725:    const { playlistId, name } = req.query;
backend/src/routes/subsonic.yuzic.ts:1734:        if (playlistId) {
backend/src/routes/subsonic.yuzic.ts:1735:            // Update existing playlist
backend/src/routes/subsonic.yuzic.ts:1736:            const { id: plId } = parseSubsonicId(playlistId as string);
backend/src/routes/subsonic.yuzic.ts:1739:            const existingPlaylist = await prisma.playlist.findUnique({
backend/src/routes/subsonic.yuzic.ts:1744:            if (!existingPlaylist || existingPlaylist.userId !== req.user!.id) {
backend/src/routes/subsonic.yuzic.ts:1748:                    "Not authorized to modify this playlist",
backend/src/routes/subsonic.yuzic.ts:1755:                await prisma.playlist.update({
backend/src/routes/subsonic.yuzic.ts:1763:                await prisma.playlistItem.deleteMany({
backend/src/routes/subsonic.yuzic.ts:1764:                    where: { playlistId: plId },
backend/src/routes/subsonic.yuzic.ts:1769:                await prisma.playlistItem.createMany({
backend/src/routes/subsonic.yuzic.ts:1771:                        playlistId: plId,
backend/src/routes/subsonic.yuzic.ts:1780:            // Create new playlist
backend/src/routes/subsonic.yuzic.ts:1781:            const playlist = await prisma.playlist.create({
backend/src/routes/subsonic.yuzic.ts:1791:                await prisma.playlistItem.createMany({
backend/src/routes/subsonic.yuzic.ts:1793:                        playlistId: playlist.id,
backend/src/routes/subsonic.yuzic.ts:1805:                "Required parameter 'name' or 'playlistId' is missing",
backend/src/routes/subsonic.yuzic.ts:1811:        console.error("[Subsonic] createPlaylist error:", error);
backend/src/routes/subsonic.yuzic.ts:1815:            "Failed to create/update playlist",
backend/src/routes/subsonic.yuzic.ts:1823: * updatePlaylist.view - Update playlist (add/remove songs)
backend/src/routes/subsonic.yuzic.ts:1825:router.get("/updatePlaylist.view", async (req: Request, res: Response) => {
backend/src/routes/subsonic.yuzic.ts:1827:    const { playlistId, name, songIdToAdd, songIndexToRemove } = req.query;
backend/src/routes/subsonic.yuzic.ts:1829:    if (!playlistId) {
backend/src/routes/subsonic.yuzic.ts:1833:            "Required parameter 'playlistId' is missing",
backend/src/routes/subsonic.yuzic.ts:1840:        const { id: plId } = parseSubsonicId(playlistId as string);
backend/src/routes/subsonic.yuzic.ts:1843:        const playlist = await prisma.playlist.findUnique({
backend/src/routes/subsonic.yuzic.ts:1848:        if (!playlist || playlist.userId !== req.user!.id) {
backend/src/routes/subsonic.yuzic.ts:1852:                "Not authorized to modify this playlist",
backend/src/routes/subsonic.yuzic.ts:1860:            await prisma.playlist.update({
backend/src/routes/subsonic.yuzic.ts:1869:            const currentMax = await prisma.playlistItem.aggregate({
backend/src/routes/subsonic.yuzic.ts:1870:                where: { playlistId: plId },
backend/src/routes/subsonic.yuzic.ts:1877:            await prisma.playlistItem.createMany({
backend/src/routes/subsonic.yuzic.ts:1879:                    playlistId: plId,
backend/src/routes/subsonic.yuzic.ts:1892:            const items = await prisma.playlistItem.findMany({
backend/src/routes/subsonic.yuzic.ts:1893:                where: { playlistId: plId },
backend/src/routes/subsonic.yuzic.ts:1902:                await prisma.playlistItem.deleteMany({
backend/src/routes/subsonic.yuzic.ts:1910:        console.error("[Subsonic] updatePlaylist error:", error);
backend/src/routes/subsonic.yuzic.ts:1914:            "Failed to update playlist",
backend/src/routes/subsonic.yuzic.ts:1922: * deletePlaylist.view - Delete a playlist
backend/src/routes/subsonic.yuzic.ts:1924:router.get("/deletePlaylist.view", async (req: Request, res: Response) => {
backend/src/routes/subsonic.yuzic.ts:1939:        const { id: playlistId } = parseSubsonicId(id as string);
backend/src/routes/subsonic.yuzic.ts:1942:        const playlist = await prisma.playlist.findUnique({
backend/src/routes/subsonic.yuzic.ts:1943:            where: { id: playlistId },
backend/src/routes/subsonic.yuzic.ts:1946:        if (!playlist || playlist.userId !== req.user!.id) {
backend/src/routes/subsonic.yuzic.ts:1950:                "Not authorized to delete this playlist",
backend/src/routes/subsonic.yuzic.ts:1957:        await prisma.playlistItem.deleteMany({
backend/src/routes/subsonic.yuzic.ts:1958:            where: { playlistId },
backend/src/routes/subsonic.yuzic.ts:1961:        await prisma.playlist.delete({
backend/src/routes/subsonic.yuzic.ts:1962:            where: { id: playlistId },
backend/src/routes/subsonic.yuzic.ts:1967:        console.error("[Subsonic] deletePlaylist error:", error);
backend/src/routes/subsonic.yuzic.ts:1971:            "Failed to delete playlist",
backend/src/routes/subsonic.yuzic.ts:2068:                downloadRole: true,
backend/src/routes/subsonic.yuzic.ts:2070:                playlistRole: true,
backend/src/routes/subsonic.yuzic.ts:2102:    // TODO: Implement starring (add to favorites playlist)
frontend/features/discover/components/DiscoverHero.tsx:3:import { DiscoverPlaylist, DiscoverConfig } from "../types";
frontend/features/discover/components/DiscoverHero.tsx:6:    playlist: DiscoverPlaylist | null;
frontend/features/discover/components/DiscoverHero.tsx:10:export function DiscoverHero({ playlist, config }: DiscoverHeroProps) {
frontend/features/discover/components/DiscoverHero.tsx:12:    const totalDuration = playlist?.tracks?.reduce((sum, t) => sum + (t.duration || 0), 0) || 0;
frontend/features/discover/components/DiscoverHero.tsx:34:                        Playlist
frontend/features/discover/components/DiscoverHero.tsx:40:                        Your personalized playlist of new music, curated based on your listening history.
frontend/features/discover/components/DiscoverHero.tsx:43:                        {playlist && (
frontend/features/discover/components/DiscoverHero.tsx:46:                                    Week of {format(new Date(playlist.weekStart), "MMM d, yyyy")}
frontend/features/discover/components/DiscoverHero.tsx:49:                                <span>{playlist.totalCount} songs</span>
frontend/features/discover/components/DiscoverHero.tsx:53:                                {playlist.unavailableCount > 0 && (
frontend/features/discover/components/DiscoverHero.tsx:57:                                            {playlist.unavailableCount} unavailable
frontend/features/discover/components/HowItWorks.tsx:31:                        One song per album downloads the full album to
frontend/features/discover/components/HowItWorks.tsx:50:                        replaced and you can still preview them via Deezer
backend/src/services/dataCache.ts:14:import { deezerService } from "./deezer";
backend/src/services/dataCache.ts:21:     * Order: DB -> Fanart.tv -> Deezer -> Last.fm -> save to DB
backend/src/services/dataCache.ts:146:     * Order: Fanart.tv (if MBID) -> Deezer -> Last.fm
backend/src/services/dataCache.ts:167:        // Try Deezer
backend/src/services/dataCache.ts:169:            heroUrl = await deezerService.getArtistImage(artistName);
backend/src/services/dataCache.ts:171:                console.log(`[DataCache] Got image from Deezer for ${artistName}`);
backend/src/services/dataCache.ts:175:            // Deezer failed, continue
frontend/features/artist/hooks/index.ts:3:export { useDownloadActions } from "./useDownloadActions";
frontend/features/discover/components/DiscoverActionBar.tsx:6:import type { DiscoverPlaylist, DiscoverConfig } from "../types";
frontend/features/discover/components/DiscoverActionBar.tsx:10:    status: "downloading" | "scanning" | null;
frontend/features/discover/components/DiscoverActionBar.tsx:18:    playlist: DiscoverPlaylist | null;
frontend/features/discover/components/DiscoverActionBar.tsx:20:    isPlaylistPlaying: boolean;
frontend/features/discover/components/DiscoverActionBar.tsx:30:    playlist,
frontend/features/discover/components/DiscoverActionBar.tsx:32:    isPlaylistPlaying,
frontend/features/discover/components/DiscoverActionBar.tsx:48:            return `Downloading ${batchStatus.completed || 0}/${batchStatus.total}`;
frontend/features/discover/components/DiscoverActionBar.tsx:58:                {playlist && playlist.tracks.length > 0 && (
frontend/features/discover/components/DiscoverActionBar.tsx:69:                        {isPlaylistPlaying && isPlaying ? (
frontend/features/discover/components/DiscoverActionBar.tsx:100:                                {playlist ? "Regenerate" : "Generate"}
backend/src/routes/downloads.ts:7:import { simpleDownloadManager } from "../services/simpleDownloadManager";
backend/src/routes/downloads.ts:14:// POST /downloads - Create download job
backend/src/routes/downloads.ts:23:            downloadType = "library",
backend/src/routes/downloads.ts:39:        if (downloadType !== "library" && downloadType !== "discovery") {
backend/src/routes/downloads.ts:41:                error: "downloadType must be 'library' or 'discovery'",
backend/src/routes/downloads.ts:53:        // Determine root folder path based on download type
backend/src/routes/downloads.ts:55:            downloadType === "discovery" ? "/music/discovery" : "/music";
backend/src/routes/downloads.ts:58:            // For artist downloads, fetch albums and create individual jobs
backend/src/routes/downloads.ts:59:            const jobs = await processArtistDownload(
backend/src/routes/downloads.ts:64:                downloadType
backend/src/routes/downloads.ts:70:                downloadType,
backend/src/routes/downloads.ts:72:                message: `Creating download jobs for ${jobs.length} album(s)...`,
backend/src/routes/downloads.ts:78:        // Single album download - check for existing job first
backend/src/routes/downloads.ts:79:        const existingJob = await prisma.downloadJob.findFirst({
backend/src/routes/downloads.ts:87:            console.log(`[DOWNLOAD] Job already exists for ${mbid}: ${existingJob.id} (${existingJob.status})`);
backend/src/routes/downloads.ts:91:                downloadType,
backend/src/routes/downloads.ts:93:                message: "Download already in progress",
backend/src/routes/downloads.ts:98:        const job = await prisma.downloadJob.create({
backend/src/routes/downloads.ts:106:                    downloadType,
backend/src/routes/downloads.ts:115:            `[DOWNLOAD] Triggering Lidarr: ${type} "${subject}" -> ${rootFolderPath}`
backend/src/routes/downloads.ts:119:        processDownload(
backend/src/routes/downloads.ts:129:                `Download processing failed for job ${job.id}:`,
backend/src/routes/downloads.ts:137:            downloadType,
backend/src/routes/downloads.ts:139:            message: "Download job created. Processing in background.",
backend/src/routes/downloads.ts:142:        console.error("Create download job error:", error);
backend/src/routes/downloads.ts:143:        res.status(500).json({ error: "Failed to create download job" });
backend/src/routes/downloads.ts:148: * Process artist download by creating individual album jobs
backend/src/routes/downloads.ts:150:async function processArtistDownload(
backend/src/routes/downloads.ts:155:    downloadType: string
backend/src/routes/downloads.ts:157:    console.log(`\n Processing artist download: ${artistName}`);
backend/src/routes/downloads.ts:160:    // Generate a batch ID to group all album downloads
backend/src/routes/downloads.ts:203:            // Check if we already have this album downloaded
backend/src/routes/downloads.ts:214:            const existingJob = await prisma.downloadJob.findFirst({
backend/src/routes/downloads.ts:223:                    `   Skipping "${albumTitle}" - already in download queue`
backend/src/routes/downloads.ts:228:            // Create download job for this album
backend/src/routes/downloads.ts:230:            const job = await prisma.downloadJob.create({
backend/src/routes/downloads.ts:238:                        downloadType,
backend/src/routes/downloads.ts:243:                        batchId, // Link all albums in this artist download
backend/src/routes/downloads.ts:253:            // Start the download in background
backend/src/routes/downloads.ts:254:            processDownload(
backend/src/routes/downloads.ts:263:                console.error(`Download failed for ${albumSubject}:`, error);
backend/src/routes/downloads.ts:267:        console.log(`   Created ${jobs.length} album download jobs`);
backend/src/routes/downloads.ts:270:        console.error(`   Failed to process artist download:`, error.message);
backend/src/routes/downloads.ts:275:// Background download processor
backend/src/routes/downloads.ts:276:async function processDownload(
backend/src/routes/downloads.ts:285:    const job = await prisma.downloadJob.findUnique({ where: { id: jobId } });
backend/src/routes/downloads.ts:292:        // For albums, use the simple download manager
backend/src/routes/downloads.ts:309:        // Use simple download manager for album downloads
backend/src/routes/downloads.ts:310:        const result = await simpleDownloadManager.startDownload(
backend/src/routes/downloads.ts:319:            console.error(`Failed to start download: ${result.error}`);
backend/src/routes/downloads.ts:324:// DELETE /downloads/clear-all - Clear all download jobs for the current user
backend/src/routes/downloads.ts:336:        const result = await prisma.downloadJob.deleteMany({ where });
backend/src/routes/downloads.ts:339:            ` Cleared ${result.count} download jobs for user ${userId}`
backend/src/routes/downloads.ts:343:        console.error("Clear downloads error:", error);
backend/src/routes/downloads.ts:344:        res.status(500).json({ error: "Failed to clear downloads" });
backend/src/routes/downloads.ts:348:// POST /downloads/clear-lidarr-queue - Clear stuck/failed items from Lidarr's queue
backend/src/routes/downloads.ts:351:        const result = await simpleDownloadManager.clearLidarrQueue();
backend/src/routes/downloads.ts:363:// GET /downloads/failed - List failed/unavailable albums for the current user
backend/src/routes/downloads.ts:381:// DELETE /downloads/failed/:id - Dismiss a failed album notification
backend/src/routes/downloads.ts:407:// GET /downloads/:id - Get download job status
backend/src/routes/downloads.ts:413:        const job = await prisma.downloadJob.findFirst({
backend/src/routes/downloads.ts:421:            return res.status(404).json({ error: "Download job not found" });
backend/src/routes/downloads.ts:426:        console.error("Get download job error:", error);
backend/src/routes/downloads.ts:427:        res.status(500).json({ error: "Failed to get download job" });
backend/src/routes/downloads.ts:431:// PATCH /downloads/:id - Update download job (e.g., mark as complete)
backend/src/routes/downloads.ts:438:        const job = await prisma.downloadJob.findFirst({
backend/src/routes/downloads.ts:446:            return res.status(404).json({ error: "Download job not found" });
backend/src/routes/downloads.ts:449:        const updated = await prisma.downloadJob.update({
backend/src/routes/downloads.ts:459:        console.error("Update download job error:", error);
backend/src/routes/downloads.ts:460:        res.status(500).json({ error: "Failed to update download job" });
backend/src/routes/downloads.ts:464:// DELETE /downloads/:id - Delete download job
backend/src/routes/downloads.ts:472:        const result = await prisma.downloadJob.deleteMany({
backend/src/routes/downloads.ts:482:        console.error("Delete download job error:", error);
backend/src/routes/downloads.ts:485:            error: "Failed to delete download job",
backend/src/routes/downloads.ts:491:// GET /downloads - List user's download jobs
backend/src/routes/downloads.ts:506:        const jobs = await prisma.downloadJob.findMany({
backend/src/routes/downloads.ts:512:        // Filter out discovery downloads unless explicitly requested
backend/src/routes/downloads.ts:513:        // Discovery downloads are automated and shouldn't show in the UI popover
backend/src/routes/downloads.ts:519:                      return metadata?.downloadType !== "discovery";
backend/src/routes/downloads.ts:524:        console.error("List download jobs error:", error);
backend/src/routes/downloads.ts:525:        res.status(500).json({ error: "Failed to list download jobs" });
backend/src/routes/downloads.ts:529:// GET /downloads/releases/:albumMbid - Get available releases for an album (Interactive Search)
backend/src/routes/downloads.ts:583:                // Add artist to Lidarr (without downloading)
backend/src/routes/downloads.ts:655:// POST /downloads/grab - Grab a specific release (Interactive Download)
backend/src/routes/downloads.ts:683:        // Create download job to track this
backend/src/routes/downloads.ts:685:        const job = await prisma.downloadJob.create({
backend/src/routes/downloads.ts:694:                    downloadType: "library",
backend/src/routes/downloads.ts:698:                    interactiveDownload: true,
backend/src/routes/downloads.ts:715:            await prisma.downloadJob.update({
backend/src/routes/downloads.ts:731:            message: `Downloading "${albumTitle}" - release grabbed from indexer`,
backend/src/routes/downloads.ts:748:// POST /downloads/keep-track - Keep a discovery track (move to permanent library)
backend/src/routes/downloads.ts:775:        // If Lidarr enabled, create job to download full album to permanent library
backend/src/routes/downloads.ts:778:            const job = await prisma.downloadJob.create({
backend/src/routes/downloads.ts:791:                    "Track marked as kept. Full album will be downloaded to permanent library.",
backend/src/routes/downloads.ts:792:                downloadJobId: job.id,
frontend/features/artist/hooks/useDownloadActions.ts:4:import { useDownloadContext } from '@/lib/download-context';
frontend/features/artist/hooks/useDownloadActions.ts:7:export function useDownloadActions() {
frontend/features/artist/hooks/useDownloadActions.ts:8:  const { addPendingDownload, isPendingByMbid } = useDownloadContext();
frontend/features/artist/hooks/useDownloadActions.ts:10:  const downloadArtist = useCallback(
frontend/features/artist/hooks/useDownloadActions.ts:22:      // Check if already downloading
frontend/features/artist/hooks/useDownloadActions.ts:24:        toast.info(`${artist.name} is already being downloaded`);
frontend/features/artist/hooks/useDownloadActions.ts:29:        // Add to pending downloads
frontend/features/artist/hooks/useDownloadActions.ts:30:        addPendingDownload('artist', artist.name, artist.mbid);
frontend/features/artist/hooks/useDownloadActions.ts:33:        toast.loading(`Preparing download: "${artist.name}"...`, {
frontend/features/artist/hooks/useDownloadActions.ts:34:          id: `download-${artist.mbid}`,
frontend/features/artist/hooks/useDownloadActions.ts:37:        // Trigger download
frontend/features/artist/hooks/useDownloadActions.ts:38:        await api.downloadArtist(artist.name, artist.mbid);
frontend/features/artist/hooks/useDownloadActions.ts:41:        toast.success(`Downloading ${artist.name}`, {
frontend/features/artist/hooks/useDownloadActions.ts:42:          id: `download-${artist.mbid}`,
frontend/features/artist/hooks/useDownloadActions.ts:45:        console.error('Failed to download artist:', error);
frontend/features/artist/hooks/useDownloadActions.ts:46:        toast.error(error.message || 'Failed to download artist', {
frontend/features/artist/hooks/useDownloadActions.ts:47:          id: `download-${artist.mbid}`,
frontend/features/artist/hooks/useDownloadActions.ts:51:    [addPendingDownload, isPendingByMbid]
frontend/features/artist/hooks/useDownloadActions.ts:54:  const downloadAlbum = useCallback(
frontend/features/artist/hooks/useDownloadActions.ts:67:      // Check if already downloading
frontend/features/artist/hooks/useDownloadActions.ts:69:        toast.info(`${album.title} is already being downloaded`);
frontend/features/artist/hooks/useDownloadActions.ts:74:        // Add to pending downloads
frontend/features/artist/hooks/useDownloadActions.ts:75:        addPendingDownload('album', `${artistName} - ${album.title}`, mbid);
frontend/features/artist/hooks/useDownloadActions.ts:78:        toast.loading(`Preparing download: "${album.title}"...`, {
frontend/features/artist/hooks/useDownloadActions.ts:79:          id: `download-${mbid}`,
frontend/features/artist/hooks/useDownloadActions.ts:82:        // Trigger download
frontend/features/artist/hooks/useDownloadActions.ts:83:        await api.downloadAlbum(artistName, album.title, mbid);
frontend/features/artist/hooks/useDownloadActions.ts:86:        toast.success(`Downloading ${album.title}`, {
frontend/features/artist/hooks/useDownloadActions.ts:87:          id: `download-${mbid}`,
frontend/features/artist/hooks/useDownloadActions.ts:90:        console.error('Failed to download album:', error);
frontend/features/artist/hooks/useDownloadActions.ts:91:        toast.error(error.message || 'Failed to download album', {
frontend/features/artist/hooks/useDownloadActions.ts:92:          id: `download-${mbid}`,
frontend/features/artist/hooks/useDownloadActions.ts:96:    [addPendingDownload, isPendingByMbid]
frontend/features/artist/hooks/useDownloadActions.ts:100:    downloadArtist,
frontend/features/artist/hooks/useDownloadActions.ts:101:    downloadAlbum,
backend/src/services/musicScanner.ts:7:import { deezerService } from "./deezer";
backend/src/services/musicScanner.ts:376:     * Check if an album is part of a discovery download by matching artist name + album title.
backend/src/services/musicScanner.ts:379:    private async isDiscoveryDownload(
backend/src/services/musicScanner.ts:400:            const discoveryJobs = await prisma.downloadJob.findMany({
backend/src/services/musicScanner.ts:475:            // This catches cases where Lidarr downloads a different album than requested
backend/src/services/musicScanner.ts:802:                // 2. Check if artist+album matches a discovery download job
backend/src/services/musicScanner.ts:806:                const isDiscoveryByJob = await this.isDiscoveryDownload(artistName, albumTitle);
backend/src/services/musicScanner.ts:903:                        // No embedded art, try fetching from Deezer
backend/src/services/musicScanner.ts:905:                            const deezerCover = await deezerService.getAlbumCover(
backend/src/services/musicScanner.ts:909:                            if (deezerCover) {
backend/src/services/musicScanner.ts:912:                                    data: { coverUrl: deezerCover },
backend/src/routes/recommendations.ts:573:        // Return AI artists - Deezer photos and top tracks fetched on-demand by frontend
backend/src/services/audiobookCache.ts:135:        // Build full cover URL for download (needs to be absolute URL with base)
backend/src/services/audiobookCache.ts:197:        // Download cover image if available - need to construct full URL
backend/src/services/audiobookCache.ts:203:                localCoverPath = await this.downloadCover(
backend/src/services/audiobookCache.ts:293:     * Download a cover image and save it locally
backend/src/services/audiobookCache.ts:295:    private async downloadCover(
backend/src/services/audiobookCache.ts:331:                `Failed to download cover for ${audiobookId}:`,
backend/src/services/audiobookCache.ts:334:            return null as any; // Return null if download fails
frontend/features/search/components/SearchFilters.tsx:1:import { Download } from "lucide-react";
frontend/features/search/components/SearchFilters.tsx:71:                    <Download className="w-4 h-4" />
backend/src/routes/playlists.ts:5:import { sessionLog } from "../utils/playlistLogger";
backend/src/routes/playlists.ts:11:const createPlaylistSchema = z.object({
backend/src/routes/playlists.ts:20:// GET /playlists
backend/src/routes/playlists.ts:25:        // Get user's hidden playlists
backend/src/routes/playlists.ts:26:        const hiddenPlaylists = await prisma.hiddenPlaylist.findMany({
backend/src/routes/playlists.ts:28:            select: { playlistId: true },
backend/src/routes/playlists.ts:30:        const hiddenPlaylistIds = new Set(
backend/src/routes/playlists.ts:31:            hiddenPlaylists.map((h) => h.playlistId)
backend/src/routes/playlists.ts:34:        const playlists = await prisma.playlist.findMany({
backend/src/routes/playlists.ts:67:        const playlistsWithCounts = playlists.map((playlist) => ({
backend/src/routes/playlists.ts:68:            ...playlist,
backend/src/routes/playlists.ts:69:            trackCount: playlist.items.length,
backend/src/routes/playlists.ts:70:            isOwner: playlist.userId === userId,
backend/src/routes/playlists.ts:71:            isHidden: hiddenPlaylistIds.has(playlist.id),
backend/src/routes/playlists.ts:74:        // Debug: log shared playlists with user info
backend/src/routes/playlists.ts:75:        const sharedPlaylists = playlistsWithCounts.filter((p) => !p.isOwner);
backend/src/routes/playlists.ts:76:        if (sharedPlaylists.length > 0) {
backend/src/routes/playlists.ts:78:                `[Playlists] Found ${sharedPlaylists.length} shared playlists for user ${userId}:`
backend/src/routes/playlists.ts:80:            sharedPlaylists.forEach((p) => {
backend/src/routes/playlists.ts:89:        res.json(playlistsWithCounts);
backend/src/routes/playlists.ts:91:        console.error("Get playlists error:", error);
backend/src/routes/playlists.ts:92:        res.status(500).json({ error: "Failed to get playlists" });
backend/src/routes/playlists.ts:96:// POST /playlists
backend/src/routes/playlists.ts:100:        const data = createPlaylistSchema.parse(req.body);
backend/src/routes/playlists.ts:102:        const playlist = await prisma.playlist.create({
backend/src/routes/playlists.ts:110:        res.json(playlist);
backend/src/routes/playlists.ts:117:        console.error("Create playlist error:", error);
backend/src/routes/playlists.ts:118:        res.status(500).json({ error: "Failed to create playlist" });
backend/src/routes/playlists.ts:122:// GET /playlists/:id
backend/src/routes/playlists.ts:127:        const playlist = await prisma.playlist.findUnique({
backend/src/routes/playlists.ts:161:        if (!playlist) {
backend/src/routes/playlists.ts:162:            return res.status(404).json({ error: "Playlist not found" });
backend/src/routes/playlists.ts:166:        if (!playlist.isPublic && playlist.userId !== userId) {
backend/src/routes/playlists.ts:170:        // Format playlist items
backend/src/routes/playlists.ts:171:        const formattedItems = playlist.items.map((item) => ({
backend/src/routes/playlists.ts:184:        const formattedPending = playlist.pendingTracks.map((pending) => ({
backend/src/routes/playlists.ts:190:                artist: pending.spotifyArtist,
backend/src/routes/playlists.ts:191:                title: pending.spotifyTitle,
backend/src/routes/playlists.ts:192:                album: pending.spotifyAlbum,
backend/src/routes/playlists.ts:193:                previewUrl: pending.deezerPreviewUrl,
backend/src/routes/playlists.ts:204:            ...playlist,
backend/src/routes/playlists.ts:205:            isOwner: playlist.userId === userId,
backend/src/routes/playlists.ts:206:            trackCount: playlist.items.length,
backend/src/routes/playlists.ts:207:            pendingCount: playlist.pendingTracks.length,
backend/src/routes/playlists.ts:213:        console.error("Get playlist error:", error);
backend/src/routes/playlists.ts:214:        res.status(500).json({ error: "Failed to get playlist" });
backend/src/routes/playlists.ts:218:// PUT /playlists/:id
backend/src/routes/playlists.ts:222:        const data = createPlaylistSchema.parse(req.body);
backend/src/routes/playlists.ts:225:        const existing = await prisma.playlist.findUnique({
backend/src/routes/playlists.ts:230:            return res.status(404).json({ error: "Playlist not found" });
backend/src/routes/playlists.ts:237:        const playlist = await prisma.playlist.update({
backend/src/routes/playlists.ts:245:        res.json(playlist);
backend/src/routes/playlists.ts:252:        console.error("Update playlist error:", error);
backend/src/routes/playlists.ts:253:        res.status(500).json({ error: "Failed to update playlist" });
backend/src/routes/playlists.ts:257:// POST /playlists/:id/hide - Hide any playlist from your view
backend/src/routes/playlists.ts:261:        const playlistId = req.params.id;
backend/src/routes/playlists.ts:263:        // Check playlist exists
backend/src/routes/playlists.ts:264:        const playlist = await prisma.playlist.findUnique({
backend/src/routes/playlists.ts:265:            where: { id: playlistId },
backend/src/routes/playlists.ts:268:        if (!playlist) {
backend/src/routes/playlists.ts:269:            return res.status(404).json({ error: "Playlist not found" });
backend/src/routes/playlists.ts:272:        // User must own the playlist OR it must be public (shared)
backend/src/routes/playlists.ts:273:        if (playlist.userId !== userId && !playlist.isPublic) {
backend/src/routes/playlists.ts:278:        await prisma.hiddenPlaylist.upsert({
backend/src/routes/playlists.ts:280:                userId_playlistId: { userId, playlistId },
backend/src/routes/playlists.ts:282:            create: { userId, playlistId },
backend/src/routes/playlists.ts:286:        res.json({ message: "Playlist hidden", isHidden: true });
backend/src/routes/playlists.ts:288:        console.error("Hide playlist error:", error);
backend/src/routes/playlists.ts:289:        res.status(500).json({ error: "Failed to hide playlist" });
backend/src/routes/playlists.ts:293:// DELETE /playlists/:id/hide - Unhide a shared playlist
backend/src/routes/playlists.ts:297:        const playlistId = req.params.id;
backend/src/routes/playlists.ts:300:        await prisma.hiddenPlaylist.deleteMany({
backend/src/routes/playlists.ts:301:            where: { userId, playlistId },
backend/src/routes/playlists.ts:304:        res.json({ message: "Playlist unhidden", isHidden: false });
backend/src/routes/playlists.ts:306:        console.error("Unhide playlist error:", error);
backend/src/routes/playlists.ts:307:        res.status(500).json({ error: "Failed to unhide playlist" });
backend/src/routes/playlists.ts:311:// DELETE /playlists/:id
backend/src/routes/playlists.ts:317:        const existing = await prisma.playlist.findUnique({
backend/src/routes/playlists.ts:322:            return res.status(404).json({ error: "Playlist not found" });
backend/src/routes/playlists.ts:329:        await prisma.playlist.delete({
backend/src/routes/playlists.ts:333:        res.json({ message: "Playlist deleted" });
backend/src/routes/playlists.ts:335:        console.error("Delete playlist error:", error);
backend/src/routes/playlists.ts:336:        res.status(500).json({ error: "Failed to delete playlist" });
backend/src/routes/playlists.ts:340:// POST /playlists/:id/items
backend/src/routes/playlists.ts:354:        const playlist = await prisma.playlist.findUnique({
backend/src/routes/playlists.ts:364:        if (!playlist) {
backend/src/routes/playlists.ts:365:            return res.status(404).json({ error: "Playlist not found" });
backend/src/routes/playlists.ts:368:        if (playlist.userId !== userId) {
backend/src/routes/playlists.ts:381:        // Check if track already in playlist
backend/src/routes/playlists.ts:382:        const existing = await prisma.playlistItem.findUnique({
backend/src/routes/playlists.ts:384:                playlistId_trackId: {
backend/src/routes/playlists.ts:385:                    playlistId: req.params.id,
backend/src/routes/playlists.ts:393:                message: "Track already in playlist",
backend/src/routes/playlists.ts:400:        const maxSort = playlist.items[0]?.sort || 0;
backend/src/routes/playlists.ts:402:        const item = await prisma.playlistItem.create({
backend/src/routes/playlists.ts:404:                playlistId: req.params.id,
backend/src/routes/playlists.ts:428:        console.error("Add track to playlist error:", error);
backend/src/routes/playlists.ts:429:        res.status(500).json({ error: "Failed to add track to playlist" });
backend/src/routes/playlists.ts:433:// DELETE /playlists/:id/items/:trackId
backend/src/routes/playlists.ts:439:        const playlist = await prisma.playlist.findUnique({
backend/src/routes/playlists.ts:443:        if (!playlist) {
backend/src/routes/playlists.ts:444:            return res.status(404).json({ error: "Playlist not found" });
backend/src/routes/playlists.ts:447:        if (playlist.userId !== userId) {
backend/src/routes/playlists.ts:451:        await prisma.playlistItem.delete({
backend/src/routes/playlists.ts:453:                playlistId_trackId: {
backend/src/routes/playlists.ts:454:                    playlistId: req.params.id,
backend/src/routes/playlists.ts:460:        res.json({ message: "Track removed from playlist" });
backend/src/routes/playlists.ts:462:        console.error("Remove track from playlist error:", error);
backend/src/routes/playlists.ts:463:        res.status(500).json({ error: "Failed to remove track from playlist" });
backend/src/routes/playlists.ts:467:// PUT /playlists/:id/items/reorder
backend/src/routes/playlists.ts:478:        const playlist = await prisma.playlist.findUnique({
backend/src/routes/playlists.ts:482:        if (!playlist) {
backend/src/routes/playlists.ts:483:            return res.status(404).json({ error: "Playlist not found" });
backend/src/routes/playlists.ts:486:        if (playlist.userId !== userId) {
backend/src/routes/playlists.ts:492:            prisma.playlistItem.update({
backend/src/routes/playlists.ts:494:                    playlistId_trackId: {
backend/src/routes/playlists.ts:495:                        playlistId: req.params.id,
backend/src/routes/playlists.ts:505:        res.json({ message: "Playlist reordered" });
backend/src/routes/playlists.ts:507:        console.error("Reorder playlist error:", error);
backend/src/routes/playlists.ts:508:        res.status(500).json({ error: "Failed to reorder playlist" });
backend/src/routes/playlists.ts:513:// Pending Tracks (from Spotify imports)
backend/src/routes/playlists.ts:517: * GET /playlists/:id/pending
backend/src/routes/playlists.ts:518: * Get pending tracks for a playlist (tracks from Spotify that haven't been matched yet)
backend/src/routes/playlists.ts:523:        const playlistId = req.params.id;
backend/src/routes/playlists.ts:526:        const playlist = await prisma.playlist.findUnique({
backend/src/routes/playlists.ts:527:            where: { id: playlistId },
backend/src/routes/playlists.ts:530:        if (!playlist) {
backend/src/routes/playlists.ts:531:            return res.status(404).json({ error: "Playlist not found" });
backend/src/routes/playlists.ts:534:        if (playlist.userId !== userId && !playlist.isPublic) {
backend/src/routes/playlists.ts:538:        const pendingTracks = await prisma.playlistPendingTrack.findMany({
backend/src/routes/playlists.ts:539:            where: { playlistId },
backend/src/routes/playlists.ts:547:                artist: t.spotifyArtist,
backend/src/routes/playlists.ts:548:                title: t.spotifyTitle,
backend/src/routes/playlists.ts:549:                album: t.spotifyAlbum,
backend/src/routes/playlists.ts:551:                previewUrl: t.deezerPreviewUrl,
backend/src/routes/playlists.ts:553:            spotifyPlaylistId: playlist.spotifyPlaylistId,
backend/src/routes/playlists.ts:562: * DELETE /playlists/:id/pending/:trackId
backend/src/routes/playlists.ts:568:        const { id: playlistId, trackId: pendingTrackId } = req.params;
backend/src/routes/playlists.ts:571:        const playlist = await prisma.playlist.findUnique({
backend/src/routes/playlists.ts:572:            where: { id: playlistId },
backend/src/routes/playlists.ts:575:        if (!playlist) {
backend/src/routes/playlists.ts:576:            return res.status(404).json({ error: "Playlist not found" });
backend/src/routes/playlists.ts:579:        if (playlist.userId !== userId) {
backend/src/routes/playlists.ts:583:        await prisma.playlistPendingTrack.delete({
backend/src/routes/playlists.ts:598: * GET /playlists/:id/pending/:trackId/preview
backend/src/routes/playlists.ts:599: * Get a fresh Deezer preview URL for a pending track (since they expire)
backend/src/routes/playlists.ts:606:        const pendingTrack = await prisma.playlistPendingTrack.findUnique({
backend/src/routes/playlists.ts:614:        // Fetch fresh Deezer preview URL
backend/src/routes/playlists.ts:615:        const { deezerService } = await import("../services/deezer");
backend/src/routes/playlists.ts:616:        const previewUrl = await deezerService.getTrackPreview(
backend/src/routes/playlists.ts:617:            pendingTrack.spotifyArtist,
backend/src/routes/playlists.ts:618:            pendingTrack.spotifyTitle
backend/src/routes/playlists.ts:624:                .json({ error: "No preview available on Deezer" });
backend/src/routes/playlists.ts:628:        await prisma.playlistPendingTrack.update({
backend/src/routes/playlists.ts:630:            data: { deezerPreviewUrl: previewUrl },
backend/src/routes/playlists.ts:641: * POST /playlists/:id/pending/:trackId/retry
backend/src/routes/playlists.ts:642: * Retry downloading a failed/pending track from Soulseek
backend/src/routes/playlists.ts:643: * Returns immediately and downloads in background
backend/src/routes/playlists.ts:648:        const { id: playlistId, trackId: pendingTrackId } = req.params;
backend/src/routes/playlists.ts:652:            `Request: userId=${userId} playlistId=${playlistId} pendingTrackId=${pendingTrackId}`
backend/src/routes/playlists.ts:656:        const playlist = await prisma.playlist.findUnique({
backend/src/routes/playlists.ts:657:            where: { id: playlistId },
backend/src/routes/playlists.ts:660:        if (!playlist) {
backend/src/routes/playlists.ts:663:                `Playlist not found: ${playlistId}`,
backend/src/routes/playlists.ts:666:            return res.status(404).json({ error: "Playlist not found" });
backend/src/routes/playlists.ts:669:        if (playlist.userId !== userId) {
backend/src/routes/playlists.ts:672:                `Access denied: playlistId=${playlistId} userId=${userId}`,
backend/src/routes/playlists.ts:679:        const pendingTrack = await prisma.playlistPendingTrack.findUnique({
backend/src/routes/playlists.ts:694:            `Pending track: artist="${pendingTrack.spotifyArtist}" title="${pendingTrack.spotifyTitle}" album="${pendingTrack.spotifyAlbum}"`
backend/src/routes/playlists.ts:697:        // Create a DownloadJob so this retry appears in Activity (active/history)
backend/src/routes/playlists.ts:703:        const downloadJob = await prisma.downloadJob.create({
backend/src/routes/playlists.ts:706:                subject: `${pendingTrack.spotifyArtist} - ${pendingTrack.spotifyTitle}`,
backend/src/routes/playlists.ts:714:                    downloadType: "pending-track-retry",
backend/src/routes/playlists.ts:716:                    playlistId,
backend/src/routes/playlists.ts:718:                    spotifyArtist: pendingTrack.spotifyArtist,
backend/src/routes/playlists.ts:719:                    spotifyTitle: pendingTrack.spotifyTitle,
backend/src/routes/playlists.ts:720:                    spotifyAlbum: pendingTrack.spotifyAlbum,
backend/src/routes/playlists.ts:728:            `Created download job: downloadJobId=${downloadJob.id} target=${retryTargetId}`
backend/src/routes/playlists.ts:731:        // Import soulseek service and try to download
backend/src/routes/playlists.ts:738:            await prisma.downloadJob.update({
backend/src/routes/playlists.ts:739:                where: { id: downloadJob.id },
backend/src/routes/playlists.ts:755:            await prisma.downloadJob.update({
backend/src/routes/playlists.ts:756:                where: { id: downloadJob.id },
backend/src/routes/playlists.ts:770:            pendingTrack.spotifyAlbum !== "Unknown Album"
backend/src/routes/playlists.ts:771:                ? pendingTrack.spotifyAlbum
backend/src/routes/playlists.ts:772:                : pendingTrack.spotifyArtist; // Use artist as fallback folder name
backend/src/routes/playlists.ts:775:            `[Retry] Starting download for: ${pendingTrack.spotifyArtist} - ${pendingTrack.spotifyTitle}`
backend/src/routes/playlists.ts:779:            `Search: ${pendingTrack.spotifyArtist} - ${pendingTrack.spotifyTitle}`
backend/src/routes/playlists.ts:785:            pendingTrack.spotifyArtist,
backend/src/routes/playlists.ts:786:            pendingTrack.spotifyTitle
backend/src/routes/playlists.ts:793:            await prisma.downloadJob.update({
backend/src/routes/playlists.ts:794:                where: { id: downloadJob.id },
backend/src/routes/playlists.ts:810:            `[Retry] ✓ Found ${searchResult.allMatches.length} results, starting download in background`
backend/src/routes/playlists.ts:814:            `Found ${searchResult.allMatches.length} candidate(s); starting background download`
backend/src/routes/playlists.ts:817:        // Return immediately - download happens in background
backend/src/routes/playlists.ts:820:            message: "Download started",
backend/src/routes/playlists.ts:821:            note: `Found ${searchResult.allMatches.length} sources. Downloading... Track will appear after scan.`,
backend/src/routes/playlists.ts:822:            downloadJobId: downloadJob.id,
backend/src/routes/playlists.ts:825:        // Start download in background (don't await)
backend/src/routes/playlists.ts:827:            .downloadBestMatch(
backend/src/routes/playlists.ts:828:                pendingTrack.spotifyArtist,
backend/src/routes/playlists.ts:829:                pendingTrack.spotifyTitle,
backend/src/routes/playlists.ts:837:                        `[Retry] ✓ Download complete: ${result.filePath}`
backend/src/routes/playlists.ts:841:                        `Download complete: filePath=${result.filePath}`
backend/src/routes/playlists.ts:844:                    await prisma.downloadJob.update({
backend/src/routes/playlists.ts:845:                        where: { id: downloadJob.id },
backend/src/routes/playlists.ts:850:                                ...(downloadJob.metadata as any),
backend/src/routes/playlists.ts:896:                    console.log(`[Retry] ✗ Download failed: ${result.error}`);
backend/src/routes/playlists.ts:899:                        `Download failed: ${result.error || "unknown error"}`,
backend/src/routes/playlists.ts:903:                    await prisma.downloadJob.update({
backend/src/routes/playlists.ts:904:                        where: { id: downloadJob.id },
backend/src/routes/playlists.ts:907:                            error: result.error || "Download failed",
backend/src/routes/playlists.ts:914:                console.error(`[Retry] Download error:`, error);
backend/src/routes/playlists.ts:917:                    `Download exception: ${error?.message || error}`,
backend/src/routes/playlists.ts:921:                prisma.downloadJob
backend/src/routes/playlists.ts:923:                        where: { id: downloadJob.id },
backend/src/routes/playlists.ts:926:                            error: error?.message || "Download exception",
backend/src/routes/playlists.ts:940:            error: "Failed to retry download",
backend/src/routes/playlists.ts:947: * POST /playlists/:id/pending/reconcile
backend/src/routes/playlists.ts:948: * Manually trigger reconciliation for a specific playlist
backend/src/routes/playlists.ts:953:        const playlistId = req.params.id;
backend/src/routes/playlists.ts:956:        const playlist = await prisma.playlist.findUnique({
backend/src/routes/playlists.ts:957:            where: { id: playlistId },
backend/src/routes/playlists.ts:960:        if (!playlist) {
backend/src/routes/playlists.ts:961:            return res.status(404).json({ error: "Playlist not found" });
backend/src/routes/playlists.ts:964:        if (playlist.userId !== userId) {
backend/src/routes/playlists.ts:969:        const { spotifyImportService } = await import(
backend/src/routes/playlists.ts:970:            "../services/spotifyImport"
backend/src/routes/playlists.ts:972:        const result = await spotifyImportService.reconcilePendingTracks();
backend/src/routes/playlists.ts:977:            playlistsUpdated: result.playlistsUpdated,
backend/src/services/discoveryLogger.ts:5: * Discovery Logger - Creates detailed log files for each discovery playlist generation
backend/src/services/discoverWeekly.ts:4: * Generates weekly discovery playlists using Last.fm recommendations,
backend/src/services/discoverWeekly.ts:5: * downloads via Lidarr, and only shows songs after successful import.
backend/src/services/discoverWeekly.ts:18:import { simpleDownloadManager } from "./simpleDownloadManager";
backend/src/services/discoverWeekly.ts:40:// This ensures each playlist has a mix of similarity levels
backend/src/services/discoverWeekly.ts:74:     * Process liked albums before generating new playlist
backend/src/services/discoverWeekly.ts:262:    async generatePlaylist(userId: string, jobId?: number) {
backend/src/services/discoverWeekly.ts:303:            // Get download ratio from config (default 1.3)
backend/src/services/discoverWeekly.ts:304:            const downloadRatio = config.downloadRatio ?? 1.3;
backend/src/services/discoverWeekly.ts:307:                "Target Songs": config.playlistSize,
backend/src/services/discoverWeekly.ts:308:                "Download Ratio": `${downloadRatio}x`,
backend/src/services/discoverWeekly.ts:316:            const targetCount = config.playlistSize;
backend/src/services/discoverWeekly.ts:354:            // REQUEST MORE ALBUMS than target to account for download failures
backend/src/services/discoverWeekly.ts:356:            const albumsToRequest = Math.ceil(targetCount * downloadRatio);
backend/src/services/discoverWeekly.ts:362:                `Requesting ${albumsToRequest} albums (${downloadRatio}x target of ${targetCount}) to account for failures`
backend/src/services/discoverWeekly.ts:398:                `${recommended.length} albums recommended for download`
backend/src/services/discoverWeekly.ts:418:                        status: "downloading",
backend/src/services/discoverWeekly.ts:426:                                message: `Started with ${recommended.length} albums to download`,
backend/src/services/discoverWeekly.ts:433:                // Create all download jobs in the same transaction
backend/src/services/discoverWeekly.ts:443:                    const existingJob = await tx.downloadJob.findFirst({
backend/src/services/discoverWeekly.ts:461:                    await tx.downloadJob.create({
backend/src/services/discoverWeekly.ts:470:                                downloadType: "discovery",
backend/src/services/discoverWeekly.ts:486:                `Created ${recommended.length} download jobs`
backend/src/services/discoverWeekly.ts:489:            // Step 5: Start downloads outside transaction (they involve external APIs)
backend/src/services/discoverWeekly.ts:490:            discoveryLogger.section("STEP 5: START DOWNLOADS");
backend/src/services/discoverWeekly.ts:491:            let downloadsStarted = 0;
backend/src/services/discoverWeekly.ts:492:            let downloadsFailed = 0;
backend/src/services/discoverWeekly.ts:494:            const jobs = await prisma.downloadJob.findMany({
backend/src/services/discoverWeekly.ts:501:                    const result = await simpleDownloadManager.startDownload(
backend/src/services/discoverWeekly.ts:511:                        downloadsStarted++;
backend/src/services/discoverWeekly.ts:517:                        downloadsFailed++;
backend/src/services/discoverWeekly.ts:529:                    downloadsFailed++;
backend/src/services/discoverWeekly.ts:544:                "Downloads Started": downloadsStarted,
backend/src/services/discoverWeekly.ts:545:                "Downloads Failed": downloadsFailed,
backend/src/services/discoverWeekly.ts:553:                `${downloadsStarted} downloads started, waiting for webhooks`
backend/src/services/discoverWeekly.ts:558:                `${downloadsStarted}/${recommended.length} downloads queued`
backend/src/services/discoverWeekly.ts:563:                playlistName: `Discover Weekly (Week of ${weekStart.toLocaleDateString()})`,
backend/src/services/discoverWeekly.ts:647:     * Check for batches stuck in "downloading" or "scanning" status for too long
backend/src/services/discoverWeekly.ts:657:                status: { in: ["downloading", "scanning"] },
backend/src/services/discoverWeekly.ts:691:                await prisma.downloadJob.updateMany({
backend/src/services/discoverWeekly.ts:724:                await prisma.downloadJob.updateMany({
backend/src/services/discoverWeekly.ts:731:                        error: "Batch timeout - download took too long",
backend/src/services/discoverWeekly.ts:795:        // Wait for ALL downloads to complete/fail
backend/src/services/discoverWeekly.ts:798:                `[BATCH ${batchId}] Still waiting for ${pendingJobs.length} downloads`
backend/src/services/discoverWeekly.ts:809:            // Create UnavailableAlbum records for failed downloads
backend/src/services/discoverWeekly.ts:852:                        errorMessage: "All downloads failed",
backend/src/services/discoverWeekly.ts:869:            console.log(`   All downloads failed`);
backend/src/services/discoverWeekly.ts:870:            await this.addBatchLog(batchId, "error", "All downloads failed");
backend/src/services/discoverWeekly.ts:877:        // All successful downloads will be included in the playlist
backend/src/services/discoverWeekly.ts:879:            `   ${completed} albums ready for playlist. Triggering scan...`
backend/src/services/discoverWeekly.ts:884:            `${completed} completed, ${failed} failed. All successful downloads will be in playlist.`
backend/src/services/discoverWeekly.ts:895:            `   Scan queued - will build playlist after scan completes`
backend/src/services/discoverWeekly.ts:900:     * Build final playlist after scan completes (atomic transaction)
backend/src/services/discoverWeekly.ts:902:    async buildFinalPlaylist(batchId: string) {
backend/src/services/discoverWeekly.ts:903:        console.log(`\n Building final playlist for batch ${batchId}...`);
backend/src/services/discoverWeekly.ts:914:        // Get completed download jobs
backend/src/services/discoverWeekly.ts:915:        const completedJobs = await prisma.downloadJob.findMany({
backend/src/services/discoverWeekly.ts:922:        console.log(`   Found ${completedJobs.length} completed downloads`);
backend/src/services/discoverWeekly.ts:926:            `Building playlist from ${completedJobs.length} completed downloads`
backend/src/services/discoverWeekly.ts:1089:        // PLAYLIST COMPOSITION: ALL Discovery + ~20% Anchors
backend/src/services/discoverWeekly.ts:1091:        // Include ALL successfully downloaded albums!
backend/src/services/discoverWeekly.ts:1288:            `Playlist built: ${discoverySelected.length} discovery + ${libraryAnchors.length} anchors = ${selected.length} total`
backend/src/services/discoverWeekly.ts:1294:            console.log(`   FAILED: No tracks available for playlist`);
backend/src/services/discoverWeekly.ts:1298:                `No tracks available for playlist`
backend/src/services/discoverWeekly.ts:1302:                `   NOTE: Got ${selected.length} tracks (target was ${target}, including ALL successful downloads)`
backend/src/services/discoverWeekly.ts:1407:                                downloadedAt: new Date(),
backend/src/services/discoverWeekly.ts:1418:                                downloadedAt: new Date(),
backend/src/services/discoverWeekly.ts:1498:                `   Playlist complete: ${result.trackCount} tracks from ${result.albumCount} albums`
backend/src/services/discoverWeekly.ts:1503:                `Playlist complete: ${result.trackCount} tracks from ${result.albumCount} albums`
backend/src/services/discoverWeekly.ts:1516:        // ALWAYS cleanup failed artists from Lidarr (even if playlist creation failed)
backend/src/services/discoverWeekly.ts:1526:     * but are no longer needed (download completed but album not in final playlist)
backend/src/services/discoverWeekly.ts:1548:            // Get all download IDs from our batch jobs
backend/src/services/discoverWeekly.ts:1549:            const ourDownloadIds = new Set<string>();
backend/src/services/discoverWeekly.ts:1552:                    ourDownloadIds.add(job.lidarrRef);
backend/src/services/discoverWeekly.ts:1556:            if (ourDownloadIds.size === 0) {
backend/src/services/discoverWeekly.ts:1557:                console.log(`   No download IDs to check`);
backend/src/services/discoverWeekly.ts:1576:                const downloadId = item.downloadId;
backend/src/services/discoverWeekly.ts:1578:                // Check if this is one of our downloads
backend/src/services/discoverWeekly.ts:1579:                if (downloadId && ourDownloadIds.has(downloadId)) {
backend/src/services/discoverWeekly.ts:1584:                        item.trackedDownloadState === "importFailed" ||
backend/src/services/discoverWeekly.ts:1585:                        item.trackedDownloadState === "importBlocked";
backend/src/services/discoverWeekly.ts:1629:     * - Had ALL their downloads fail in this batch
backend/src/services/discoverWeekly.ts:1633:     * who don't have successful downloads. The tag is the source of truth.
backend/src/services/discoverWeekly.ts:1647:        // Build set of artists with successful downloads in this batch
backend/src/services/discoverWeekly.ts:1658:        console.log(`   ${successfulArtistMbids.size} artists had successful downloads`);
backend/src/services/discoverWeekly.ts:1673:            // Keep if artist had successful downloads in this batch
backend/src/services/discoverWeekly.ts:1709:            // Artist has discovery tag, no successful downloads, no liked albums = remove
backend/src/services/discoverWeekly.ts:1732:     * Cleanup extra albums that won't be in the final playlist
backend/src/services/discoverWeekly.ts:1733:     * Called when we have more successful downloads than needed
backend/src/services/discoverWeekly.ts:1786:                // Mark the job as cancelled (not used in playlist)
backend/src/services/discoverWeekly.ts:1787:                await prisma.downloadJob.update({
backend/src/services/discoverWeekly.ts:1791:                        error: "Extra album - not needed for playlist",
backend/src/services/discoverWeekly.ts:2033:        // Check pending downloads
backend/src/services/discoverWeekly.ts:2034:        const pendingDownload = await prisma.downloadJob.findFirst({
backend/src/services/discoverWeekly.ts:2040:        if (pendingDownload) return true;
backend/src/services/discoverWeekly.ts:2067:     * Find a replacement album when download fails after all retries.
backend/src/services/discoverWeekly.ts:2092:        const batchJobs = await prisma.downloadJob.findMany({
backend/src/services/discoverWeekly.ts:2260:                        isLibraryAnchor: true, // Flag so we know not to download
backend/src/services/openrouter.ts:7:interface PlaylistTrack {
backend/src/services/openrouter.ts:14:interface GeneratePlaylistParams {
backend/src/services/openrouter.ts:110:    async generateWeeklyPlaylist(
backend/src/services/openrouter.ts:111:        params: GeneratePlaylistParams
backend/src/services/openrouter.ts:112:    ): Promise<PlaylistTrack[]> {
backend/src/services/openrouter.ts:135:        const prompt = `You are a music curator creating a personalized "Discover Weekly" playlist.
backend/src/services/openrouter.ts:146:Generate a ${targetCount}-track playlist with this breakdown:
backend/src/services/openrouter.ts:160:6. Variety of moods and tempos across the playlist
backend/src/services/openrouter.ts:182:                            "You are an expert music curator who creates personalized playlists based on listening history. You always respond with valid JSON only. Ensure all strings are properly escaped.",
backend/src/services/openrouter.ts:219:            throw new Error("Failed to generate playlist with AI");
backend/src/services/openrouter.ts:233:Provide a single-sentence reason why this track would fit in their Discover Weekly playlist.
frontend/features/search/components/SoulseekSongsList.tsx:1:import { Music, Download, CheckCircle } from "lucide-react";
frontend/features/search/components/SoulseekSongsList.tsx:7:    downloadingFiles: Set<string>;
frontend/features/search/components/SoulseekSongsList.tsx:8:    onDownload: (result: SoulseekResult) => void;
frontend/features/search/components/SoulseekSongsList.tsx:69:    downloadingFiles,
frontend/features/search/components/SoulseekSongsList.tsx:70:    onDownload,
frontend/features/search/components/SoulseekSongsList.tsx:94:                    const isDownloading = downloadingFiles.has(result.filename);
frontend/features/search/components/SoulseekSongsList.tsx:118:                                    onClick={() => onDownload(result)}
frontend/features/search/components/SoulseekSongsList.tsx:119:                                    disabled={isDownloading}
frontend/features/search/components/SoulseekSongsList.tsx:122:                                        isDownloading
frontend/features/search/components/SoulseekSongsList.tsx:127:                                    {isDownloading ? (
frontend/features/search/components/SoulseekSongsList.tsx:130:                                            Downloading
frontend/features/search/components/SoulseekSongsList.tsx:134:                                            <Download className="w-4 h-4" />
frontend/features/search/components/SoulseekSongsList.tsx:135:                                            Download
frontend/features/discover/types.ts:25:  deezerTrackId: string | null;
frontend/features/discover/types.ts:26:  deezerAlbumId: string | null;
frontend/features/discover/types.ts:31:export interface DiscoverPlaylist {
frontend/features/discover/types.ts:41:  playlistSize: number;
frontend/features/discover/types.ts:42:  exclusionMonths: number; // 0-12, months to exclude albums after download (0 = no exclusion)
frontend/features/discover/types.ts:43:  downloadRatio: number; // 1.0-2.0, multiplier for albums to request vs target songs
backend/src/services/podcastDownload.ts:8: * PodcastDownloadService - Background download and caching of podcast episodes
backend/src/services/podcastDownload.ts:11: * - Non-blocking background downloads when episodes are played
backend/src/services/podcastDownload.ts:16:// Track in-progress downloads to avoid duplicates
backend/src/services/podcastDownload.ts:17:const downloadingEpisodes = new Set<string>();
backend/src/services/podcastDownload.ts:19:// Track download progress (episodeId -> { bytesDownloaded, totalBytes })
backend/src/services/podcastDownload.ts:20:interface DownloadProgress {
backend/src/services/podcastDownload.ts:21:    bytesDownloaded: number;
backend/src/services/podcastDownload.ts:24:const downloadProgress = new Map<string, DownloadProgress>();
backend/src/services/podcastDownload.ts:32: * Get download progress for an episode
backend/src/services/podcastDownload.ts:33: * Returns { progress: 0-100, downloading: boolean } or null if not downloading
backend/src/services/podcastDownload.ts:35:export function getDownloadProgress(episodeId: string): { progress: number; downloading: boolean } | null {
backend/src/services/podcastDownload.ts:36:    if (!downloadingEpisodes.has(episodeId)) {
backend/src/services/podcastDownload.ts:40:    const progress = downloadProgress.get(episodeId);
backend/src/services/podcastDownload.ts:42:        return { progress: 0, downloading: true };
backend/src/services/podcastDownload.ts:45:    const percent = Math.round((progress.bytesDownloaded / progress.totalBytes) * 100);
backend/src/services/podcastDownload.ts:46:    return { progress: Math.min(100, percent), downloading: true };
backend/src/services/podcastDownload.ts:51: * Returns null if file doesn't exist, is empty, or is still being downloaded
backend/src/services/podcastDownload.ts:54:    // Don't return cache path if still downloading - file may be incomplete
backend/src/services/podcastDownload.ts:55:    if (downloadingEpisodes.has(episodeId)) {
backend/src/services/podcastDownload.ts:56:        console.log(`[PODCAST-DL] Episode ${episodeId} is still downloading, not using cache`);
backend/src/services/podcastDownload.ts:70:            // This prevents "cached=true" when we only downloaded part of the file (which breaks seeking and causes 416s).
backend/src/services/podcastDownload.ts:87:                        await prisma.podcastDownload.deleteMany({
backend/src/services/podcastDownload.ts:98:            const dbRecord = await prisma.podcastDownload.findFirst({
backend/src/services/podcastDownload.ts:117:                await prisma.podcastDownload.deleteMany({ where: { episodeId } });
backend/src/services/podcastDownload.ts:122:            await prisma.podcastDownload.updateMany({
backend/src/services/podcastDownload.ts:137: * Start a background download for an episode
backend/src/services/podcastDownload.ts:138: * Returns immediately, download happens asynchronously
backend/src/services/podcastDownload.ts:140:export function downloadInBackground(
backend/src/services/podcastDownload.ts:145:    // Skip if already downloading
backend/src/services/podcastDownload.ts:146:    if (downloadingEpisodes.has(episodeId)) {
backend/src/services/podcastDownload.ts:147:        console.log(`[PODCAST-DL] Already downloading episode ${episodeId}, skipping`);
backend/src/services/podcastDownload.ts:151:    // Mark as downloading
backend/src/services/podcastDownload.ts:152:    downloadingEpisodes.add(episodeId);
backend/src/services/podcastDownload.ts:154:    // Start download in background (don't await)
backend/src/services/podcastDownload.ts:155:    performDownload(episodeId, audioUrl, userId)
backend/src/services/podcastDownload.ts:157:            console.error(`[PODCAST-DL] Background download failed for ${episodeId}:`, err.message);
backend/src/services/podcastDownload.ts:160:            downloadingEpisodes.delete(episodeId);
backend/src/services/podcastDownload.ts:165: * Perform the actual download with retry support
backend/src/services/podcastDownload.ts:167:async function performDownload(
backend/src/services/podcastDownload.ts:174:    console.log(`[PODCAST-DL] Starting background download for episode ${episodeId} (attempt ${attempt}/${maxAttempts})`);
backend/src/services/podcastDownload.ts:186:        downloadingEpisodes.delete(episodeId); // Temporarily remove to check cache
backend/src/services/podcastDownload.ts:188:        downloadingEpisodes.add(episodeId); // Re-add
backend/src/services/podcastDownload.ts:190:            console.log(`[PODCAST-DL] Episode ${episodeId} already cached, skipping download`);
backend/src/services/podcastDownload.ts:197:        // Download the file with longer timeout for large podcasts
backend/src/services/podcastDownload.ts:251:            `[PODCAST-DL] Downloading ${episodeId} (${expectedBytes > 0 ? Math.round(expectedBytes / 1024 / 1024) : 0}MB)`
backend/src/services/podcastDownload.ts:255:        downloadProgress.set(episodeId, {
backend/src/services/podcastDownload.ts:256:            bytesDownloaded: 0,
backend/src/services/podcastDownload.ts:262:        let bytesDownloaded = 0;
backend/src/services/podcastDownload.ts:267:                bytesDownloaded += chunk.length;
backend/src/services/podcastDownload.ts:268:                downloadProgress.set(episodeId, { bytesDownloaded, totalBytes: contentLength });
backend/src/services/podcastDownload.ts:270:                // Log progress every 30 seconds for long downloads
backend/src/services/podcastDownload.ts:273:                    const percent = contentLength > 0 ? Math.round((bytesDownloaded / contentLength) * 100) : 0;
backend/src/services/podcastDownload.ts:274:                    console.log(`[PODCAST-DL] Download progress ${episodeId}: ${percent}% (${Math.round(bytesDownloaded / 1024 / 1024)}MB)`);
backend/src/services/podcastDownload.ts:298:                reject(new Error('Download aborted by server'));
backend/src/services/podcastDownload.ts:306:            throw new Error('Downloaded file is empty');
backend/src/services/podcastDownload.ts:315:            console.error(`[PODCAST-DL] Incomplete download for ${episodeId}: ${stats.size}/${expectedBytes} bytes (${percentComplete}%)`);
backend/src/services/podcastDownload.ts:317:            throw new Error(`Download incomplete: got ${stats.size} bytes, expected ${expectedBytes}`);
backend/src/services/podcastDownload.ts:327:        await prisma.podcastDownload.upsert({
backend/src/services/podcastDownload.ts:336:                downloadedAt: new Date(),
backend/src/services/podcastDownload.ts:342:                downloadedAt: new Date(),
backend/src/services/podcastDownload.ts:350:        downloadProgress.delete(episodeId);
backend/src/services/podcastDownload.ts:355:        downloadProgress.delete(episodeId);
backend/src/services/podcastDownload.ts:359:            console.log(`[PODCAST-DL] Download failed (attempt ${attempt}), retrying in 5s: ${error.message}`);
backend/src/services/podcastDownload.ts:361:            return performDownload(episodeId, audioUrl, userId, attempt + 1);
backend/src/services/podcastDownload.ts:378:    // Find expired downloads
backend/src/services/podcastDownload.ts:379:    const expiredDownloads = await prisma.podcastDownload.findMany({
backend/src/services/podcastDownload.ts:388:    for (const download of expiredDownloads) {
backend/src/services/podcastDownload.ts:391:            await fs.unlink(download.localPath).catch(() => {});
backend/src/services/podcastDownload.ts:394:            await prisma.podcastDownload.delete({
backend/src/services/podcastDownload.ts:395:                where: { id: download.id }
backend/src/services/podcastDownload.ts:399:            freedMb += download.fileSizeMb;
backend/src/services/podcastDownload.ts:401:            console.log(`[PODCAST-DL] Deleted expired cache: ${path.basename(download.localPath)}`);
backend/src/services/podcastDownload.ts:403:            console.error(`[PODCAST-DL] Failed to delete ${download.localPath}:`, err.message);
backend/src/services/podcastDownload.ts:420:    const downloads = await prisma.podcastDownload.findMany({
backend/src/services/podcastDownload.ts:423:            downloadedAt: true
backend/src/services/podcastDownload.ts:425:        orderBy: { downloadedAt: 'asc' }
backend/src/services/podcastDownload.ts:429:        totalFiles: downloads.length,
backend/src/services/podcastDownload.ts:430:        totalSizeMb: downloads.reduce((sum, d) => sum + d.fileSizeMb, 0),
backend/src/services/podcastDownload.ts:431:        oldestFile: downloads.length > 0 ? downloads[0].downloadedAt : null
backend/src/services/podcastDownload.ts:436: * Check if an episode is currently being downloaded
backend/src/services/podcastDownload.ts:438:export function isDownloading(episodeId: string): boolean {
backend/src/services/podcastDownload.ts:439:    return downloadingEpisodes.has(episodeId);
backend/src/services/downloadQueue.ts:1:interface DownloadInfo {
backend/src/services/downloadQueue.ts:2:    downloadId: string;
backend/src/services/downloadQueue.ts:26:class DownloadQueueManager {
backend/src/services/downloadQueue.ts:27:    private activeDownloads = new Map<string, DownloadInfo>();
backend/src/services/downloadQueue.ts:36:        // Start periodic cleanup of stale downloads (every 5 minutes)
backend/src/services/downloadQueue.ts:38:            this.cleanupStaleDownloads();
backend/src/services/downloadQueue.ts:43:     * Track a new download
backend/src/services/downloadQueue.ts:45:    addDownload(
backend/src/services/downloadQueue.ts:46:        downloadId: string,
backend/src/services/downloadQueue.ts:59:        const info: DownloadInfo = {
backend/src/services/downloadQueue.ts:60:            downloadId,
backend/src/services/downloadQueue.ts:74:        this.activeDownloads.set(downloadId, info);
backend/src/services/downloadQueue.ts:76:            `[DOWNLOAD] Started: "${albumTitle}" by ${artistName} (${downloadId})`
backend/src/services/downloadQueue.ts:79:        console.log(`   Active downloads: ${this.activeDownloads.size}`);
backend/src/services/downloadQueue.ts:81:        // Persist Lidarr download reference to download job for later status updates
backend/src/services/downloadQueue.ts:82:        this.linkDownloadJob(downloadId, albumMbid).catch((error) => {
backend/src/services/downloadQueue.ts:83:            console.error(` linkDownloadJob error:`, error);
backend/src/services/downloadQueue.ts:86:        // Start timeout on first download
backend/src/services/downloadQueue.ts:87:        if (this.activeDownloads.size === 1 && !this.timeoutTimer) {
backend/src/services/downloadQueue.ts:107:     * Mark download as complete
backend/src/services/downloadQueue.ts:109:    async completeDownload(downloadId: string, albumTitle: string) {
backend/src/services/downloadQueue.ts:110:        this.activeDownloads.delete(downloadId);
backend/src/services/downloadQueue.ts:111:        console.log(`Download complete: "${albumTitle}" (${downloadId})`);
backend/src/services/downloadQueue.ts:112:        console.log(`   Remaining downloads: ${this.activeDownloads.size}`);
backend/src/services/downloadQueue.ts:114:        // If no more downloads, trigger refresh immediately
backend/src/services/downloadQueue.ts:115:        if (this.activeDownloads.size === 0) {
backend/src/services/downloadQueue.ts:116:            console.log(`⏰ All downloads complete! Starting refresh now...`);
backend/src/services/downloadQueue.ts:123:     * Mark download as failed and optionally retry
backend/src/services/downloadQueue.ts:125:    async failDownload(downloadId: string, reason: string) {
backend/src/services/downloadQueue.ts:126:        const info = this.activeDownloads.get(downloadId);
backend/src/services/downloadQueue.ts:129:                `  Download ${downloadId} not tracked, ignoring failure`
backend/src/services/downloadQueue.ts:134:        console.log(` Download failed: "${info.albumTitle}" (${downloadId})`);
backend/src/services/downloadQueue.ts:141:            console.log(`    Retrying download... (attempt ${info.attempts})`);
backend/src/services/downloadQueue.ts:142:            await this.retryDownload(info);
backend/src/services/downloadQueue.ts:146:            this.activeDownloads.delete(downloadId);
backend/src/services/downloadQueue.ts:148:            // Check if all downloads are done
backend/src/services/downloadQueue.ts:149:            if (this.activeDownloads.size === 0) {
backend/src/services/downloadQueue.ts:151:                    `⏰ All downloads finished (some failed). Starting refresh...`
backend/src/services/downloadQueue.ts:160:     * Retry a failed download by triggering Lidarr album search
backend/src/services/downloadQueue.ts:162:    private async retryDownload(info: DownloadInfo) {
backend/src/services/downloadQueue.ts:207:    private async cleanupFailedAlbum(info: DownloadInfo) {
backend/src/services/downloadQueue.ts:311:     * Start timeout to trigger scan after X minutes even if downloads are still pending
backend/src/services/downloadQueue.ts:320:            if (this.activeDownloads.size > 0) {
backend/src/services/downloadQueue.ts:322:                    `\n  Timeout reached! ${this.activeDownloads.size} downloads still pending.`
backend/src/services/downloadQueue.ts:324:                console.log(`   These downloads never completed:`);
backend/src/services/downloadQueue.ts:326:                // Mark each pending download as failed to trigger callbacks
backend/src/services/downloadQueue.ts:327:                for (const [downloadId, info] of this.activeDownloads) {
backend/src/services/downloadQueue.ts:332:                    this.failDownload(
backend/src/services/downloadQueue.ts:333:                        downloadId,
backend/src/services/downloadQueue.ts:334:                        "Download timeout - never completed"
backend/src/services/downloadQueue.ts:337:                            `Error failing download ${downloadId}:`,
backend/src/services/downloadQueue.ts:344:                    `   Triggering scan anyway to process completed downloads...\n`
backend/src/services/downloadQueue.ts:429:                    item.trackedDownloadStatus === "warning" ||
backend/src/services/downloadQueue.ts:430:                    item.trackedDownloadStatus === "error" ||
backend/src/services/downloadQueue.ts:516:                source: "download-queue",
backend/src/services/downloadQueue.ts:532:            activeDownloads: this.activeDownloads.size,
backend/src/services/downloadQueue.ts:533:            downloads: Array.from(this.activeDownloads.values()),
backend/src/services/downloadQueue.ts:539:     * Get the active downloads map (for checking if a download is being tracked)
backend/src/services/downloadQueue.ts:541:    getActiveDownloads() {
backend/src/services/downloadQueue.ts:542:        return this.activeDownloads;
backend/src/services/downloadQueue.ts:554:     * Clean up stale downloads that have been active for too long
backend/src/services/downloadQueue.ts:555:     * This prevents the activeDownloads Map from growing unbounded
backend/src/services/downloadQueue.ts:557:    cleanupStaleDownloads(): number {
backend/src/services/downloadQueue.ts:561:        for (const [downloadId, info] of this.activeDownloads) {
backend/src/services/downloadQueue.ts:565:                    `[CLEANUP] Cleaning up stale download: "${
backend/src/services/downloadQueue.ts:567:                    }" (${downloadId}) - age: ${Math.round(
backend/src/services/downloadQueue.ts:571:                this.activeDownloads.delete(downloadId);
backend/src/services/downloadQueue.ts:578:                `[CLEANUP] Cleaned up ${cleanedCount} stale download(s)`
backend/src/services/downloadQueue.ts:586:     * Shutdown the download queue manager (cleanup resources)
backend/src/services/downloadQueue.ts:594:        this.activeDownloads.clear();
backend/src/services/downloadQueue.ts:595:        console.log("Download queue manager shutdown");
backend/src/services/downloadQueue.ts:599:     * Link Lidarr download IDs to download jobs (so we can mark them completed later)
backend/src/services/downloadQueue.ts:601:    private async linkDownloadJob(downloadId: string, albumMbid: string) {
backend/src/services/downloadQueue.ts:603:            `   [LINK] Attempting to link download job for MBID: ${albumMbid}`
backend/src/services/downloadQueue.ts:609:            const existingJobs = await prisma.downloadJob.findMany({
backend/src/services/downloadQueue.ts:623:            const result = await prisma.downloadJob.updateMany({
backend/src/services/downloadQueue.ts:630:                    lidarrRef: downloadId,
backend/src/services/downloadQueue.ts:637:                    `     No matching download jobs found to link with Lidarr ID ${downloadId}`
backend/src/services/downloadQueue.ts:644:                    `   Linked Lidarr download ${downloadId} to ${result.count} download job(s)`
backend/src/services/downloadQueue.ts:649:                ` Failed to persist Lidarr download link:`,
backend/src/services/downloadQueue.ts:658:export const downloadQueueManager = new DownloadQueueManager();
backend/src/services/spotify.ts:4: * Spotify Service
backend/src/services/spotify.ts:6: * Fetches public playlist data from Spotify using anonymous tokens.
backend/src/services/spotify.ts:7: * No API credentials required - uses Spotify's web player token endpoint.
backend/src/services/spotify.ts:10:export interface SpotifyTrack {
backend/src/services/spotify.ts:11:    spotifyId: string;
backend/src/services/spotify.ts:24:export interface SpotifyPlaylist {
backend/src/services/spotify.ts:31:    tracks: SpotifyTrack[];
backend/src/services/spotify.ts:35:export interface SpotifyAlbum {
backend/src/services/spotify.ts:45:export interface SpotifyPlaylistPreview {
backend/src/services/spotify.ts:55:const SPOTIFY_PLAYLIST_REGEX = /(?:spotify\.com\/playlist\/|spotify:playlist:)([a-zA-Z0-9]+)/;
backend/src/services/spotify.ts:56:const SPOTIFY_ALBUM_REGEX = /(?:spotify\.com\/album\/|spotify:album:)([a-zA-Z0-9]+)/;
backend/src/services/spotify.ts:57:const SPOTIFY_TRACK_REGEX = /(?:spotify\.com\/track\/|spotify:track:)([a-zA-Z0-9]+)/;
backend/src/services/spotify.ts:59:class SpotifyService {
backend/src/services/spotify.ts:64:     * Get anonymous access token from Spotify web player
backend/src/services/spotify.ts:76:                url: "https://open.spotify.com/get_access_token",
backend/src/services/spotify.ts:80:                url: "https://open.spotify.com/get_access_token",
backend/src/services/spotify.ts:87:                console.log(`Spotify: Fetching anonymous token from ${endpoint.url}...`);
backend/src/services/spotify.ts:95:                        "Origin": "https://open.spotify.com",
backend/src/services/spotify.ts:96:                        "Referer": "https://open.spotify.com/",
backend/src/services/spotify.ts:107:                    console.log("Spotify: Got anonymous token");
backend/src/services/spotify.ts:111:                console.log(`Spotify: Token endpoint failed (${error.response?.status || error.message})`);
backend/src/services/spotify.ts:115:        console.error("Spotify: All token endpoints failed - API browsing unavailable");
backend/src/services/spotify.ts:120:     * Parse a Spotify URL and extract the type and ID
backend/src/services/spotify.ts:122:    parseUrl(url: string): { type: "playlist" | "album" | "track"; id: string } | null {
backend/src/services/spotify.ts:123:        const playlistMatch = url.match(SPOTIFY_PLAYLIST_REGEX);
backend/src/services/spotify.ts:124:        if (playlistMatch) {
backend/src/services/spotify.ts:125:            return { type: "playlist", id: playlistMatch[1] };
backend/src/services/spotify.ts:128:        const albumMatch = url.match(SPOTIFY_ALBUM_REGEX);
backend/src/services/spotify.ts:133:        const trackMatch = url.match(SPOTIFY_TRACK_REGEX);
backend/src/services/spotify.ts:142:     * Fetch playlist via anonymous token
backend/src/services/spotify.ts:144:    private async fetchPlaylistViaAnonymousApi(playlistId: string): Promise<SpotifyPlaylist | null> {
backend/src/services/spotify.ts:147:            return await this.fetchPlaylistViaEmbedHtml(playlistId);
backend/src/services/spotify.ts:151:            console.log(`Spotify: Fetching playlist ${playlistId}...`);
backend/src/services/spotify.ts:153:            const playlistResponse = await axios.get(
backend/src/services/spotify.ts:154:                `https://api.spotify.com/v1/playlists/${playlistId}`,
backend/src/services/spotify.ts:167:            const playlist = playlistResponse.data;
backend/src/services/spotify.ts:168:            console.log(`Spotify: Fetched playlist "${playlist.name}" with ${playlist.tracks?.items?.length || 0} tracks`);
backend/src/services/spotify.ts:170:            const tracks: SpotifyTrack[] = [];
backend/src/services/spotify.ts:172:            for (const item of playlist.tracks?.items || []) {
backend/src/services/spotify.ts:183:                    console.log(`Spotify: Track "${track.name}" has no album data:`, JSON.stringify({
backend/src/services/spotify.ts:192:                    spotifyId: track.id,
backend/src/services/spotify.ts:206:            console.log(`Spotify: Processed ${tracks.length} tracks`);
backend/src/services/spotify.ts:209:                id: playlist.id,
backend/src/services/spotify.ts:210:                name: playlist.name,
backend/src/services/spotify.ts:211:                description: playlist.description,
backend/src/services/spotify.ts:212:                owner: playlist.owner?.display_name || "Unknown",
backend/src/services/spotify.ts:213:                imageUrl: playlist.images?.[0]?.url || null,
backend/src/services/spotify.ts:214:                trackCount: playlist.tracks?.total || tracks.length,
backend/src/services/spotify.ts:216:                isPublic: playlist.public ?? true,
backend/src/services/spotify.ts:219:            console.error("Spotify API error:", error.response?.status, error.response?.data || error.message);
backend/src/services/spotify.ts:222:            return await this.fetchPlaylistViaEmbedHtml(playlistId);
backend/src/services/spotify.ts:229:    private async fetchPlaylistViaEmbedHtml(playlistId: string): Promise<SpotifyPlaylist | null> {
backend/src/services/spotify.ts:231:            console.log("Spotify: Trying embed HTML parsing...");
backend/src/services/spotify.ts:234:                `https://open.spotify.com/embed/playlist/${playlistId}`,
backend/src/services/spotify.ts:247:                console.error("Spotify: Could not find __NEXT_DATA__ in embed HTML");
backend/src/services/spotify.ts:253:            const playlistData = data.props?.pageProps?.state?.data?.entity 
backend/src/services/spotify.ts:257:            if (!playlistData) {
backend/src/services/spotify.ts:258:                console.error("Spotify: Could not find playlist data in embed JSON");
backend/src/services/spotify.ts:262:            const tracks: SpotifyTrack[] = [];
backend/src/services/spotify.ts:263:            const trackList = playlistData.trackList || playlistData.tracks?.items || [];
backend/src/services/spotify.ts:281:                    console.log(`Spotify Embed: Track "${trackData.title || trackData.name}" has no album data:`, JSON.stringify({
backend/src/services/spotify.ts:289:                    spotifyId: trackData.uri?.split(":")[2] || trackData.id || "",
backend/src/services/spotify.ts:304:                id: playlistId,
backend/src/services/spotify.ts:305:                name: playlistData.name || "Unknown Playlist",
backend/src/services/spotify.ts:306:                description: playlistData.description || null,
backend/src/services/spotify.ts:307:                owner: playlistData.ownerV2?.data?.name || playlistData.owner?.display_name || "Unknown",
backend/src/services/spotify.ts:308:                imageUrl: playlistData.images?.items?.[0]?.sources?.[0]?.url || playlistData.images?.[0]?.url || null,
backend/src/services/spotify.ts:314:            console.error("Spotify embed HTML error:", error.message);
backend/src/services/spotify.ts:320:     * Fetch a playlist by ID or URL
backend/src/services/spotify.ts:322:    async getPlaylist(urlOrId: string): Promise<SpotifyPlaylist | null> {
backend/src/services/spotify.ts:324:        let playlistId = urlOrId;
backend/src/services/spotify.ts:327:            if (parsed.type !== "playlist") {
backend/src/services/spotify.ts:328:                throw new Error(`Expected playlist URL, got ${parsed.type}`);
backend/src/services/spotify.ts:330:            playlistId = parsed.id;
backend/src/services/spotify.ts:333:        console.log("Spotify: Fetching public playlist via anonymous token");
backend/src/services/spotify.ts:334:        return await this.fetchPlaylistViaAnonymousApi(playlistId);
backend/src/services/spotify.ts:338:     * Get featured/popular playlists from Spotify
backend/src/services/spotify.ts:341:    async getFeaturedPlaylists(limit: number = 20): Promise<SpotifyPlaylistPreview[]> {
backend/src/services/spotify.ts:344:            console.error("Spotify: Cannot fetch featured playlists without token");
backend/src/services/spotify.ts:350:            console.log("Spotify: Trying featured playlists via official API...");
backend/src/services/spotify.ts:353:                "https://api.spotify.com/v1/browse/featured-playlists",
backend/src/services/spotify.ts:367:            const playlists = response.data?.playlists?.items || [];
backend/src/services/spotify.ts:368:            if (playlists.length > 0) {
backend/src/services/spotify.ts:369:                console.log(`Spotify: Got ${playlists.length} featured playlists via official API`);
backend/src/services/spotify.ts:370:                return playlists.map((playlist: any) => ({
backend/src/services/spotify.ts:371:                    id: playlist.id,
backend/src/services/spotify.ts:372:                    name: playlist.name,
backend/src/services/spotify.ts:373:                    description: playlist.description || null,
backend/src/services/spotify.ts:374:                    owner: playlist.owner?.display_name || "Spotify",
backend/src/services/spotify.ts:375:                    imageUrl: playlist.images?.[0]?.url || null,
backend/src/services/spotify.ts:376:                    trackCount: playlist.tracks?.total || 0,
backend/src/services/spotify.ts:380:            console.log("Spotify: Featured playlists API failed, trying search fallback...", error.response?.status || error.message);
backend/src/services/spotify.ts:383:        // Fallback: Search for popular playlists
backend/src/services/spotify.ts:385:            console.log("Spotify: Trying search fallback for featured playlists...");
backend/src/services/spotify.ts:387:            // Search for popular/curated playlists
backend/src/services/spotify.ts:389:            const allPlaylists: SpotifyPlaylistPreview[] = [];
backend/src/services/spotify.ts:392:                const results = await this.searchPlaylists(query, 5);
backend/src/services/spotify.ts:393:                // Filter to only include Spotify-owned playlists
backend/src/services/spotify.ts:394:                const spotifyOwned = results.filter(p => 
backend/src/services/spotify.ts:395:                    p.owner.toLowerCase() === "spotify" || 
backend/src/services/spotify.ts:396:                    p.owner.toLowerCase().includes("spotify")
backend/src/services/spotify.ts:398:                allPlaylists.push(...spotifyOwned);
backend/src/services/spotify.ts:400:                if (allPlaylists.length >= limit) break;
backend/src/services/spotify.ts:403:            console.log(`Spotify: Got ${allPlaylists.length} playlists via search fallback`);
backend/src/services/spotify.ts:404:            return allPlaylists.slice(0, limit);
backend/src/services/spotify.ts:406:            console.error("Spotify: Search fallback also failed:", searchError.message);
backend/src/services/spotify.ts:412:     * Get playlists by category
backend/src/services/spotify.ts:414:    async getCategoryPlaylists(categoryId: string, limit: number = 20): Promise<SpotifyPlaylistPreview[]> {
backend/src/services/spotify.ts:421:            console.log(`Spotify: Fetching playlists for category ${categoryId}...`);
backend/src/services/spotify.ts:424:                `https://api.spotify.com/v1/browse/categories/${categoryId}/playlists`,
backend/src/services/spotify.ts:438:            const playlists = response.data?.playlists?.items || [];
backend/src/services/spotify.ts:439:            return playlists.map((playlist: any) => ({
backend/src/services/spotify.ts:440:                id: playlist.id,
backend/src/services/spotify.ts:441:                name: playlist.name,
backend/src/services/spotify.ts:442:                description: playlist.description || null,
backend/src/services/spotify.ts:443:                owner: playlist.owner?.display_name || "Spotify",
backend/src/services/spotify.ts:444:                imageUrl: playlist.images?.[0]?.url || null,
backend/src/services/spotify.ts:445:                trackCount: playlist.tracks?.total || 0,
backend/src/services/spotify.ts:448:            console.error(`Spotify category playlists error for ${categoryId}:`, error.message);
backend/src/services/spotify.ts:454:     * Search for playlists on Spotify
backend/src/services/spotify.ts:456:    async searchPlaylists(query: string, limit: number = 20): Promise<SpotifyPlaylistPreview[]> {
backend/src/services/spotify.ts:459:            console.error("Spotify: Cannot search without token");
backend/src/services/spotify.ts:464:            console.log(`Spotify: Searching playlists for "${query}"...`);
backend/src/services/spotify.ts:467:                "https://api.spotify.com/v1/search",
backend/src/services/spotify.ts:476:                        type: "playlist",
backend/src/services/spotify.ts:484:            const playlists = response.data?.playlists?.items || [];
backend/src/services/spotify.ts:485:            console.log(`Spotify: Found ${playlists.length} playlists for "${query}"`);
backend/src/services/spotify.ts:487:            return playlists
backend/src/services/spotify.ts:488:                .filter((playlist: any) => playlist && playlist.id) // Filter out null entries
backend/src/services/spotify.ts:489:                .map((playlist: any) => ({
backend/src/services/spotify.ts:490:                    id: playlist.id,
backend/src/services/spotify.ts:491:                    name: playlist.name,
backend/src/services/spotify.ts:492:                    description: playlist.description || null,
backend/src/services/spotify.ts:493:                    owner: playlist.owner?.display_name || "Unknown",
backend/src/services/spotify.ts:494:                    imageUrl: playlist.images?.[0]?.url || null,
backend/src/services/spotify.ts:495:                    trackCount: playlist.tracks?.total || 0,
backend/src/services/spotify.ts:498:            console.error("Spotify search playlists error:", error.response?.status, error.response?.data || error.message);
backend/src/services/spotify.ts:501:                console.log("Spotify: Token expired, refreshing...");
backend/src/services/spotify.ts:508:                            "https://api.spotify.com/v1/search",
backend/src/services/spotify.ts:514:                                params: { q: query, type: "playlist", limit, market: "US" },
backend/src/services/spotify.ts:518:                        const retryPlaylists = retryResponse.data?.playlists?.items || [];
backend/src/services/spotify.ts:519:                        return retryPlaylists
backend/src/services/spotify.ts:530:                        console.error("Spotify: Retry also failed");
backend/src/services/spotify.ts:549:                "https://api.spotify.com/v1/browse/categories",
backend/src/services/spotify.ts:569:            console.error("Spotify categories error:", error.message);
backend/src/services/spotify.ts:575:export const spotifyService = new SpotifyService();
backend/src/services/deezer.ts:6: * Deezer Service
backend/src/services/deezer.ts:8: * Fetches images, previews, and public playlist data from Deezer.
backend/src/services/deezer.ts:9: * No authentication required - Deezer's API is completely public.
backend/src/services/deezer.ts:12:const DEEZER_API = "https://api.deezer.com";
backend/src/services/deezer.ts:15:// Playlist Types
backend/src/services/deezer.ts:18:export interface DeezerTrack {
backend/src/services/deezer.ts:19:    deezerId: string;
backend/src/services/deezer.ts:30:export interface DeezerPlaylist {
backend/src/services/deezer.ts:37:    tracks: DeezerTrack[];
backend/src/services/deezer.ts:41:export interface DeezerPlaylistPreview {
backend/src/services/deezer.ts:51:export interface DeezerRadioStation {
backend/src/services/deezer.ts:59:export interface DeezerGenre {
backend/src/services/deezer.ts:65:export interface DeezerGenreWithRadios {
backend/src/services/deezer.ts:68:    radios: DeezerRadioStation[];
backend/src/services/deezer.ts:75:class DeezerService {
backend/src/services/deezer.ts:76:    private readonly cachePrefix = "deezer:";
backend/src/services/deezer.ts:115:            const response = await axios.get(`${DEEZER_API}/search/artist`, {
backend/src/services/deezer.ts:126:            console.error(`Deezer artist image error for ${artistName}:`, error.message);
backend/src/services/deezer.ts:142:            const response = await axios.get(`${DEEZER_API}/search/artist`, {
backend/src/services/deezer.ts:169:            console.error(`Deezer artist image (strict) error for ${artistName}:`, error.message);
backend/src/services/deezer.ts:185:            const response = await axios.get(`${DEEZER_API}/search/album`, {
backend/src/services/deezer.ts:207:            console.error(`Deezer album cover error for ${artistName} - ${albumName}:`, error.message);
backend/src/services/deezer.ts:225:        // Normalize quotes for Deezer compatibility (MusicBrainz uses curly quotes)
backend/src/services/deezer.ts:241:            const response = await axios.get(`${DEEZER_API}/search/track`, {
backend/src/services/deezer.ts:261:            console.error(`Deezer track preview error for ${artistName} - ${trackName}:`, error.message);
backend/src/services/deezer.ts:267:    // Playlist Methods (new functionality)
backend/src/services/deezer.ts:271:     * Parse a Deezer URL and extract the type and ID
backend/src/services/deezer.ts:273:    parseUrl(url: string): { type: "playlist" | "album" | "track"; id: string } | null {
backend/src/services/deezer.ts:274:        const playlistMatch = url.match(/deezer\.com\/(?:[a-z]{2}\/)?playlist\/(\d+)/);
backend/src/services/deezer.ts:275:        if (playlistMatch) {
backend/src/services/deezer.ts:276:            return { type: "playlist", id: playlistMatch[1] };
backend/src/services/deezer.ts:279:        const albumMatch = url.match(/deezer\.com\/(?:[a-z]{2}\/)?album\/(\d+)/);
backend/src/services/deezer.ts:284:        const trackMatch = url.match(/deezer\.com\/(?:[a-z]{2}\/)?track\/(\d+)/);
backend/src/services/deezer.ts:293:     * Fetch a playlist by ID
backend/src/services/deezer.ts:295:    async getPlaylist(playlistId: string): Promise<DeezerPlaylist | null> {
backend/src/services/deezer.ts:297:            console.log(`Deezer: Fetching playlist ${playlistId}...`);
backend/src/services/deezer.ts:299:            const response = await axios.get(`${DEEZER_API}/playlist/${playlistId}`, {
backend/src/services/deezer.ts:305:                console.error("Deezer API error:", data.error);
backend/src/services/deezer.ts:309:            const tracks: DeezerTrack[] = (data.tracks?.data || []).map((track: any) => ({
backend/src/services/deezer.ts:310:                deezerId: String(track.id),
backend/src/services/deezer.ts:321:            console.log(`Deezer: Fetched playlist "${data.title}" with ${tracks.length} tracks`);
backend/src/services/deezer.ts:325:                title: data.title || "Unknown Playlist",
backend/src/services/deezer.ts:334:            console.error("Deezer playlist fetch error:", error.message);
backend/src/services/deezer.ts:340:     * Get chart playlists (top playlists)
backend/src/services/deezer.ts:342:    async getChartPlaylists(limit: number = 20): Promise<DeezerPlaylistPreview[]> {
backend/src/services/deezer.ts:344:            const response = await axios.get(`${DEEZER_API}/chart/0/playlists`, {
backend/src/services/deezer.ts:349:            return (response.data?.data || []).map((playlist: any) => ({
backend/src/services/deezer.ts:350:                id: String(playlist.id),
backend/src/services/deezer.ts:351:                title: playlist.title || "Unknown",
backend/src/services/deezer.ts:353:                creator: playlist.user?.name || "Deezer",
backend/src/services/deezer.ts:354:                imageUrl: playlist.picture_medium || playlist.picture || null,
backend/src/services/deezer.ts:355:                trackCount: playlist.nb_tracks || 0,
backend/src/services/deezer.ts:356:                fans: playlist.fans || 0,
backend/src/services/deezer.ts:359:            console.error("Deezer chart playlists error:", error.message);
backend/src/services/deezer.ts:365:     * Search for playlists
backend/src/services/deezer.ts:367:    async searchPlaylists(query: string, limit: number = 20): Promise<DeezerPlaylistPreview[]> {
backend/src/services/deezer.ts:369:            const response = await axios.get(`${DEEZER_API}/search/playlist`, {
backend/src/services/deezer.ts:374:            return (response.data?.data || []).map((playlist: any) => ({
backend/src/services/deezer.ts:375:                id: String(playlist.id),
backend/src/services/deezer.ts:376:                title: playlist.title || "Unknown",
backend/src/services/deezer.ts:378:                creator: playlist.user?.name || "Unknown",
backend/src/services/deezer.ts:379:                imageUrl: playlist.picture_medium || playlist.picture || null,
backend/src/services/deezer.ts:380:                trackCount: playlist.nb_tracks || 0,
backend/src/services/deezer.ts:384:            console.error("Deezer playlist search error:", error.message);
backend/src/services/deezer.ts:390:     * Get featured/curated playlists from multiple sources
backend/src/services/deezer.ts:391:     * Combines chart playlists with popular genre-based searches
backend/src/services/deezer.ts:394:    async getFeaturedPlaylists(limit: number = 50): Promise<DeezerPlaylistPreview[]> {
backend/src/services/deezer.ts:395:        const cacheKey = `playlists:featured:${limit}`;
backend/src/services/deezer.ts:398:            console.log("Deezer: Returning cached featured playlists");
backend/src/services/deezer.ts:403:            const allPlaylists: DeezerPlaylistPreview[] = [];
backend/src/services/deezer.ts:406:            // 1. Get chart playlists (max 99 available)
backend/src/services/deezer.ts:407:            console.log("Deezer: Fetching chart playlists from API...");
backend/src/services/deezer.ts:408:            const chartPlaylists = await this.getChartPlaylists(Math.min(limit, 99));
backend/src/services/deezer.ts:409:            for (const p of chartPlaylists) {
backend/src/services/deezer.ts:412:                    allPlaylists.push(p);
backend/src/services/deezer.ts:415:            console.log(`Deezer: Got ${chartPlaylists.length} chart playlists`);
backend/src/services/deezer.ts:417:            // 2. If we need more, search for popular genre playlists
backend/src/services/deezer.ts:418:            if (allPlaylists.length < limit) {
backend/src/services/deezer.ts:422:                    if (allPlaylists.length >= limit) break;
backend/src/services/deezer.ts:425:                        const genrePlaylists = await this.searchPlaylists(genre, 10);
backend/src/services/deezer.ts:426:                        for (const p of genrePlaylists) {
backend/src/services/deezer.ts:427:                            if (!seenIds.has(p.id) && allPlaylists.length < limit) {
backend/src/services/deezer.ts:429:                                allPlaylists.push(p);
backend/src/services/deezer.ts:438:            const result = allPlaylists.slice(0, limit);
backend/src/services/deezer.ts:439:            console.log(`Deezer: Caching ${result.length} featured playlists`);
backend/src/services/deezer.ts:443:            console.error("Deezer featured playlists error:", error.message);
backend/src/services/deezer.ts:449:     * Get genres/categories available on Deezer
backend/src/services/deezer.ts:452:     * Get genres/categories available on Deezer
backend/src/services/deezer.ts:459:            console.log("Deezer: Returning cached genres");
backend/src/services/deezer.ts:464:            console.log("Deezer: Fetching genres from API...");
backend/src/services/deezer.ts:465:            const response = await axios.get(`${DEEZER_API}/genre`, {
backend/src/services/deezer.ts:477:            console.log(`Deezer: Caching ${genres.length} genres`);
backend/src/services/deezer.ts:481:            console.error("Deezer genres error:", error.message);
backend/src/services/deezer.ts:487:     * Get playlists for a specific genre by searching
backend/src/services/deezer.ts:489:    async getGenrePlaylists(genreName: string, limit: number = 20): Promise<DeezerPlaylistPreview[]> {
backend/src/services/deezer.ts:490:        return this.searchPlaylists(genreName, limit);
backend/src/services/deezer.ts:501:    async getRadioStations(): Promise<DeezerRadioStation[]> {
backend/src/services/deezer.ts:505:            console.log("Deezer: Returning cached radio stations");
backend/src/services/deezer.ts:510:            console.log("Deezer: Fetching radio stations from API...");
backend/src/services/deezer.ts:511:            const response = await axios.get(`${DEEZER_API}/radio`, {
backend/src/services/deezer.ts:523:            console.log(`Deezer: Got ${stations.length} radio stations, caching...`);
backend/src/services/deezer.ts:527:            console.error("Deezer radio stations error:", error.message);
backend/src/services/deezer.ts:539:    async getRadiosByGenre(): Promise<DeezerGenreWithRadios[]> {
backend/src/services/deezer.ts:543:            console.log("Deezer: Returning cached radios by genre");
backend/src/services/deezer.ts:548:            console.log("Deezer: Fetching radios by genre from API...");
backend/src/services/deezer.ts:549:            const response = await axios.get(`${DEEZER_API}/radio/genres`, {
backend/src/services/deezer.ts:565:            console.log(`Deezer: Got ${genres.length} genre categories with radios, caching...`);
backend/src/services/deezer.ts:569:            console.error("Deezer radios by genre error:", error.message);
backend/src/services/deezer.ts:575:     * Get tracks from a radio station (returns as DeezerPlaylist for consistency)
backend/src/services/deezer.ts:577:    async getRadioTracks(radioId: string): Promise<DeezerPlaylist | null> {
backend/src/services/deezer.ts:579:            console.log(`Deezer: Fetching radio ${radioId} tracks...`);
backend/src/services/deezer.ts:582:            const infoResponse = await axios.get(`${DEEZER_API}/radio/${radioId}`, {
backend/src/services/deezer.ts:588:            const tracksResponse = await axios.get(`${DEEZER_API}/radio/${radioId}/tracks`, {
backend/src/services/deezer.ts:593:            const tracks: DeezerTrack[] = (tracksResponse.data?.data || []).map((track: any) => ({
backend/src/services/deezer.ts:594:                deezerId: String(track.id),
backend/src/services/deezer.ts:605:            console.log(`Deezer: Fetched radio "${radioInfo.title}" with ${tracks.length} tracks`);
backend/src/services/deezer.ts:610:                description: `Deezer Radio - ${radioInfo.title}`,
backend/src/services/deezer.ts:611:                creator: "Deezer",
backend/src/services/deezer.ts:618:            console.error("Deezer radio tracks error:", error.message);
backend/src/services/deezer.ts:625:     * Returns releases and playlists for that genre
backend/src/services/deezer.ts:628:        playlists: DeezerPlaylistPreview[];
backend/src/services/deezer.ts:629:        radios: DeezerRadioStation[];
backend/src/services/deezer.ts:632:            // Get genre-specific playlists via search
backend/src/services/deezer.ts:633:            const genreResponse = await axios.get(`${DEEZER_API}/genre/${genreId}`, {
backend/src/services/deezer.ts:638:            // Search for playlists with this genre
backend/src/services/deezer.ts:639:            const playlists = genreName ? await this.searchPlaylists(genreName, 20) : [];
backend/src/services/deezer.ts:642:            const radiosResponse = await axios.get(`${DEEZER_API}/radio/genres`, {
backend/src/services/deezer.ts:647:            const radios: DeezerRadioStation[] = (genreRadios?.radios || []).map((radio: any) => ({
backend/src/services/deezer.ts:655:            return { playlists, radios };
backend/src/services/deezer.ts:657:            console.error("Deezer editorial content error:", error.message);
backend/src/services/deezer.ts:658:            return { playlists: [], radios: [] };
backend/src/services/deezer.ts:663:export const deezerService = new DeezerService();
frontend/features/discover/components/DiscoverSettings.tsx:13:    onPlaylistCleared?: () => void;
frontend/features/discover/components/DiscoverSettings.tsx:19:    onPlaylistCleared,
frontend/features/discover/components/DiscoverSettings.tsx:44:    async function handleClearPlaylist() {
frontend/features/discover/components/DiscoverSettings.tsx:48:            "Clear Discovery Playlist?\n\n" +
frontend/features/discover/components/DiscoverSettings.tsx:58:            const result = await api.clearDiscoverPlaylist();
frontend/features/discover/components/DiscoverSettings.tsx:76:            onPlaylistCleared?.();
frontend/features/discover/components/DiscoverSettings.tsx:78:            toast.error("Failed to clear playlist");
frontend/features/discover/components/DiscoverSettings.tsx:91:                            Playlist Size: {config?.playlistSize || 10} songs
frontend/features/discover/components/DiscoverSettings.tsx:98:                            value={config?.playlistSize || 10}
frontend/features/discover/components/DiscoverSettings.tsx:100:                                handleConfigChange("playlistSize", parseInt(e.target.value))
frontend/features/discover/components/DiscoverSettings.tsx:111:                            Download Buffer: {((config?.downloadRatio ?? 1.3) * 100 - 100).toFixed(0)}% extra
frontend/features/discover/components/DiscoverSettings.tsx:118:                            value={config?.downloadRatio ?? 1.3}
frontend/features/discover/components/DiscoverSettings.tsx:120:                                handleConfigChange("downloadRatio", parseFloat(e.target.value))
frontend/features/discover/components/DiscoverSettings.tsx:125:                            Extra albums to download in case some fail. Higher = more reliable, but uses more bandwidth.
frontend/features/discover/components/DiscoverSettings.tsx:153:                    {/* Clear Playlist */}
frontend/features/discover/components/DiscoverSettings.tsx:156:                            Clear Playlist
frontend/features/discover/components/DiscoverSettings.tsx:159:                            Remove the current playlist. Liked albums will be moved
frontend/features/discover/components/DiscoverSettings.tsx:163:                            onClick={handleClearPlaylist}
frontend/features/discover/components/DiscoverSettings.tsx:172:                            {isClearing ? "Clearing..." : "Remove Playlist"}
backend/src/routes/discover.ts:58:// RECOMMENDATION-ONLY ENDPOINT (No Auto-Download)
backend/src/routes/discover.ts:69: * This is a preview-only mode that returns recommendations without downloading.
backend/src/routes/discover.ts:70: * Users can browse artists, check top tracks, then manually download if interested.
backend/src/routes/discover.ts:454:- Artists who "fit the same playlist"
backend/src/routes/discover.ts:500:- "Fits the same playlist" feeling
backend/src/routes/discover.ts:679:// LEGACY ENDPOINTS (Download-based - kept for backwards compatibility)
backend/src/routes/discover.ts:691:                status: { in: ["downloading", "scanning"] },
backend/src/routes/discover.ts:731:// POST /discover/generate - Generate new Discover Weekly playlist (using Bull queue)
backend/src/routes/discover.ts:740:                status: { in: ["downloading", "scanning"] },
backend/src/routes/discover.ts:791:// GET /discover/current - Get current week's Discover Weekly playlist
backend/src/routes/discover.ts:809:            orderBy: { downloadedAt: "asc" },
backend/src/routes/discover.ts:894:                    // Album not in library yet (downloading/pending)
backend/src/routes/discover.ts:913:        // Get the list of successfully downloaded album MBIDs from discoveryAlbums
backend/src/routes/discover.ts:917:        // 1. Remove albums that successfully downloaded (have DiscoveryAlbum record)
backend/src/routes/discover.ts:921:            // Skip if this album successfully downloaded this week
backend/src/routes/discover.ts:962:            deezerTrackId: album.deezerTrackId,
backend/src/routes/discover.ts:963:            deezerAlbumId: album.deezerAlbumId,
backend/src/routes/discover.ts:1001:            error: "Failed to get Discover Weekly playlist",
backend/src/routes/discover.ts:1227:                    playlistSize: 10,
backend/src/routes/discover.ts:1230:                    downloadRatio: 1.3,
backend/src/routes/discover.ts:1250:        const { playlistSize, maxRetryAttempts, exclusionMonths, downloadRatio, enabled, discoveryMode, discoveryTimeframe, includeLibraryArtists } = req.body;
backend/src/routes/discover.ts:1252:        // Validate playlist size
backend/src/routes/discover.ts:1253:        if (playlistSize !== undefined) {
backend/src/routes/discover.ts:1254:            const size = parseInt(playlistSize, 10);
backend/src/routes/discover.ts:1257:                    error: "Invalid playlist size. Must be between 5-50 in increments of 5.",
backend/src/routes/discover.ts:1282:        // Validate download ratio
backend/src/routes/discover.ts:1283:        if (downloadRatio !== undefined) {
backend/src/routes/discover.ts:1284:            const ratio = parseFloat(downloadRatio);
backend/src/routes/discover.ts:1287:                    error: "Invalid download ratio. Must be between 1.0-2.0.",
backend/src/routes/discover.ts:1316:                playlistSize: playlistSize ?? 10,
backend/src/routes/discover.ts:1319:                downloadRatio: downloadRatio ?? 1.3,
backend/src/routes/discover.ts:1326:                ...(playlistSize !== undefined && {
backend/src/routes/discover.ts:1327:                    playlistSize: parseInt(playlistSize, 10),
backend/src/routes/discover.ts:1335:                ...(downloadRatio !== undefined && {
backend/src/routes/discover.ts:1336:                    downloadRatio: parseFloat(downloadRatio),
backend/src/routes/discover.ts:1370:// DELETE /discover/clear - Clear the discovery playlist (move liked to library, delete the rest)
backend/src/routes/discover.ts:1375:        console.log(`\n Clearing Discover Weekly playlist for user ${userId}`);
backend/src/routes/discover.ts:1723:        // ALSO clean up "extra" downloaded albums that didn't make the final playlist
backend/src/routes/discover.ts:1724:        // These are in DownloadJob but not in DiscoveryAlbum
backend/src/routes/discover.ts:1727:            const completedJobs = await prisma.downloadJob.findMany({
backend/src/routes/discover.ts:1749:            // Find completed jobs that didn't make the playlist AND aren't from liked artists
backend/src/routes/discover.ts:1875:        // Get all failed download jobs for this user and remove their artists from Lidarr
backend/src/routes/discover.ts:1879:            const failedJobs = await prisma.downloadJob.findMany({
backend/src/routes/discover.ts:1957:            // DON'T delete download jobs immediately - scanner needs them to identify discovery albums
backend/src/routes/discover.ts:1960:            await prisma.downloadJob.deleteMany({
backend/src/routes/discover.ts:1971:        // This can happen if downloads failed or playlist build failed
backend/src/routes/discover.ts:2078:                downloadedAt: { lt: thirtyDaysAgo },
backend/src/routes/discover.ts:2160:            message: "Discovery playlist cleared",
backend/src/routes/discover.ts:2167:        console.error("Clear discovery playlist error:", error?.message || error);
backend/src/routes/discover.ts:2170:            error: "Failed to clear discovery playlist",
backend/src/routes/discover.ts:2312:                // Check if artist has any ACTIVE discovery albums (current playlist)
frontend/features/artist/components/PopularTracks.tsx:65:                    // Use Deezer album cover for previews, fall back to track's album art
frontend/features/artist/components/PopularTracks.tsx:68:                        ? previewCover  // Deezer cover is already a full URL
frontend/features/artist/components/PopularTracks.tsx:163:                                        {/* Use Deezer album info if available, otherwise fall back to track data */}
frontend/features/artist/components/AvailableAlbums.tsx:14:    onDownloadAlbum: (album: Album, e: React.MouseEvent) => void;
frontend/features/artist/components/AvailableAlbums.tsx:16:    isPendingDownload: (mbid: string) => boolean;
frontend/features/artist/components/AvailableAlbums.tsx:24:    onDownloadAlbum,
frontend/features/artist/components/AvailableAlbums.tsx:26:    isPendingDownload,
frontend/features/artist/components/AvailableAlbums.tsx:32:    onDownloadAlbum: (album: Album, e: React.MouseEvent) => void;
frontend/features/artist/components/AvailableAlbums.tsx:34:    isPendingDownload: (mbid: string) => boolean;
frontend/features/artist/components/AvailableAlbums.tsx:82:    // Get MBID for download tracking
frontend/features/artist/components/AvailableAlbums.tsx:102:            badge="download"
frontend/features/artist/components/AvailableAlbums.tsx:105:            isDownloading={isPendingDownload(albumMbid)}
frontend/features/artist/components/AvailableAlbums.tsx:106:            onDownload={(e) => onDownloadAlbum(album, e)}
frontend/features/artist/components/AvailableAlbums.tsx:117:    onDownloadAlbum,
frontend/features/artist/components/AvailableAlbums.tsx:119:    isPendingDownload,
frontend/features/artist/components/AvailableAlbums.tsx:129:                    onDownloadAlbum={onDownloadAlbum}
frontend/features/artist/components/AvailableAlbums.tsx:131:                    isPendingDownload={isPendingDownload}
frontend/features/artist/components/AvailableAlbums.tsx:144:    onDownloadAlbum,
frontend/features/artist/components/AvailableAlbums.tsx:146:    isPendingDownload,
frontend/features/artist/components/AvailableAlbums.tsx:173:                            onDownloadAlbum={onDownloadAlbum}
frontend/features/artist/components/AvailableAlbums.tsx:175:                            isPendingDownload={isPendingDownload}
frontend/features/artist/components/AvailableAlbums.tsx:192:                            onDownloadAlbum={onDownloadAlbum}
frontend/features/artist/components/AvailableAlbums.tsx:194:                            isPendingDownload={isPendingDownload}
backend/src/services/lidarr.ts:514:            // even if we don't want to download all albums
backend/src/services/lidarr.ts:710:                    false, // Don't auto-download all albums
backend/src/services/lidarr.ts:712:                    isDiscovery // Tag as discovery if this is a discovery download
backend/src/services/lidarr.ts:802:            // wrong albums to be downloaded (e.g., "A Trip To The Mystery Planet" matching "A Funk Odyssey")
backend/src/services/lidarr.ts:875:                // We should NOT download a random album that isn't what was requested
backend/src/services/lidarr.ts:972:                    console.warn(`   Download will be attempted but may fail.`);
backend/src/services/lidarr.ts:976:            // ALWAYS trigger search to download the album
backend/src/services/lidarr.ts:1021:                        throw new Error("No releases available - indexers found no matching downloads");
backend/src/services/lidarr.ts:1027:                    throw new Error("No releases available - indexers found no matching downloads");
backend/src/services/lidarr.ts:1031:            console.log(`   Album download started: ${updatedAlbum.title}`);
backend/src/services/lidarr.ts:1109:            // Check if artist has active downloads - don't delete if so
backend/src/services/lidarr.ts:1110:            const hasActive = await this.hasActiveDownloads(lidarrArtist.id);
backend/src/services/lidarr.ts:1112:                console.log(`[LIDARR] Skipping delete for ${lidarrArtist.artistName} - has active downloads`);
backend/src/services/lidarr.ts:1113:                return { success: false, message: "Artist has active downloads in queue" };
backend/src/services/lidarr.ts:1194:     * Check if an album exists in Lidarr and has files (already downloaded)
backend/src/services/lidarr.ts:1534:     * Check if an artist has active downloads in Lidarr's queue
backend/src/services/lidarr.ts:1536:    async hasActiveDownloads(lidarrArtistId: number): Promise<boolean> {
backend/src/services/lidarr.ts:1558:            return false; // Assume no downloads if we can't check
backend/src/services/lidarr.ts:1564:     * Will skip deletion if artist has active downloads in queue
backend/src/services/lidarr.ts:1577:            // Check if artist has active downloads - don't delete if so
backend/src/services/lidarr.ts:1578:            const hasActive = await this.hasActiveDownloads(lidarrId);
backend/src/services/lidarr.ts:1580:                console.log(`[LIDARR] Skipping delete for artist ${lidarrId} - has active downloads`);
backend/src/services/lidarr.ts:1581:                return { success: false, message: "Artist has active downloads in queue" };
backend/src/services/lidarr.ts:1651:     * Grab (download) a specific release by GUID
backend/src/services/lidarr.ts:1652:     * This tells Lidarr to download the specified release
backend/src/services/lidarr.ts:1681:     * Remove a download from queue and blocklist the release
backend/src/services/lidarr.ts:1682:     * Use skipRedownload=true since we'll manually grab the next release
backend/src/services/lidarr.ts:1684:    async blocklistAndRemove(downloadId: string): Promise<boolean> {
backend/src/services/lidarr.ts:1692:            // Find the queue item by downloadId
backend/src/services/lidarr.ts:1698:                (item: any) => item.downloadId === downloadId
backend/src/services/lidarr.ts:1702:                console.log(`[LIDARR] Download ${downloadId} not found in queue (may already be removed)`);
backend/src/services/lidarr.ts:1712:                    skipRedownload: true, // We'll grab the next release manually
backend/src/services/lidarr.ts:1725:     * Find queue item by download ID
backend/src/services/lidarr.ts:1727:    async findQueueItemByDownloadId(downloadId: string): Promise<any | null> {
backend/src/services/lidarr.ts:1740:                (item: any) => item.downloadId === downloadId
backend/src/services/lidarr.ts:1835:// Interface for release data from Lidarr (exported for use by simpleDownloadManager)
backend/src/services/lidarr.ts:1865:    downloadId: string;
backend/src/services/lidarr.ts:1866:    trackedDownloadStatus: string;
backend/src/services/lidarr.ts:1867:    trackedDownloadState: string;
backend/src/services/lidarr.ts:1881:    downloadId: string;
backend/src/services/lidarr.ts:1905:// Patterns that indicate a stuck download (case-insensitive matching)
backend/src/services/lidarr.ts:1927:    // Download/transfer issues
backend/src/services/lidarr.ts:1928:    "Download failed",
backend/src/services/lidarr.ts:1934: * Clean stuck downloads from Lidarr queue
backend/src/services/lidarr.ts:1937:export async function cleanStuckDownloads(
backend/src/services/lidarr.ts:1969:                `      Status: ${item.status}, TrackedStatus: ${item.trackedDownloadStatus}, State: ${item.trackedDownloadState}`
backend/src/services/lidarr.ts:1982:            // Also check if trackedDownloadStatus is "warning" with importPending state
backend/src/services/lidarr.ts:1983:            // These are items that have finished downloading but can't be imported
backend/src/services/lidarr.ts:1985:                item.trackedDownloadStatus === "warning" &&
backend/src/services/lidarr.ts:1986:                item.trackedDownloadState === "importPending";
backend/src/services/lidarr.ts:1990:            const isImportFailed = item.trackedDownloadState === "importFailed";
backend/src/services/lidarr.ts:2008:                            skipRedownload: false, // DO trigger new search
backend/src/services/lidarr.ts:2041: * Get recently completed downloads from Lidarr history
backend/src/services/lidarr.ts:2044:export async function getRecentCompletedDownloads(
backend/src/services/lidarr.ts:2058:                    eventType: 3, // 3 = downloadFolderImported (successful import)
backend/src/services/lidarr.ts:2101: * Check if a specific download is still actively downloading in Lidarr's queue
backend/src/services/lidarr.ts:2102: * Returns true if actively downloading, false if not found or stuck
backend/src/services/lidarr.ts:2104:export async function isDownloadActive(
backend/src/services/lidarr.ts:2105:    downloadId: string
backend/src/services/lidarr.ts:2125:        const item = response.data.records.find(r => r.downloadId === downloadId);
backend/src/services/lidarr.ts:2131:        // Check if it's actively downloading (not stuck in warning/failed state)
backend/src/services/lidarr.ts:2132:        const isActivelyDownloading = 
backend/src/services/lidarr.ts:2133:            item.status === "downloading" || 
backend/src/services/lidarr.ts:2134:            (item.trackedDownloadState === "downloading" && item.trackedDownloadStatus !== "warning");
backend/src/services/lidarr.ts:2137:            active: isActivelyDownloading,
backend/src/services/lidarr.ts:2138:            status: item.trackedDownloadState || item.status,
backend/src/services/lidarr.ts:2144:        console.error("Failed to check download status:", error.message);
backend/src/services/simpleDownloadManager.ts:2: * Simple Download Manager (Refactored)
backend/src/services/simpleDownloadManager.ts:4: * Stateless download service that uses the database as the single source of truth.
backend/src/services/simpleDownloadManager.ts:5: * Handles album downloads with automatic retry, blocklisting, and completion tracking.
backend/src/services/simpleDownloadManager.ts:14:import { sessionLog } from "../utils/playlistLogger";
backend/src/services/simpleDownloadManager.ts:23:class SimpleDownloadManager {
backend/src/services/simpleDownloadManager.ts:44:     * Start a new download
backend/src/services/simpleDownloadManager.ts:48:    async startDownload(
backend/src/services/simpleDownloadManager.ts:56:        console.log(`\n Starting download: ${artistName} - ${albumTitle}${isDiscovery ? " (discovery)" : ""}`);
backend/src/services/simpleDownloadManager.ts:78:                    // This prevents downloading wrong artist when MusicBrainz data is incorrect
backend/src/services/simpleDownloadManager.ts:115:            // Add album to Lidarr (with discovery tag if this is a discovery download)
backend/src/services/simpleDownloadManager.ts:144:            const existingJob = await prisma.downloadJob.findUnique({
backend/src/services/simpleDownloadManager.ts:150:            await prisma.downloadJob.update({
backend/src/services/simpleDownloadManager.ts:166:                        downloadType: existingMetadata.downloadType || "library",
backend/src/services/simpleDownloadManager.ts:173:                `   Download started with correlation ID: ${correlationId}`
backend/src/services/simpleDownloadManager.ts:177:            console.error(`   Failed to start download:`, error.message);
backend/src/services/simpleDownloadManager.ts:180:            const job = await prisma.downloadJob.findUnique({
backend/src/services/simpleDownloadManager.ts:211:            await prisma.downloadJob.update({
backend/src/services/simpleDownloadManager.ts:232:     * Handle download grabbed event (from webhook)
backend/src/services/simpleDownloadManager.ts:233:     * Links the Lidarr downloadId to our job
backend/src/services/simpleDownloadManager.ts:238:    async onDownloadGrabbed(
backend/src/services/simpleDownloadManager.ts:239:        downloadId: string,
backend/src/services/simpleDownloadManager.ts:245:        console.log(`[DOWNLOAD] Grabbed: ${artistName} - ${albumTitle}`);
backend/src/services/simpleDownloadManager.ts:246:        console.log(`   Download ID: ${downloadId}`);
backend/src/services/simpleDownloadManager.ts:252:        const activeJobs = await prisma.downloadJob.findMany({
backend/src/services/simpleDownloadManager.ts:287:        // Strategy 3: Match by lidarrAlbumId (stored when download started)
backend/src/services/simpleDownloadManager.ts:305:                if (j.lidarrRef) return false; // Already linked to a different download
backend/src/services/simpleDownloadManager.ts:381:            // Still no match - this is truly an external download or timing issue
backend/src/services/simpleDownloadManager.ts:385:            // Check if there's already a tracking job for this exact download
backend/src/services/simpleDownloadManager.ts:386:            const existingTrackingJob = await prisma.downloadJob.findFirst({
backend/src/services/simpleDownloadManager.ts:388:                    lidarrRef: downloadId,
backend/src/services/simpleDownloadManager.ts:398:            const duplicateCheck = await prisma.downloadJob.findFirst({
backend/src/services/simpleDownloadManager.ts:416:            console.log(`   Creating tracking job for untracked download`);
backend/src/services/simpleDownloadManager.ts:419:                // Find the user from a recent artist download request
backend/src/services/simpleDownloadManager.ts:420:                const recentJob = await prisma.downloadJob.findFirst({
backend/src/services/simpleDownloadManager.ts:435:                    const newJob = await prisma.downloadJob.create({
backend/src/services/simpleDownloadManager.ts:442:                            lidarrRef: downloadId,
backend/src/services/simpleDownloadManager.ts:448:                                downloadId,
backend/src/services/simpleDownloadManager.ts:467:        await prisma.downloadJob.update({
backend/src/services/simpleDownloadManager.ts:471:                lidarrRef: downloadId,
backend/src/services/simpleDownloadManager.ts:476:                    downloadId,
backend/src/services/simpleDownloadManager.ts:488:     * Handle download complete event (from webhook)
backend/src/services/simpleDownloadManager.ts:492:    async onDownloadComplete(
backend/src/services/simpleDownloadManager.ts:493:        downloadId: string,
backend/src/services/simpleDownloadManager.ts:498:    ): Promise<{ jobId?: string; batchId?: string; downloadBatchId?: string }> {
backend/src/services/simpleDownloadManager.ts:499:        console.log(`\n[COMPLETE] Download completed: ${downloadId}`);
backend/src/services/simpleDownloadManager.ts:506:        const activeJobs = await prisma.downloadJob.findMany({
backend/src/services/simpleDownloadManager.ts:522:        job = activeJobs.find((j) => j.lidarrRef === downloadId);
backend/src/services/simpleDownloadManager.ts:531:        // Strategy 3: Match by previousDownloadIds (for retried downloads)
backend/src/services/simpleDownloadManager.ts:535:                const prevIds = metadata?.previousDownloadIds as string[] | undefined;
backend/src/services/simpleDownloadManager.ts:536:                return prevIds?.includes(downloadId);
backend/src/services/simpleDownloadManager.ts:538:            if (job) console.log(`    Matched by previousDownloadIds`);
backend/src/services/simpleDownloadManager.ts:588:            console.log(`   No matching job found for downloadId: ${downloadId}`);
backend/src/services/simpleDownloadManager.ts:593:        // Mark extras as completed too (they're the same logical download)
backend/src/services/simpleDownloadManager.ts:629:            await prisma.downloadJob.updateMany({
backend/src/services/simpleDownloadManager.ts:640:        await prisma.downloadJob.update({
backend/src/services/simpleDownloadManager.ts:645:                error: null, // Clear any timeout errors since download succeeded
backend/src/services/simpleDownloadManager.ts:655:        // Send notification for completed download (skip for discovery/import batches)
backend/src/services/simpleDownloadManager.ts:658:        const isDiscovery = meta?.downloadType === "discovery";
backend/src/services/simpleDownloadManager.ts:659:        const isSpotifyImport = !!meta?.spotifyImportJobId;
backend/src/services/simpleDownloadManager.ts:662:        if (!isDiscovery && !isSpotifyImport && !notificationAlreadySent) {
backend/src/services/simpleDownloadManager.ts:664:                await notificationService.notifyDownloadComplete(
backend/src/services/simpleDownloadManager.ts:672:                await prisma.downloadJob.update({
backend/src/services/simpleDownloadManager.ts:682:                console.error("Failed to send download notification:", notifError);
backend/src/services/simpleDownloadManager.ts:687:        const downloadBatchId = metadata?.batchId as string | undefined;
backend/src/services/simpleDownloadManager.ts:688:        const spotifyImportJobId = metadata?.spotifyImportJobId as string | undefined;
backend/src/services/simpleDownloadManager.ts:701:                downloadBatchId,
backend/src/services/simpleDownloadManager.ts:705:        // Check if part of Spotify import
backend/src/services/simpleDownloadManager.ts:706:        if (spotifyImportJobId) {
backend/src/services/simpleDownloadManager.ts:707:            console.log(`   Part of Spotify Import: ${spotifyImportJobId}`);
backend/src/services/simpleDownloadManager.ts:709:            const { spotifyImportService } = await import("./spotifyImport");
backend/src/services/simpleDownloadManager.ts:710:            await spotifyImportService.checkImportCompletion(spotifyImportJobId);
backend/src/services/simpleDownloadManager.ts:713:                spotifyImportJobId,
backend/src/services/simpleDownloadManager.ts:714:                downloadBatchId,
backend/src/services/simpleDownloadManager.ts:718:        // Check if part of download batch (artist download)
backend/src/services/simpleDownloadManager.ts:719:        if (downloadBatchId) {
backend/src/services/simpleDownloadManager.ts:720:            console.log(`   Part of download batch: ${downloadBatchId}`);
backend/src/services/simpleDownloadManager.ts:723:        return { jobId: job.id, downloadBatchId };
backend/src/services/simpleDownloadManager.ts:734:     * 1. Blocklist the failed release with skipRedownload=false (Lidarr searches for alternatives)
backend/src/services/simpleDownloadManager.ts:740:        downloadId: string,
backend/src/services/simpleDownloadManager.ts:744:        console.log(`\n[RETRY] Import failed: ${downloadId}`);
backend/src/services/simpleDownloadManager.ts:747:        // Deduplicate failure events - same downloadId within 30 seconds
backend/src/services/simpleDownloadManager.ts:749:        const lastProcessed = this.processedFailures.get(downloadId);
backend/src/services/simpleDownloadManager.ts:761:        this.processedFailures.set(downloadId, now);
backend/src/services/simpleDownloadManager.ts:773:        const processingJobs = await prisma.downloadJob.findMany({
backend/src/services/simpleDownloadManager.ts:780:        job = processingJobs.find((j) => j.lidarrRef === downloadId);
backend/src/services/simpleDownloadManager.ts:783:        // Strategy 2: Match by previousDownloadIds in metadata
backend/src/services/simpleDownloadManager.ts:787:                const prevIds = metadata?.previousDownloadIds as
backend/src/services/simpleDownloadManager.ts:790:                return prevIds?.includes(downloadId);
backend/src/services/simpleDownloadManager.ts:792:            if (job) console.log(`    Matched by previousDownloadIds`);
backend/src/services/simpleDownloadManager.ts:806:            await this.removeFromLidarrQueue(downloadId);
backend/src/services/simpleDownloadManager.ts:817:        // skipRedownload=false means Lidarr will automatically search for another release
backend/src/services/simpleDownloadManager.ts:821:        const previousDownloadIds = metadata.previousDownloadIds || [];
backend/src/services/simpleDownloadManager.ts:822:        if (downloadId && !previousDownloadIds.includes(downloadId)) {
backend/src/services/simpleDownloadManager.ts:823:            previousDownloadIds.push(downloadId);
backend/src/services/simpleDownloadManager.ts:827:        await prisma.downloadJob.update({
backend/src/services/simpleDownloadManager.ts:836:                    previousDownloadIds,
backend/src/services/simpleDownloadManager.ts:843:        // Blocklist with skipRedownload=false so Lidarr searches for alternatives
backend/src/services/simpleDownloadManager.ts:844:        await this.removeFromLidarrQueue(downloadId);
backend/src/services/simpleDownloadManager.ts:846:        // For Spotify Import jobs, check if this failure completes the import
backend/src/services/simpleDownloadManager.ts:847:        // (Unlike regular downloads, we don't do fallback, so failure might mean completion)
backend/src/services/simpleDownloadManager.ts:848:        if (metadata.spotifyImportJobId) {
backend/src/services/simpleDownloadManager.ts:863:     * - For Spotify Import jobs, we DON'T do same-artist fallback.
backend/src/services/simpleDownloadManager.ts:864:     *   User wants EXACT playlist, not substitutes.
backend/src/services/simpleDownloadManager.ts:883:        // CRITICAL: For Spotify Import, DON'T try same-artist fallback
backend/src/services/simpleDownloadManager.ts:884:        // User wants the EXACT playlist, not substitutes from same artist
backend/src/services/simpleDownloadManager.ts:885:        if (metadata.spotifyImportJobId || metadata.downloadType === "spotify_import" || metadata.noFallback) {
backend/src/services/simpleDownloadManager.ts:886:            console.log(`[RETRY] Spotify Import job - skipping fallback (exact match required)`);
backend/src/services/simpleDownloadManager.ts:893:            if (metadata.spotifyImportJobId) {
backend/src/services/simpleDownloadManager.ts:894:                const { spotifyImportService } = await import("./spotifyImport");
backend/src/services/simpleDownloadManager.ts:895:                await spotifyImportService.checkImportCompletion(metadata.spotifyImportJobId);
backend/src/services/simpleDownloadManager.ts:924:            const artistJobs = await prisma.downloadJob.findMany({
backend/src/services/simpleDownloadManager.ts:958:            await prisma.downloadJob.update({
backend/src/services/simpleDownloadManager.ts:971:            const newJob = await prisma.downloadJob.create({
backend/src/services/simpleDownloadManager.ts:988:                        downloadType: metadata.downloadType || "library",
backend/src/services/simpleDownloadManager.ts:996:            // Start the download
backend/src/services/simpleDownloadManager.ts:997:            const result = await this.startDownload(
backend/src/services/simpleDownloadManager.ts:1006:                console.log(`   Same-artist fallback download started`);
backend/src/services/simpleDownloadManager.ts:1010:                // The new job will be marked as failed by startDownload
backend/src/services/simpleDownloadManager.ts:1038:            const completedDuplicate = await prisma.downloadJob.findFirst({
backend/src/services/simpleDownloadManager.ts:1052:                    await prisma.downloadJob.update({
backend/src/services/simpleDownloadManager.ts:1069:        await prisma.downloadJob.update({
backend/src/services/simpleDownloadManager.ts:1085:        // 1. Not discovery/spotify import
backend/src/services/simpleDownloadManager.ts:1088:        const isDiscovery = meta?.downloadType === "discovery";
backend/src/services/simpleDownloadManager.ts:1089:        const isSpotifyImport = !!meta?.spotifyImportJobId;
backend/src/services/simpleDownloadManager.ts:1092:        if (!isDiscovery && !isSpotifyImport && !notificationAlreadySent) {
backend/src/services/simpleDownloadManager.ts:1094:            const otherNotified = await prisma.downloadJob.findFirst({
backend/src/services/simpleDownloadManager.ts:1117:                    await notificationService.notifyDownloadFailed(
backend/src/services/simpleDownloadManager.ts:1124:                    await prisma.downloadJob.update({
backend/src/services/simpleDownloadManager.ts:1146:     * - Pending jobs (never started) timeout after 3 minutes = "download never started"
backend/src/services/simpleDownloadManager.ts:1156:        const activeJobs = await prisma.downloadJob.findMany({
backend/src/services/simpleDownloadManager.ts:1160:        // Log to session for debugging Spotify imports
backend/src/services/simpleDownloadManager.ts:1162:            const spotifyJobs = activeJobs.filter(j => j.id.startsWith("spotify_"));
backend/src/services/simpleDownloadManager.ts:1163:            if (spotifyJobs.length > 0) {
backend/src/services/simpleDownloadManager.ts:1164:                sessionLog('CLEANUP', `Checking ${activeJobs.length} active jobs (${spotifyJobs.length} Spotify import)`);
backend/src/services/simpleDownloadManager.ts:1183:                await prisma.downloadJob.update({
backend/src/services/simpleDownloadManager.ts:1187:                        error: "Download never started - timed out",
backend/src/services/simpleDownloadManager.ts:1206:        // Import lidarr service for active download check
backend/src/services/simpleDownloadManager.ts:1207:        const { isDownloadActive } = await import("./lidarr");
backend/src/services/simpleDownloadManager.ts:1218:                console.log(`   ${job.subject}: Soulseek download, skipping stale check`);
backend/src/services/simpleDownloadManager.ts:1229:                // Jobs with lidarrRef = grabbed but potentially still downloading
backend/src/services/simpleDownloadManager.ts:1231:                    // Check if Lidarr is still actively downloading before timing out
backend/src/services/simpleDownloadManager.ts:1232:                    const downloadStatus = await isDownloadActive(job.lidarrRef);
backend/src/services/simpleDownloadManager.ts:1234:                    if (downloadStatus.active) {
backend/src/services/simpleDownloadManager.ts:1235:                        // Still downloading - extend the timeout, don't mark as stale
backend/src/services/simpleDownloadManager.ts:1236:                        console.log(`   ${job.subject}: Still downloading (${downloadStatus.progress || 0}%), extending timeout`);
backend/src/services/simpleDownloadManager.ts:1239:                        await prisma.downloadJob.update({
backend/src/services/simpleDownloadManager.ts:1250:                        // Not actively downloading - mark as stale
backend/src/services/simpleDownloadManager.ts:1261:        console.log(`\n⏰ Found ${staleJobs.length} stale download jobs`);
backend/src/services/simpleDownloadManager.ts:1266:        const downloadBatchIds = new Set<string>();
backend/src/services/simpleDownloadManager.ts:1271:                ? `Import failed - download stuck for ${
backend/src/services/simpleDownloadManager.ts:1290:                const completedDuplicate = await prisma.downloadJob.findFirst({
backend/src/services/simpleDownloadManager.ts:1304:                        await prisma.downloadJob.update({
backend/src/services/simpleDownloadManager.ts:1354:                await prisma.downloadJob.update({
backend/src/services/simpleDownloadManager.ts:1368:            // Track download batch IDs for artist downloads
backend/src/services/simpleDownloadManager.ts:1370:                downloadBatchIds.add(metadata.batchId);
backend/src/services/simpleDownloadManager.ts:1390:     * skipRedownload=false tells Lidarr to automatically search for another release
backend/src/services/simpleDownloadManager.ts:1392:    private async blocklistAndRetry(downloadId: string, _lidarrAlbumId: number) {
backend/src/services/simpleDownloadManager.ts:1408:                    (item: any) => item.downloadId === downloadId
backend/src/services/simpleDownloadManager.ts:1412:                    // Remove from queue with blocklist=true and skipRedownload=false
backend/src/services/simpleDownloadManager.ts:1415:                        `${settings.lidarrUrl}/api/v1/queue/${queueItem.id}?removeFromClient=true&blocklist=true&skipRedownload=false`,
backend/src/services/simpleDownloadManager.ts:1433:     * Remove a failed download from Lidarr's queue (without retrying)
backend/src/services/simpleDownloadManager.ts:1436:    private async removeFromLidarrQueue(downloadId: string) {
backend/src/services/simpleDownloadManager.ts:1450:                (item: any) => item.downloadId === downloadId
backend/src/services/simpleDownloadManager.ts:1454:                // Remove from queue with blocklist=true and skipRedownload=false
backend/src/services/simpleDownloadManager.ts:1455:                // skipRedownload=false tells Lidarr to search for another release
backend/src/services/simpleDownloadManager.ts:1457:                    `${settings.lidarrUrl}/api/v1/queue/${queueItem.id}?removeFromClient=true&blocklist=true&skipRedownload=false`,
backend/src/services/simpleDownloadManager.ts:1478:     * Clear all failed/stuck items from Lidarr's download queue
backend/src/services/simpleDownloadManager.ts:1492:            console.log(`\nClearing Lidarr download queue...`);
backend/src/services/simpleDownloadManager.ts:1511:            // NOTE: importPending is NOT a failure - it means download complete, waiting for import
backend/src/services/simpleDownloadManager.ts:1515:                    item.trackedDownloadStatus === "error" ||
backend/src/services/simpleDownloadManager.ts:1516:                    item.trackedDownloadState === "importFailed" ||
backend/src/services/simpleDownloadManager.ts:1518:                    ((item.status === "warning" || item.trackedDownloadStatus === "warning") &&
backend/src/services/simpleDownloadManager.ts:1537:                        `${settings.lidarrUrl}/api/v1/queue/${item.id}?removeFromClient=true&blocklist=true&skipRedownload=false`,
backend/src/services/simpleDownloadManager.ts:1592:     * Get statistics about current downloads
backend/src/services/simpleDownloadManager.ts:1601:            prisma.downloadJob.count({ where: { status: "pending" } }),
backend/src/services/simpleDownloadManager.ts:1602:            prisma.downloadJob.count({ where: { status: "processing" } }),
backend/src/services/simpleDownloadManager.ts:1603:            prisma.downloadJob.count({ where: { status: "completed" } }),
backend/src/services/simpleDownloadManager.ts:1604:            prisma.downloadJob.count({ where: { status: "failed" } }),
backend/src/services/simpleDownloadManager.ts:1620:        const processingJobs = await prisma.downloadJob.findMany({
backend/src/services/simpleDownloadManager.ts:1671:                    await prisma.downloadJob.update({
backend/src/services/simpleDownloadManager.ts:1712:export const simpleDownloadManager = new SimpleDownloadManager();
frontend/features/artist/components/ArtistActionBar.tsx:1:import { Play, Pause, Shuffle, Download, Radio } from "lucide-react";
frontend/features/artist/components/ArtistActionBar.tsx:17:    onDownloadAll: () => void;
frontend/features/artist/components/ArtistActionBar.tsx:19:    isPendingDownload: boolean;
frontend/features/artist/components/ArtistActionBar.tsx:32:    onDownloadAll,
frontend/features/artist/components/ArtistActionBar.tsx:34:    isPendingDownload,
frontend/features/artist/components/ArtistActionBar.tsx:42:    const showDownloadAll = source === "discovery" || availableAlbums.length > 0;
frontend/features/artist/components/ArtistActionBar.tsx:89:            {/* Download All Button */}
frontend/features/artist/components/ArtistActionBar.tsx:90:            {showDownloadAll && (
frontend/features/artist/components/ArtistActionBar.tsx:92:                    onClick={onDownloadAll}
frontend/features/artist/components/ArtistActionBar.tsx:93:                    disabled={isPendingDownload}
frontend/features/artist/components/ArtistActionBar.tsx:96:                        isPendingDownload
frontend/features/artist/components/ArtistActionBar.tsx:101:                    <Download className="w-4 h-4" />
frontend/features/artist/components/ArtistActionBar.tsx:103:                        {isPendingDownload ? "Downloading..." : "Download All"}
frontend/features/discover/hooks/useDiscoverActions.ts:5:import { DiscoverTrack, DiscoverPlaylist } from "../types";
frontend/features/discover/hooks/useDiscoverActions.ts:8:    playlist: DiscoverPlaylist | null,
frontend/features/discover/hooks/useDiscoverActions.ts:28:            toast.info("Generating your Discover Weekly playlist...");
frontend/features/discover/hooks/useDiscoverActions.ts:36:            toast.success("Generation started! Downloading albums...");
frontend/features/discover/hooks/useDiscoverActions.ts:43:                toast.warning("A playlist is already being generated...");
frontend/features/discover/hooks/useDiscoverActions.ts:49:                toast.error(error.message || "Failed to generate playlist");
frontend/features/discover/hooks/useDiscoverActions.ts:82:    const handlePlayPlaylist = useCallback(() => {
frontend/features/discover/hooks/useDiscoverActions.ts:83:        if (!playlist || playlist.tracks.length === 0) return;
frontend/features/discover/hooks/useDiscoverActions.ts:85:        const formattedTracks = playlist.tracks.map((track) => ({
frontend/features/discover/hooks/useDiscoverActions.ts:98:    }, [playlist, playTracks]);
frontend/features/discover/hooks/useDiscoverActions.ts:102:            if (!playlist || playlist.tracks.length === 0) return;
frontend/features/discover/hooks/useDiscoverActions.ts:104:            const formattedTracks = playlist.tracks.map((track) => ({
frontend/features/discover/hooks/useDiscoverActions.ts:118:        [playlist, playTracks]
frontend/features/discover/hooks/useDiscoverActions.ts:132:        handlePlayPlaylist,
frontend/features/discover/types/index.ts:25:    deezerTrackId: string | null;
frontend/features/discover/types/index.ts:26:    deezerAlbumId: string | null;
frontend/features/discover/types/index.ts:32:export interface DiscoverPlaylist {
frontend/features/discover/types/index.ts:42:    playlistSize: number;
frontend/features/discover/hooks/useDiscoverData.ts:3:import type { DiscoverPlaylist, DiscoverConfig } from '../types';
frontend/features/discover/hooks/useDiscoverData.ts:7:  status: "downloading" | "scanning" | null;
frontend/features/discover/hooks/useDiscoverData.ts:16:  const [playlist, setPlaylist] = useState<DiscoverPlaylist | null>(null);
frontend/features/discover/hooks/useDiscoverData.ts:32:      const [playlistData, configData] = await Promise.all([
frontend/features/discover/hooks/useDiscoverData.ts:37:      setPlaylist(playlistData);
frontend/features/discover/hooks/useDiscoverData.ts:56:        console.log('[Discover] Batch completed, reloading playlist data...');
frontend/features/discover/hooks/useDiscoverData.ts:114:      // Load playlist data
frontend/features/discover/hooks/useDiscoverData.ts:144:    setPlaylist(prev => {
frontend/features/discover/hooks/useDiscoverData.ts:158:    playlist,
frontend/features/album/hooks/useAlbumData.ts:6:import { useDownloadContext } from "@/lib/download-context";
frontend/features/album/hooks/useAlbumData.ts:14:    const { downloadStatus } = useDownloadContext();
frontend/features/album/hooks/useAlbumData.ts:15:    const prevActiveCountRef = useRef(downloadStatus.activeDownloads.length);
frontend/features/album/hooks/useAlbumData.ts:17:    // Use React Query with dynamic refetch interval based on download status
frontend/features/album/hooks/useAlbumData.ts:36:        // Poll every 5 seconds when there are active downloads
frontend/features/album/hooks/useAlbumData.ts:37:        refetchInterval: downloadStatus.hasActiveDownloads ? 5000 : false,
frontend/features/album/hooks/useAlbumData.ts:40:    // Refetch when downloads complete (active count decreases)
frontend/features/album/hooks/useAlbumData.ts:42:        const currentActiveCount = downloadStatus.activeDownloads.length;
frontend/features/album/hooks/useAlbumData.ts:47:            // Downloads have completed, refresh data
frontend/features/album/hooks/useAlbumData.ts:51:    }, [downloadStatus.activeDownloads.length, refetch]);
frontend/features/album/hooks/useTrackPreview.ts:34:        toast("No Deezer preview available", { duration: 1500 });
frontend/features/album/hooks/useAlbumActions.ts:3:import { useDownloadContext } from "@/lib/download-context";
frontend/features/album/hooks/useAlbumActions.ts:13:    const { addPendingDownload, isPendingByMbid } = useDownloadContext();
frontend/features/album/hooks/useAlbumActions.ts:124:    const downloadAlbum = async (album: Album | null, e?: React.MouseEvent) => {
frontend/features/album/hooks/useAlbumActions.ts:141:            toast.info("Album is already being downloaded");
frontend/features/album/hooks/useAlbumActions.ts:146:            addPendingDownload("album", album.title, mbid);
frontend/features/album/hooks/useAlbumActions.ts:149:            toast.loading(`Preparing download: "${album.title}"...`, {
frontend/features/album/hooks/useAlbumActions.ts:150:                id: `download-${mbid}`,
frontend/features/album/hooks/useAlbumActions.ts:153:            await api.downloadAlbum(
frontend/features/album/hooks/useAlbumActions.ts:160:            toast.success(`Downloading "${album.title}"`, {
frontend/features/album/hooks/useAlbumActions.ts:161:                id: `download-${mbid}`,
frontend/features/album/hooks/useAlbumActions.ts:164:            console.error("Failed to download album:", error);
frontend/features/album/hooks/useAlbumActions.ts:165:            toast.error("Failed to start album download", {
frontend/features/album/hooks/useAlbumActions.ts:166:                id: `download-${mbid}`,
frontend/features/album/hooks/useAlbumActions.ts:176:        downloadAlbum,
frontend/features/album/components/TrackList.tsx:15:  onAddToPlaylist: (trackId: string) => void;
frontend/features/album/components/TrackList.tsx:32:  onAddToPlaylist: (trackId: string) => void;
frontend/features/album/components/TrackList.tsx:124:  onAddToPlaylist,
frontend/features/album/components/TrackList.tsx:134:  const handleAddToPlaylist = useCallback((e: React.MouseEvent) => {
frontend/features/album/components/TrackList.tsx:136:    onAddToPlaylist(track.id);
frontend/features/album/components/TrackList.tsx:137:  }, [track.id, onAddToPlaylist]);
frontend/features/album/components/TrackList.tsx:255:            onClick={handleAddToPlaylist}
frontend/features/album/components/TrackList.tsx:257:            aria-label="Add to playlist"
frontend/features/album/components/TrackList.tsx:258:            title="Add to playlist"
frontend/features/album/components/TrackList.tsx:305:  onAddToPlaylist,
frontend/features/album/components/TrackList.tsx:378:                      onAddToPlaylist={onAddToPlaylist}
frontend/features/album/components/AlbumActionBar.tsx:2:import { Play, Pause, Shuffle, Download, ListPlus, Search } from "lucide-react";
frontend/features/album/components/AlbumActionBar.tsx:16:    onDownloadAlbum: () => void;
frontend/features/album/components/AlbumActionBar.tsx:17:    onAddToPlaylist: () => void;
frontend/features/album/components/AlbumActionBar.tsx:18:    isPendingDownload: boolean;
frontend/features/album/components/AlbumActionBar.tsx:30:    onDownloadAlbum,
frontend/features/album/components/AlbumActionBar.tsx:31:    onAddToPlaylist,
frontend/features/album/components/AlbumActionBar.tsx:32:    isPendingDownload,
frontend/features/album/components/AlbumActionBar.tsx:40:    const showDownload = !isOwned && (album.mbid || album.rgMbid);
frontend/features/album/components/AlbumActionBar.tsx:80:                        {/* Add to Playlist Button */}
frontend/features/album/components/AlbumActionBar.tsx:82:                            onClick={onAddToPlaylist}
frontend/features/album/components/AlbumActionBar.tsx:84:                            title="Add to playlist"
frontend/features/album/components/AlbumActionBar.tsx:91:                {/* Download Album Buttons - for unowned albums */}
frontend/features/album/components/AlbumActionBar.tsx:92:                {showDownload && (
frontend/features/album/components/AlbumActionBar.tsx:94:                        {/* Quick Download Button (Auto) */}
frontend/features/album/components/AlbumActionBar.tsx:96:                            onClick={onDownloadAlbum}
frontend/features/album/components/AlbumActionBar.tsx:97:                            disabled={isPendingDownload}
frontend/features/album/components/AlbumActionBar.tsx:100:                                isPendingDownload
frontend/features/album/components/AlbumActionBar.tsx:104:                            title="Auto-download best release"
frontend/features/album/components/AlbumActionBar.tsx:106:                            <Download className="w-4 h-4" />
frontend/features/album/components/AlbumActionBar.tsx:108:                                {isPendingDownload ? "Downloading..." : "Download"}
frontend/features/album/components/AlbumActionBar.tsx:115:                            disabled={isPendingDownload}
frontend/features/album/components/AlbumActionBar.tsx:118:                                isPendingDownload
frontend/features/album/components/AlbumActionBar.tsx:132:            {showDownload && (
